[
  {
    "id": "gs_mixbytes_mantle-meth-aave_M01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Mantle mETH x Aave Integration Security Audit",
    "source_finding_id": "M-1",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
    "github_repo_url": "https://github.com/mantle-lsp/contracts",
    "contest_date": "2025-10-22",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Default manager deactivation in LiquidityBuffer can break auto-allocation",
    "finding_description": "Staking.allocateETH() forwards ETH to LiquidityBuffer.depositETH(), which auto-allocates to defaultManagerId when shouldExecuteAllocation is true. If the current default manager is deactivated via LiquidityBuffer.updatePositionManager()/togglePositionManagerStatus() without first switching defaultManagerId or disabling auto-allocation, _allocateETHToManager(defaultManagerId, â€¦) reverts with LiquidityBuffer__ManagerInactive(). This can unexpectedly block allocation flows.",
    "attack_scenario": "1. Admin sets defaultManagerId to manager 0 with shouldExecuteAllocation = true\n2. Admin calls togglePositionManagerStatus(0) to deactivate the default manager\n3. User calls Staking.allocateETH() which forwards to LiquidityBuffer.depositETH()\n4. depositETH() calls _allocateETHToManager(defaultManagerId, msg.value)\n5. _allocateETHToManager reverts with LiquidityBuffer__ManagerInactive() because the default manager is inactive\n6. All allocation flows are blocked until admin either reactivates the manager or changes defaultManagerId",
    "fix_description": "Prevent deactivation of the current defaultManagerId while auto-allocation is enabled: require shouldExecuteAllocation == false or switch defaultManagerId to an active manager before deactivation.",
    "primary_file": {
      "path": "src/liquidityBuffer/LiquidityBuffer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed managerId, uint256 amount);\n    event ETHReturnedToStaking(uint256 amount);\n    event ETHAllocatedToManager(uint256 indexed managerId, uint256 amount);\n    event ETHReceivedFromStaking(uint256 amount);\n    event FeesCollected(uint256 amount);\n    event InterestClaimed(\n        uint256 indexed managerId,\n        uint256 interestAmount\n    );\n    event InterestToppedUp(\n        uint256 amount\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = keccak256(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = keccak256(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = keccak256(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public stakingContract;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public pauser;\n\n    /// @notice Total number of position managers\n    uint256 public positionManagerCount;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public positionManagerConfigs;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public positionAccountants;\n\n    /// @notice Total funds received from staking contract\n    uint256 public totalFundsReceived;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public totalFundsReturned;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public totalAllocatedBalance;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public totalInterestClaimed;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public totalInterestToppedUp;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public totalAllocationCapacity;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public cumulativeDrawdown;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public defaultManagerId;\n\n    /// @notice The address receiving protocol fees.\n    address payable public feesReceiver;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public feesBasisPoints;\n\n    uint256 public totalFeesCollected;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public pendingInterest;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public pendingPrincipal;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public shouldExecuteAllocation;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public isRegisteredManager;\n\n    struct Init {\n        address admin;\n        address liquidityManager;\n        address positionManager;\n        address interestTopUp;\n        address drawdownManager;\n        address payable feesReceiver;\n        IStakingReturnsWrite staking;\n        IPauserRead pauser;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n        _grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n        _grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n        _grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\n        \n        stakingContract = init.staking;\n        pauser = init.pauser;\n        feesReceiver = init.feesReceiver;\n        shouldExecuteAllocation = true;\n        \n        _grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function getInterestAmount(uint256 managerId) public view returns (uint256) {        \n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        // Get current underlying balance from position manager\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        uint256 currentBalance = manager.getUnderlyingBalance();\n        \n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory accounting = positionAccountants[managerId];\n        \n        if (currentBalance > accounting.allocatedBalance) {\n            return currentBalance - accounting.allocatedBalance;\n        }\n        \n        return 0;\n    }\n\n    function getAvailableCapacity() public view returns (uint256) {\n        return totalAllocationCapacity - totalAllocatedBalance;\n    }\n\n    function getAvailableBalance() public view returns (uint256) {\n        return totalFundsReceived - totalFundsReturned;\n    }\n\n    function getControlledBalance() public view returns (uint256) {\n        uint256 totalBalance = address(this).balance;\n        \n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig storage config = positionManagerConfigs[i];\n            if (config.isActive) {\n                IPositionManager manager = IPositionManager(config.managerAddress);\n                uint256 managerBalance = manager.getUnderlyingBalance();\n                totalBalance += managerBalance;\n            }\n        }\n        \n        return totalBalance;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function addPositionManager(\n        address managerAddress,\n        uint256 allocationCap\n    ) external onlyRole(POSITION_MANAGER_ROLE) returns (uint256 managerId) {\n        if (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        managerId = positionManagerCount;\n        positionManagerCount++;\n\n        positionManagerConfigs[managerId] = PositionManagerConfig({\n            managerAddress: managerAddress,\n            allocationCap: allocationCap,\n            isActive: true\n        });\n        positionAccountants[managerId] = PositionAccountant({\n            allocatedBalance: 0,\n            interestClaimedFromManager: 0\n        });\n        isRegisteredManager[managerAddress] = true;\n\n        totalAllocationCapacity += allocationCap;\n        emit ProtocolConfigChanged(\n            this.addPositionManager.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.encode(managerAddress, allocationCap)\n        );\n    }\n\n    function updatePositionManager(\n        uint256 managerId,\n        uint256 newAllocationCap,\n        bool isActive\n    ) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n\n        if (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n        \n        // Update total allocation capacity\n        totalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\n        \n        config.allocationCap = newAllocationCap;\n        config.isActive = isActive;\n\n        emit ProtocolConfigChanged(\n            this.updatePositionManager.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.encode(managerId, newAllocationCap, isActive)\n        );\n    }\n\n    function togglePositionManagerStatus(uint256 managerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n        config.isActive = !config.isActive;\n\n        emit ProtocolConfigChanged(\n            this.togglePositionManagerStatus.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.encode(managerId)\n        );\n    }\n\n    function setCumulativeDrawdown(uint256 drawdownAmount) external onlyRole(DRAWDOWN_MANAGER_ROLE) {        \n        cumulativeDrawdown = drawdownAmount;\n        \n        emit ProtocolConfigChanged(\n            this.setCumulativeDrawdown.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.encode(drawdownAmount)\n        );\n    }\n\n    function setDefaultManagerId(uint256 newDefaultManagerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newDefaultManagerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n        \n        if (!positionManagerConfigs[newDefaultManagerId].isActive) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n        \n        defaultManagerId = newDefaultManagerId;\n        \n        emit ProtocolConfigChanged(\n            this.setDefaultManagerId.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.encode(newDefaultManagerId)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function setFeeBasisPoints(uint16 newBasisPoints) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newBasisPoints > _BASIS_POINTS_DENOMINATOR) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        feesBasisPoints = newBasisPoints;\n        emit ProtocolConfigChanged(\n            this.setFeeBasisPoints.selector, \"setFeeBasisPoints(uint16)\", abi.encode(newBasisPoints)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function setFeesReceiver(address payable newReceiver)\n        external\n        onlyRole(POSITION_MANAGER_ROLE)\n        notZeroAddress(newReceiver)\n    {\n        feesReceiver = newReceiver;\n        emit ProtocolConfigChanged(this.setFeesReceiver.selector, \"setFeesReceiver(address)\", abi.encode(newReceiver));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function setShouldExecuteAllocation(bool executeAllocation) external onlyRole(POSITION_MANAGER_ROLE) {\n        shouldExecuteAllocation = executeAllocation;\n        emit ProtocolConfigChanged(this.setShouldExecuteAllocation.selector, \"setShouldExecuteAllocation(bool)\", abi.encode(executeAllocation));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function depositETH() external payable onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        if (pauser.isLiquidityBufferPaused()) revert LiquidityBuffer__Paused();\n        _receiveETHFromStaking(msg.value);\n        if (shouldExecuteAllocation) {\n            _allocateETHToManager(defaultManagerId, msg.value);\n        }\n    }\n\n    function withdrawAndReturn(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n        _returnETHToStaking(amount);\n    }\n\n    function allocateETHToManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _allocateETHToManager(managerId, amount);\n    }\n\n    function withdrawETHFromManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n    }\n\n    function returnETHToStaking(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _returnETHToStaking(amount);\n    }\n\n    function receiveETHFromPositionManager() external payable onlyPositionManagerContract {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function claimInterestFromManager(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return amount;\n    }\n\n    function topUpInterestToStaking(uint256 amount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < amount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n        return amount;\n    }\n\n    function claimInterestAndTopUp(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n\n        return amount;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _topUpInterestToStakingAndCollectFees(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingInterest) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        pendingInterest -= amount;\n        uint256 fees = Math.mulDiv(feesBasisPoints, amount, _BASIS_POINTS_DENOMINATOR);\n        uint256 topUpAmount = amount - fees;\n        stakingContract.topUp{value: topUpAmount}();\n        totalInterestToppedUp += topUpAmount;\n        emit InterestToppedUp(topUpAmount);\n\n        if (fees > 0) {\n            Address.sendValue(feesReceiver, fees);\n            totalFeesCollected += fees;\n            emit FeesCollected(fees);\n        }\n    }\n    \n    function _claimInterestFromManager(uint256 managerId) internal returns (uint256) {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 interestAmount = getInterestAmount(managerId);\n        \n        if (interestAmount > 0) {\n            PositionManagerConfig memory config = positionManagerConfigs[managerId];\n            \n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            positionAccountants[managerId].interestClaimedFromManager += interestAmount;\n            totalInterestClaimed += interestAmount;\n            pendingInterest += interestAmount;\n            emit InterestClaimed(managerId, interestAmount);\n            \n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager manager = IPositionManager(config.managerAddress);\n            manager.withdraw(interestAmount);\n        } else {\n            emit InterestClaimed(managerId, interestAmount);\n        }\n        \n        return interestAmount;\n    }\n\n    function _withdrawETHFromManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage accounting = positionAccountants[managerId];\n\n        // Check sufficient allocation\n        if (amount > accounting.allocatedBalance) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        accounting.allocatedBalance -= amount;\n        totalAllocatedBalance -= amount;\n        pendingPrincipal += amount;\n        emit ETHWithdrawnFromManager(managerId, amount);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.withdraw(amount);\n    }\n\n    function _returnETHToStaking(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        \n        // Validate staking contract is set and not zero address\n        if (address(stakingContract) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n        \n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        totalFundsReturned += amount;\n        pendingPrincipal -= amount;\n        emit ETHReturnedToStaking(amount);\n        \n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        stakingContract.receiveReturnsFromLiquidityBuffer{value: amount}();\n    }\n\n    function _allocateETHToManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n        \n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < amount) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage accounting = positionAccountants[managerId];\n        if (accounting.allocatedBalance + amount > config.allocationCap) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        accounting.allocatedBalance += amount;\n        totalAllocatedBalance += amount;\n        pendingPrincipal -= amount;\n        emit ETHAllocatedToManager(managerId, amount);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.deposit{value: amount}(0);\n    }\n\n    function _receiveETHFromStaking(uint256 amount) internal {\n        totalFundsReceived += amount;\n        pendingPrincipal += amount;\n        emit ETHReceivedFromStaking(amount);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier onlyStakingContract() {\n        if (msg.sender != address(stakingContract)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier onlyPositionManagerContract() {\n        bool isValidManager = false;\n        \n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig memory config = positionManagerConfigs[i];\n            \n            if (msg.sender == config.managerAddress && config.isActive) {\n                isValidManager = true;\n                break;\n            }\n        }\n        \n        if (!isValidManager) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "vulnerable_lines": [230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 334, 335, 336, 337, 338, 339, 340],
      "vulnerable_functions": ["updatePositionManager", "togglePositionManagerStatus", "depositETH", "_allocateETHToManager"]
    },
    "context_files": [],
    "call_flow": "Staking.allocateETH() -> LiquidityBuffer.depositETH() -> _allocateETHToManager(defaultManagerId) -> reverts if defaultManager.isActive == false",
    "context_hint": "The depositETH function auto-allocates to the default manager when shouldExecuteAllocation is true, but updatePositionManager and togglePositionManagerStatus can deactivate the default manager without any check, causing subsequent depositETH calls to revert.",
    "is_vulnerable": true
  },
  {
    "id": "gs_mixbytes_mantle-meth-aave_M02",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Mantle mETH x Aave Integration Security Audit",
    "source_finding_id": "M-2",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
    "github_repo_url": "https://github.com/mantle-lsp/contracts",
    "contest_date": "2025-10-22",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Inactive managers may under-report funds",
    "finding_description": "LiquidityBuffer.getControlledBalance() sums balances of managers with isActive == true only. If an admin deactivates a manager via updatePositionManager()/togglePositionManagerStatus() before evacuating funds, any residual underlying on that manager is excluded from the total, causing under-reporting. Moreover, withdrawals from inactive managers are blocked (_withdrawETHFromManager and onlyPositionManagerContract both require the manager to be active), so the funds remain inaccessible until the manager is reactivated.",
    "attack_scenario": "1. Position manager 0 has 1000 ETH allocated to it in Aave\n2. Admin calls togglePositionManagerStatus(0) to deactivate manager 0 without first withdrawing funds\n3. getControlledBalance() now returns a value that is 1000 ETH less than the actual protocol holdings\n4. _withdrawETHFromManager(0, amount) reverts with LiquidityBuffer__ManagerInactive()\n5. The 1000 ETH is effectively locked and invisible to the protocol accounting until admin reactivates the manager",
    "fix_description": "Check underlying balance before deactivation and use a dedicated forceDeactivate() if it's not zero. This was fixed in commit 93280383c0858c559270ceaec6f5d04f9be0a8e7.",
    "primary_file": {
      "path": "src/liquidityBuffer/LiquidityBuffer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed managerId, uint256 amount);\n    event ETHReturnedToStaking(uint256 amount);\n    event ETHAllocatedToManager(uint256 indexed managerId, uint256 amount);\n    event ETHReceivedFromStaking(uint256 amount);\n    event FeesCollected(uint256 amount);\n    event InterestClaimed(\n        uint256 indexed managerId,\n        uint256 interestAmount\n    );\n    event InterestToppedUp(\n        uint256 amount\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = keccak256(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = keccak256(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = keccak256(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public stakingContract;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public pauser;\n\n    /// @notice Total number of position managers\n    uint256 public positionManagerCount;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public positionManagerConfigs;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public positionAccountants;\n\n    /// @notice Total funds received from staking contract\n    uint256 public totalFundsReceived;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public totalFundsReturned;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public totalAllocatedBalance;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public totalInterestClaimed;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public totalInterestToppedUp;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public totalAllocationCapacity;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public cumulativeDrawdown;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public defaultManagerId;\n\n    /// @notice The address receiving protocol fees.\n    address payable public feesReceiver;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public feesBasisPoints;\n\n    uint256 public totalFeesCollected;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public pendingInterest;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public pendingPrincipal;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public shouldExecuteAllocation;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public isRegisteredManager;\n\n    struct Init {\n        address admin;\n        address liquidityManager;\n        address positionManager;\n        address interestTopUp;\n        address drawdownManager;\n        address payable feesReceiver;\n        IStakingReturnsWrite staking;\n        IPauserRead pauser;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n        _grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n        _grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n        _grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\n        \n        stakingContract = init.staking;\n        pauser = init.pauser;\n        feesReceiver = init.feesReceiver;\n        shouldExecuteAllocation = true;\n        \n        _grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function getInterestAmount(uint256 managerId) public view returns (uint256) {        \n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        // Get current underlying balance from position manager\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        uint256 currentBalance = manager.getUnderlyingBalance();\n        \n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory accounting = positionAccountants[managerId];\n        \n        if (currentBalance > accounting.allocatedBalance) {\n            return currentBalance - accounting.allocatedBalance;\n        }\n        \n        return 0;\n    }\n\n    function getAvailableCapacity() public view returns (uint256) {\n        return totalAllocationCapacity - totalAllocatedBalance;\n    }\n\n    function getAvailableBalance() public view returns (uint256) {\n        return totalFundsReceived - totalFundsReturned;\n    }\n\n    function getControlledBalance() public view returns (uint256) {\n        uint256 totalBalance = address(this).balance;\n        \n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig storage config = positionManagerConfigs[i];\n            if (config.isActive) {\n                IPositionManager manager = IPositionManager(config.managerAddress);\n                uint256 managerBalance = manager.getUnderlyingBalance();\n                totalBalance += managerBalance;\n            }\n        }\n        \n        return totalBalance;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function addPositionManager(\n        address managerAddress,\n        uint256 allocationCap\n    ) external onlyRole(POSITION_MANAGER_ROLE) returns (uint256 managerId) {\n        if (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        managerId = positionManagerCount;\n        positionManagerCount++;\n\n        positionManagerConfigs[managerId] = PositionManagerConfig({\n            managerAddress: managerAddress,\n            allocationCap: allocationCap,\n            isActive: true\n        });\n        positionAccountants[managerId] = PositionAccountant({\n            allocatedBalance: 0,\n            interestClaimedFromManager: 0\n        });\n        isRegisteredManager[managerAddress] = true;\n\n        totalAllocationCapacity += allocationCap;\n        emit ProtocolConfigChanged(\n            this.addPositionManager.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.encode(managerAddress, allocationCap)\n        );\n    }\n\n    function updatePositionManager(\n        uint256 managerId,\n        uint256 newAllocationCap,\n        bool isActive\n    ) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n\n        if (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n        \n        // Update total allocation capacity\n        totalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\n        \n        config.allocationCap = newAllocationCap;\n        config.isActive = isActive;\n\n        emit ProtocolConfigChanged(\n            this.updatePositionManager.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.encode(managerId, newAllocationCap, isActive)\n        );\n    }\n\n    function togglePositionManagerStatus(uint256 managerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n        config.isActive = !config.isActive;\n\n        emit ProtocolConfigChanged(\n            this.togglePositionManagerStatus.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.encode(managerId)\n        );\n    }\n\n    function setCumulativeDrawdown(uint256 drawdownAmount) external onlyRole(DRAWDOWN_MANAGER_ROLE) {        \n        cumulativeDrawdown = drawdownAmount;\n        \n        emit ProtocolConfigChanged(\n            this.setCumulativeDrawdown.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.encode(drawdownAmount)\n        );\n    }\n\n    function setDefaultManagerId(uint256 newDefaultManagerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newDefaultManagerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n        \n        if (!positionManagerConfigs[newDefaultManagerId].isActive) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n        \n        defaultManagerId = newDefaultManagerId;\n        \n        emit ProtocolConfigChanged(\n            this.setDefaultManagerId.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.encode(newDefaultManagerId)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function setFeeBasisPoints(uint16 newBasisPoints) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newBasisPoints > _BASIS_POINTS_DENOMINATOR) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        feesBasisPoints = newBasisPoints;\n        emit ProtocolConfigChanged(\n            this.setFeeBasisPoints.selector, \"setFeeBasisPoints(uint16)\", abi.encode(newBasisPoints)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function setFeesReceiver(address payable newReceiver)\n        external\n        onlyRole(POSITION_MANAGER_ROLE)\n        notZeroAddress(newReceiver)\n    {\n        feesReceiver = newReceiver;\n        emit ProtocolConfigChanged(this.setFeesReceiver.selector, \"setFeesReceiver(address)\", abi.encode(newReceiver));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function setShouldExecuteAllocation(bool executeAllocation) external onlyRole(POSITION_MANAGER_ROLE) {\n        shouldExecuteAllocation = executeAllocation;\n        emit ProtocolConfigChanged(this.setShouldExecuteAllocation.selector, \"setShouldExecuteAllocation(bool)\", abi.encode(executeAllocation));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function depositETH() external payable onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        if (pauser.isLiquidityBufferPaused()) revert LiquidityBuffer__Paused();\n        _receiveETHFromStaking(msg.value);\n        if (shouldExecuteAllocation) {\n            _allocateETHToManager(defaultManagerId, msg.value);\n        }\n    }\n\n    function withdrawAndReturn(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n        _returnETHToStaking(amount);\n    }\n\n    function allocateETHToManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _allocateETHToManager(managerId, amount);\n    }\n\n    function withdrawETHFromManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n    }\n\n    function returnETHToStaking(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _returnETHToStaking(amount);\n    }\n\n    function receiveETHFromPositionManager() external payable onlyPositionManagerContract {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function claimInterestFromManager(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return amount;\n    }\n\n    function topUpInterestToStaking(uint256 amount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < amount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n        return amount;\n    }\n\n    function claimInterestAndTopUp(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n\n        return amount;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _topUpInterestToStakingAndCollectFees(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingInterest) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        pendingInterest -= amount;\n        uint256 fees = Math.mulDiv(feesBasisPoints, amount, _BASIS_POINTS_DENOMINATOR);\n        uint256 topUpAmount = amount - fees;\n        stakingContract.topUp{value: topUpAmount}();\n        totalInterestToppedUp += topUpAmount;\n        emit InterestToppedUp(topUpAmount);\n\n        if (fees > 0) {\n            Address.sendValue(feesReceiver, fees);\n            totalFeesCollected += fees;\n            emit FeesCollected(fees);\n        }\n    }\n    \n    function _claimInterestFromManager(uint256 managerId) internal returns (uint256) {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 interestAmount = getInterestAmount(managerId);\n        \n        if (interestAmount > 0) {\n            PositionManagerConfig memory config = positionManagerConfigs[managerId];\n            \n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            positionAccountants[managerId].interestClaimedFromManager += interestAmount;\n            totalInterestClaimed += interestAmount;\n            pendingInterest += interestAmount;\n            emit InterestClaimed(managerId, interestAmount);\n            \n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager manager = IPositionManager(config.managerAddress);\n            manager.withdraw(interestAmount);\n        } else {\n            emit InterestClaimed(managerId, interestAmount);\n        }\n        \n        return interestAmount;\n    }\n\n    function _withdrawETHFromManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage accounting = positionAccountants[managerId];\n\n        // Check sufficient allocation\n        if (amount > accounting.allocatedBalance) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        accounting.allocatedBalance -= amount;\n        totalAllocatedBalance -= amount;\n        pendingPrincipal += amount;\n        emit ETHWithdrawnFromManager(managerId, amount);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.withdraw(amount);\n    }\n\n    function _returnETHToStaking(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        \n        // Validate staking contract is set and not zero address\n        if (address(stakingContract) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n        \n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        totalFundsReturned += amount;\n        pendingPrincipal -= amount;\n        emit ETHReturnedToStaking(amount);\n        \n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        stakingContract.receiveReturnsFromLiquidityBuffer{value: amount}();\n    }\n\n    function _allocateETHToManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n        \n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < amount) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage accounting = positionAccountants[managerId];\n        if (accounting.allocatedBalance + amount > config.allocationCap) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        accounting.allocatedBalance += amount;\n        totalAllocatedBalance += amount;\n        pendingPrincipal -= amount;\n        emit ETHAllocatedToManager(managerId, amount);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.deposit{value: amount}(0);\n    }\n\n    function _receiveETHFromStaking(uint256 amount) internal {\n        totalFundsReceived += amount;\n        pendingPrincipal += amount;\n        emit ETHReceivedFromStaking(amount);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier onlyStakingContract() {\n        if (msg.sender != address(stakingContract)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier onlyPositionManagerContract() {\n        bool isValidManager = false;\n        \n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig memory config = positionManagerConfigs[i];\n            \n            if (msg.sender == config.managerAddress && config.isActive) {\n                isValidManager = true;\n                break;\n            }\n        }\n        \n        if (!isValidManager) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "vulnerable_lines": [183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 441, 442, 443, 444, 445, 446, 447, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562],
      "vulnerable_functions": ["getControlledBalance", "_withdrawETHFromManager", "onlyPositionManagerContract"]
    },
    "context_files": [],
    "call_flow": "getControlledBalance() loops through managers but skips inactive ones -> _withdrawETHFromManager() reverts for inactive managers -> funds locked until reactivation",
    "context_hint": "The getControlledBalance function only sums balances from active managers, but deactivation doesn't force fund evacuation first. This causes under-reporting of controlled funds and locks the funds since _withdrawETHFromManager requires the manager to be active.",
    "is_vulnerable": true
  },
  {
    "id": "gs_mixbytes_mantle-meth-aave_M03",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Mantle mETH x Aave Integration Security Audit",
    "source_finding_id": "M-3",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
    "github_repo_url": "https://github.com/mantle-lsp/contracts",
    "contest_date": "2025-10-22",
    "severity": "medium",
    "vulnerability_type": "front_running",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Front-running unstakeRequestWithPermit() can invalidate user transaction",
    "finding_description": "An attacker can read the v, r, s from the mempool and call mETH.permit() first, consuming the user's signature and updating the nonce. The subsequent user transaction Staking.unstakeRequestWithPermit() then reverts on the permit() call due to an invalidated signature/nonce, preventing the unstake flow from executing, even though allowance is already set.",
    "attack_scenario": "1. User submits unstakeRequestWithPermit() transaction with signature (v, r, s) to the mempool\n2. Attacker monitors mempool and extracts the permit signature parameters\n3. Attacker front-runs with a direct call to mETH.permit() using the extracted (v, r, s)\n4. The permit succeeds, consuming the user's nonce and setting the allowance\n5. User's original unstakeRequestWithPermit() transaction is mined\n6. The SafeERC20Upgradeable.safePermit() call inside unstakeRequestWithPermit() reverts because the nonce is already used\n7. User's unstake request fails even though the allowance was set",
    "fix_description": "Wrap the permit() invocation in a try-catch clause and proceed with the unstake if allowance is already sufficient, avoiding a hard revert when signatures are pre-consumed.",
    "primary_file": {
      "path": "src/Staking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 amount);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 amount);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 amount);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 amount);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 amount);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\n    error UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 operatorID;\n        uint256 depositAmount;\n        bytes pubkey;\n        bytes withdrawalCredentials;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    mapping(bytes pubkey => bool exists) public usedValidators;\n    uint256 public totalDepositedInValidators;\n    uint256 public numInitiatedValidators;\n    uint256 public unallocatedETH;\n    uint256 public allocatedETHForDeposits;\n    uint256 public minimumStakeBound;\n    uint256 public minimumUnstakeBound;\n    uint16 public exchangeAdjustmentRate;\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n    uint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\n    uint256 public minimumDepositAmount;\n    uint256 public maximumDepositAmount;\n    IDepositContract public depositContract;\n    IMETH public mETH;\n    IOracleReadRecord public oracle;\n    IPauserRead public pauser;\n    IUnstakeRequestsManager public unstakeRequestsManager;\n    address public withdrawalWallet;\n    address public returnsAggregator;\n    bool public isStakingAllowlist;\n    uint256 public initializationBlockNumber;\n    uint256 public maximumMETHSupply;\n    ILiquidityBuffer public liquidityBuffer;\n\n    struct Init {\n        address admin;\n        address manager;\n        address allocatorService;\n        address initiatorService;\n        address returnsAggregator;\n        address withdrawalWallet;\n        IMETH mETH;\n        IDepositContract depositContract;\n        IOracleReadRecord oracle;\n        IPauserRead pauser;\n        IUnstakeRequestsManager unstakeRequestsManager;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(STAKING_MANAGER_ROLE, init.manager);\n        _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n        _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n\n        _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        mETH = init.mETH;\n        depositContract = init.depositContract;\n        oracle = init.oracle;\n        pauser = init.pauser;\n        returnsAggregator = init.returnsAggregator;\n        unstakeRequestsManager = init.unstakeRequestsManager;\n        withdrawalWallet = init.withdrawalWallet;\n\n        minimumStakeBound = 0.1 ether;\n        minimumUnstakeBound = 0.01 ether;\n        minimumDepositAmount = 32 ether;\n        maximumDepositAmount = 32 ether;\n        isStakingAllowlist = true;\n        initializationBlockNumber = block.number;\n        maximumMETHSupply = 1024 ether;\n    }\n        \n    function initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\n        liquidityBuffer = lb;\n    }\n\n    function stake(uint256 minMETHAmount) external payable {\n        if (pauser.isStakingPaused()) {\n            revert Paused();\n        }\n\n        if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 mETHMintAmount = ethToMETH(msg.value);\n        if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n        }\n\n        unallocatedETH += msg.value;\n\n        emit Staked(msg.sender, msg.value, mETHMintAmount);\n        mETH.mint(msg.sender, mETHMintAmount);\n    }\n\n    function unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function unstakeRequestWithPermit(\n        uint128 methAmount,\n        uint128 minETHAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\n        if (pauser.isUnstakeRequestsAndClaimsPaused()) {\n            revert Paused();\n        }\n\n        if (methAmount < minimumUnstakeBound) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 ethAmount = uint128(mETHToETH(methAmount));\n        if (ethAmount < minETHAmount) {\n            revert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n        }\n\n        uint256 requestID =\n            unstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\n        emit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\n\n        SafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\n\n        return requestID;\n    }\n\n    function ethToMETH(uint256 ethAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return ethAmount;\n        }\n        uint256 adjustedTotalControlled = Math.mulDiv(\n            totalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n        );\n        return Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n    }\n\n    function mETHToETH(uint256 mETHAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return mETHAmount;\n        }\n        return Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n    }\n\n    function totalControlled() public view returns (uint256) {\n        OracleRecord memory record = oracle.latestRecord();\n        uint256 total = 0;\n        total += unallocatedETH;\n        total += allocatedETHForDeposits;\n        total += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\n        total += record.currentTotalValidatorBalance;\n        total += liquidityBuffer.getAvailableBalance();\n        total -= liquidityBuffer.cumulativeDrawdown();\n        total += unstakeRequestsManager.balance();\n        return total;\n    }\n\n    function receiveReturns() external payable onlyReturnsAggregator {\n        emit ReturnsReceived(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    function receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    modifier onlyReturnsAggregator() {\n        if (msg.sender != returnsAggregator) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier onlyLiquidityBuffer() {\n        if (msg.sender != address(liquidityBuffer)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier onlyUnstakeRequestsManager() {\n        if (msg.sender != address(unstakeRequestsManager)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "vulnerable_lines": [194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
      "vulnerable_functions": ["unstakeRequestWithPermit"]
    },
    "context_files": [],
    "call_flow": "User submits unstakeRequestWithPermit(methAmount, minETHAmount, deadline, v, r, s) -> Attacker front-runs with mETH.permit(user, staking, methAmount, deadline, v, r, s) -> User's safePermit() reverts due to invalid nonce",
    "context_hint": "The unstakeRequestWithPermit function uses safePermit which will revert if the permit has already been used. An attacker can extract the signature from the mempool and front-run by calling permit directly, causing the user's transaction to fail even though the approval was set.",
    "is_vulnerable": true
  },
  {
    "id": "gs_mixbytes_mantle-meth-aave_M04",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Mantle mETH x Aave Integration Security Audit",
    "source_finding_id": "M-4",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
    "github_repo_url": "https://github.com/mantle-lsp/contracts",
    "contest_date": "2025-10-22",
    "severity": "medium",
    "vulnerability_type": "access_control",
    "difficulty_tier": 1,
    "context_level": "single_file",
    "finding_title": "Emergency admin can transfer aWETH from the PositionManager",
    "finding_description": "EMERGENCY_ROLE in PositionManager can transfer aWETH from the contract to any address without restrictions, which may be unintended and creates additional risks in case this role is compromised. The emergencyTokenTransfer function allows unrestricted transfer of any ERC20 token, including aWETH which represents the protocol's position in Aave.",
    "attack_scenario": "1. Attacker compromises the account holding EMERGENCY_ROLE\n2. Attacker calls emergencyTokenTransfer(aWETH, attackerAddress, aWETH.balanceOf(positionManager))\n3. All aWETH tokens (representing ETH deposited in Aave) are transferred to the attacker\n4. Protocol loses all funds deposited through this position manager\n5. The attack bypasses the normal withdraw() flow which goes through LiquidityBuffer",
    "fix_description": "Disallow aWETH emergency transfers or approvals from the PositionManager contract, since withdrawals are already handled via the more transparent withdraw() flow. The team acknowledged this is intentional for rapid fund withdrawal in critical situations and noted EMERGENCY_ROLE will not be configured at launch.",
    "primary_file": {
      "path": "src/liquidityBuffer/PositionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\n/**\n * @title PositionManager\n * @dev Position manager with role-based access control\n * inspired by WrappedTokenGatewayV3 0xd01607c3c5ecaba394d8be377a08590149325722\n */\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\n    using SafeERC20 for IERC20;\n    \n    // Role definitions\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n    \n    // State variables\n    IPool public pool;\n    IWETH public weth;\n    ILiquidityBuffer public liquidityBuffer;\n\n    /// @notice Configuration for contract initialization.\n    struct Init {\n        address admin;\n        address manager;\n        ILiquidityBuffer liquidityBuffer;\n        IWETH weth;\n        IPool pool;\n    }\n\n    // Events\n    event Deposit(address indexed caller, uint amount, uint aTokenAmount);\n    event Withdraw(address indexed caller, uint amount);\n    event Borrow(address indexed caller, uint amount, uint rateMode);\n    event Repay(address indexed caller, uint amount, uint rateMode);\n    event SetUserEMode(address indexed caller, uint8 categoryId);\n\n    constructor() {\n        _disableInitializers();\n    }\n    \n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n        \n        weth = init.weth;\n        pool = init.pool;\n        liquidityBuffer = init.liquidityBuffer;\n        \n        // Set up roles\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(MANAGER_ROLE, init.manager);\n        _grantRole(EXECUTOR_ROLE, address(init.liquidityBuffer));\n        \n        // Approve pool to spend WETH\n        weth.approve(address(pool), type(uint256).max);\n    }\n\n    // IPositionManager Implementation\n\n    function deposit(uint16 referralCode) external payable override onlyRole(EXECUTOR_ROLE) {\n        if (msg.value > 0) {\n            // Wrap ETH to WETH\n            weth.deposit{value: msg.value}();\n            \n            // Deposit WETH into pool\n            pool.deposit(address(weth), msg.value, address(this), referralCode);\n            \n            emit Deposit(msg.sender, msg.value, msg.value);\n        }\n    }\n\n    function withdraw(uint256 amount) external override onlyRole(EXECUTOR_ROLE) {\n        require(amount > 0, 'Invalid amount');\n        \n        // Get aWETH token\n        IERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\n        uint256 userBalance = aWETH.balanceOf(address(this));\n        \n        uint256 amountToWithdraw = amount;\n        if (amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n        \n        require(amountToWithdraw <= userBalance, 'Insufficient balance');\n        \n        // Withdraw from pool\n        pool.withdraw(address(weth), amountToWithdraw, address(this));\n        \n        // Unwrap WETH to ETH\n        weth.withdraw(amountToWithdraw);\n        \n        // Transfer ETH to LiquidityBuffer via receiveETHFromPositionManager\n        liquidityBuffer.receiveETHFromPositionManager{value: amountToWithdraw}();\n        \n        emit Withdraw(msg.sender, amountToWithdraw);\n    }\n\n    function getUnderlyingBalance() external view returns (uint256) {\n        IERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\n        return aWETH.balanceOf(address(this));\n    }\n\n    function setUserEMode(uint8 categoryId) external override onlyRole(MANAGER_ROLE) {\n        // Set user E-mode category\n        pool.setUserEMode(categoryId);\n        \n        emit SetUserEMode(msg.sender, categoryId);\n    }\n    function approveToken(address token, address addr, uint256 wad) external override onlyRole(MANAGER_ROLE) {\n        IERC20(token).safeApprove(addr, wad);\n    }\n\n    function revokeToken(address token, address addr) external override onlyRole(MANAGER_ROLE) {\n        IERC20(token).safeApprove(addr, 0);\n    }\n\n    // Additional helper functions\n\n    function getBorrowBalance() external view returns (uint256) {\n        address debtToken = pool.getReserveVariableDebtToken(address(weth));\n        return IERC20(debtToken).balanceOf(address(this));\n    }\n\n    function getCollateralBalance() external view returns (uint256) {\n        IERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\n        return aWETH.balanceOf(address(this));\n    }\n\n    function getUserEMode() external view returns (uint256) {\n        return pool.getUserEMode(address(this));\n    }\n\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external onlyRole(MANAGER_ROLE) {\n        pool.setUserUseReserveAsCollateral(asset, useAsCollateral);\n    }\n\n    function setLiquidityBuffer(address _liquidityBuffer) external onlyRole(MANAGER_ROLE) {\n        _revokeRole(EXECUTOR_ROLE, address(liquidityBuffer));\n        _grantRole(EXECUTOR_ROLE, _liquidityBuffer);\n        liquidityBuffer = ILiquidityBuffer(_liquidityBuffer);\n    }\n\n    /**\n    * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n    * direct transfers to the contract address.\n    * @param token token to transfer\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function emergencyTokenTransfer(address token, address to, uint256 amount) external onlyRole(EMERGENCY_ROLE) {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n    * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n    * due to selfdestructs or ether transfers to the pre-computed contract address before deployment.\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function emergencyEtherTransfer(address to, uint256 amount) external onlyRole(EMERGENCY_ROLE) {\n        _safeTransferETH(to, amount);\n    }\n\n    /**\n     * @dev transfer ETH to an address, revert if it fails.\n     * @param to recipient of the transfer\n     * @param value the amount to send\n     */\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n    \n    /**\n    * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n    */\n    receive() external payable {\n        require(msg.sender == address(weth), 'Receive not allowed');\n    }\n\n    /**\n    * @dev Revert fallback calls\n    */\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n}",
      "vulnerable_lines": [155, 156, 157, 158, 159, 160, 161, 162, 163, 164],
      "vulnerable_functions": ["emergencyTokenTransfer"]
    },
    "context_files": [],
    "call_flow": "Compromised EMERGENCY_ROLE holder -> emergencyTokenTransfer(aWETH, attacker, balance) -> All protocol funds in Aave transferred to attacker",
    "context_hint": "The emergencyTokenTransfer function allows the EMERGENCY_ROLE to transfer any ERC20 token including aWETH. This bypasses the normal withdraw flow and could be exploited if the emergency role is compromised.",
    "is_vulnerable": true
  },
  {
    "id": "gs_mixbytes_mantle-meth-aave_M05",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Mantle mETH x Aave Integration Security Audit",
    "source_finding_id": "M-5",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
    "github_repo_url": "https://github.com/mantle-lsp/contracts",
    "contest_date": "2025-10-22",
    "severity": "medium",
    "vulnerability_type": "oracle_manipulation",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "Missing freshness check on oracle data in Staking.totalControlled() enables stale-rate arbitrage",
    "finding_description": "Staking.totalControlled() derives the mETH/ETH exchange rate inputs from oracle.latestRecord() without validating the record timestamp. If the oracle lags significant state changes (e.g., validator rewards or slashing), the resulting rate becomes stale. An attacker can exploit this by timing mint/burn operations against outdated totals: redeeming mETH for excess ETH when a slashing is not yet reflected (overstated totalControlled()), or depositing ETH to mint excess mETH when recent rewards are not yet reflected (understated totalControlled()), extracting value from other users.",
    "attack_scenario": "Slashing scenario:\n1. Validators are slashed, reducing the actual ETH controlled by the protocol\n2. Oracle has not yet updated to reflect the slashing\n3. totalControlled() returns the old (higher) value\n4. Attacker calls unstakeRequest() and receives more ETH per mETH than they should\n5. Other users bear the loss when the oracle updates\n\nReward scenario:\n1. Validators earn significant rewards\n2. Oracle has not yet updated to reflect the new rewards\n3. totalControlled() returns the old (lower) value\n4. Attacker calls stake() and receives more mETH per ETH than they should\n5. The mETH is worth more once the oracle updates",
    "fix_description": "Enforce freshness validation for oracle records when minting or burning mETH. The Oracle.latestRecord() function has no sanity checks - it simply returns _records[_records.length - 1]. The validations should be implemented on the caller side, specifically in the Staking.totalControlled() function.",
    "primary_file": {
      "path": "src/Staking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 amount);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 amount);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 amount);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 amount);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 amount);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\n    error UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 operatorID;\n        uint256 depositAmount;\n        bytes pubkey;\n        bytes withdrawalCredentials;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    mapping(bytes pubkey => bool exists) public usedValidators;\n    uint256 public totalDepositedInValidators;\n    uint256 public numInitiatedValidators;\n    uint256 public unallocatedETH;\n    uint256 public allocatedETHForDeposits;\n    uint256 public minimumStakeBound;\n    uint256 public minimumUnstakeBound;\n    uint16 public exchangeAdjustmentRate;\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n    uint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\n    uint256 public minimumDepositAmount;\n    uint256 public maximumDepositAmount;\n    IDepositContract public depositContract;\n    IMETH public mETH;\n    IOracleReadRecord public oracle;\n    IPauserRead public pauser;\n    IUnstakeRequestsManager public unstakeRequestsManager;\n    address public withdrawalWallet;\n    address public returnsAggregator;\n    bool public isStakingAllowlist;\n    uint256 public initializationBlockNumber;\n    uint256 public maximumMETHSupply;\n    ILiquidityBuffer public liquidityBuffer;\n\n    struct Init {\n        address admin;\n        address manager;\n        address allocatorService;\n        address initiatorService;\n        address returnsAggregator;\n        address withdrawalWallet;\n        IMETH mETH;\n        IDepositContract depositContract;\n        IOracleReadRecord oracle;\n        IPauserRead pauser;\n        IUnstakeRequestsManager unstakeRequestsManager;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(STAKING_MANAGER_ROLE, init.manager);\n        _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n        _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n\n        _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        mETH = init.mETH;\n        depositContract = init.depositContract;\n        oracle = init.oracle;\n        pauser = init.pauser;\n        returnsAggregator = init.returnsAggregator;\n        unstakeRequestsManager = init.unstakeRequestsManager;\n        withdrawalWallet = init.withdrawalWallet;\n\n        minimumStakeBound = 0.1 ether;\n        minimumUnstakeBound = 0.01 ether;\n        minimumDepositAmount = 32 ether;\n        maximumDepositAmount = 32 ether;\n        isStakingAllowlist = true;\n        initializationBlockNumber = block.number;\n        maximumMETHSupply = 1024 ether;\n    }\n        \n    function initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\n        liquidityBuffer = lb;\n    }\n\n    function stake(uint256 minMETHAmount) external payable {\n        if (pauser.isStakingPaused()) {\n            revert Paused();\n        }\n\n        if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 mETHMintAmount = ethToMETH(msg.value);\n        if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n        }\n\n        unallocatedETH += msg.value;\n\n        emit Staked(msg.sender, msg.value, mETHMintAmount);\n        mETH.mint(msg.sender, mETHMintAmount);\n    }\n\n    function unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function unstakeRequestWithPermit(\n        uint128 methAmount,\n        uint128 minETHAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\n        if (pauser.isUnstakeRequestsAndClaimsPaused()) {\n            revert Paused();\n        }\n\n        if (methAmount < minimumUnstakeBound) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 ethAmount = uint128(mETHToETH(methAmount));\n        if (ethAmount < minETHAmount) {\n            revert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n        }\n\n        uint256 requestID =\n            unstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\n        emit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\n\n        SafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\n\n        return requestID;\n    }\n\n    function ethToMETH(uint256 ethAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return ethAmount;\n        }\n        uint256 adjustedTotalControlled = Math.mulDiv(\n            totalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n        );\n        return Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n    }\n\n    function mETHToETH(uint256 mETHAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return mETHAmount;\n        }\n        return Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n    }\n\n    function totalControlled() public view returns (uint256) {\n        OracleRecord memory record = oracle.latestRecord();\n        uint256 total = 0;\n        total += unallocatedETH;\n        total += allocatedETHForDeposits;\n        total += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\n        total += record.currentTotalValidatorBalance;\n        total += liquidityBuffer.getAvailableBalance();\n        total -= liquidityBuffer.cumulativeDrawdown();\n        total += unstakeRequestsManager.balance();\n        return total;\n    }\n\n    function receiveReturns() external payable onlyReturnsAggregator {\n        emit ReturnsReceived(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    function receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    modifier onlyReturnsAggregator() {\n        if (msg.sender != returnsAggregator) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier onlyLiquidityBuffer() {\n        if (msg.sender != address(liquidityBuffer)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier onlyUnstakeRequestsManager() {\n        if (msg.sender != address(unstakeRequestsManager)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "vulnerable_lines": [230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241],
      "vulnerable_functions": ["totalControlled"]
    },
    "context_files": [
      {
        "path": "src/Oracle.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {\n    IOracle,\n    IOracleReadRecord,\n    IOracleReadPending,\n    IOracleWrite,\n    IOracleManager,\n    OracleRecord\n} from \"./interfaces/IOracle.sol\";\nimport {IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {IReturnsAggregatorWrite} from \"./interfaces/IReturnsAggregator.sol\";\nimport {IPauser} from \"./interfaces/IPauser.sol\";\n\n/// @notice Events emitted by the oracle contract.\ninterface OracleEvents {\n    event OracleRecordAdded(uint256 indexed index, OracleRecord record);\n    event OracleRecordModified(uint256 indexed index, OracleRecord record);\n    event OraclePendingUpdateRejected(OracleRecord pendingUpdate);\n    event OracleRecordFailedSanityCheck(\n        bytes32 indexed reasonHash, string reason, OracleRecord record, uint256 value, uint256 bound\n    );\n}\n\n/// @title Oracle\n/// @notice The oracle contract stores records which are snapshots of consensus layer state.\ncontract Oracle is Initializable, AccessControlEnumerableUpgradeable, IOracle, OracleEvents, ProtocolEvents {\n    error CannotUpdateWhileUpdatePending();\n    error CannotModifyInitialRecord();\n    error InvalidConfiguration();\n    error InvalidRecordModification();\n    error InvalidUpdateStartBlock(uint256 wantUpdateStartBlock, uint256 gotUpdateStartBlock);\n    error InvalidUpdateEndBeforeStartBlock(uint256 end, uint256 start);\n    error InvalidUpdateMoreDepositsProcessedThanSent(uint256 processed, uint256 sent);\n    error InvalidUpdateMoreValidatorsThanInitiated(uint256 numValidatorsOnRecord, uint256 numInitiatedValidators);\n    error NoUpdatePending();\n    error Paused();\n    error RecordDoesNotExist(uint256 idx);\n    error UnauthorizedOracleUpdater(address sender, address oracleUpdater);\n    error UpdateEndBlockNumberNotFinal(uint256 updateFinalizingBlock);\n    error ZeroAddress();\n\n    bytes32 public constant ORACLE_MANAGER_ROLE = keccak256(\"ORACLE_MANAGER_ROLE\");\n    bytes32 public constant ORACLE_MODIFIER_ROLE = keccak256(\"ORACLE_MODIFIER_ROLE\");\n    bytes32 public constant ORACLE_PENDING_UPDATE_RESOLVER_ROLE = keccak256(\"ORACLE_PENDING_UPDATE_RESOLVER_ROLE\");\n\n    uint256 internal constant _FINALIZATION_BLOCK_NUMBER_DELTA_UPPER_BOUND = 2048;\n\n    OracleRecord[] internal _records;\n    bool public hasPendingUpdate;\n    OracleRecord internal _pendingUpdate;\n    uint256 public finalizationBlockNumberDelta;\n    address public oracleUpdater;\n    IPauser public pauser;\n    IStakingInitiationRead public staking;\n    IReturnsAggregatorWrite public aggregator;\n\n    uint256 public minDepositPerValidator;\n    uint256 public maxDepositPerValidator;\n    uint40 public minConsensusLayerGainPerBlockPPT;\n    uint40 public maxConsensusLayerGainPerBlockPPT;\n    uint24 public maxConsensusLayerLossPPM;\n    uint16 public minReportSizeBlocks;\n\n    uint24 internal constant _PPM_DENOMINATOR = 1e6;\n    uint40 internal constant _PPT_DENOMINATOR = 1e12;\n\n    struct Init {\n        address admin;\n        address manager;\n        address oracleUpdater;\n        address pendingResolver;\n        IReturnsAggregatorWrite aggregator;\n        IPauser pauser;\n        IStakingInitiationRead staking;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(ORACLE_MANAGER_ROLE, init.manager);\n        _grantRole(ORACLE_PENDING_UPDATE_RESOLVER_ROLE, init.pendingResolver);\n\n        aggregator = init.aggregator;\n        oracleUpdater = init.oracleUpdater;\n        pauser = init.pauser;\n        staking = init.staking;\n    }\n\n    /// @inheritdoc IOracleReadRecord\n    function latestRecord() public view returns (OracleRecord memory) {\n        return _records[_records.length - 1];\n    }\n\n    /// @inheritdoc IOracleReadPending\n    function pendingUpdate() external view returns (OracleRecord memory) {\n        if (!hasPendingUpdate) {\n            revert NoUpdatePending();\n        }\n        return _pendingUpdate;\n    }\n\n    /// @inheritdoc IOracleReadRecord\n    function recordAt(uint256 idx) external view returns (OracleRecord memory) {\n        return _records[idx];\n    }\n\n    /// @inheritdoc IOracleReadRecord\n    function numRecords() external view returns (uint256) {\n        return _records.length;\n    }\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n}",
        "relevance": "The Oracle.latestRecord() function returns the latest record without any freshness validation. The vulnerability exists because Staking.totalControlled() uses this record without checking how old it is."
      }
    ],
    "call_flow": "stake()/unstakeRequest() -> ethToMETH()/mETHToETH() -> totalControlled() -> oracle.latestRecord() -> returns potentially stale data -> incorrect exchange rate calculation",
    "context_hint": "The totalControlled() function uses oracle.latestRecord() to get validator balances without checking how recent the record is. If the oracle is stale (hasn't updated after slashing or rewards), the exchange rate will be incorrect, allowing arbitrage.",
    "is_vulnerable": true
  },
  {
    "id": "gs_mixbytes_mantle-meth-aave_M06",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Mantle mETH x Aave Integration Security Audit",
    "source_finding_id": "M-6",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
    "github_repo_url": "https://github.com/mantle-lsp/contracts",
    "contest_date": "2025-10-22",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "Fixed exchange rate at unstaking fails to socialize slashing and distorts rewards",
    "finding_description": "When Staking.unstakeRequest() is called, the mETH/ETH rate is fixed and does not reflect slashing or rewards that may occur by the time Staking.claimUnstakeRequest() is executed. If two users create requests concurrently and losses arrive afterward, those losses are not socialized across them. One request may be fully paid while the other may revert on claim due to insufficient allocated funds. This can be exacerbated by frontrunning updates to LiquidityBuffer.cumulativeDrawdown(), enabling informed actors to anticipate loss application. Rewards are also misallocated: requests lock mETH but do not burn it until UnstakeRequestsManager.claim(), so these shares continue participating in reward distribution, diluting rewards for users who have not requested to unstake.",
    "attack_scenario": "Loss scenario:\n1. Alice and Bob each hold 100 mETH, pool controls 200 ETH\n2. Alice calls unstakeRequest(100 mETH), rate fixed at 1:1, expects 100 ETH\n3. Bob calls unstakeRequest(100 mETH), rate fixed at 1:1, expects 100 ETH\n4. Slashing event occurs, pool now only has 150 ETH\n5. Protocol allocates 100 ETH to Alice's claim (succeeds)\n6. Bob's claim reverts due to insufficient funds (only 50 ETH left)\n7. The slashing loss was not socialized - Alice escaped, Bob bears full loss\n\nReward dilution scenario:\n1. Alice and Bob each hold 100 mETH, pool controls 200 ETH\n2. Alice calls unstakeRequest(100 mETH) - shares locked but not burned\n3. 100 ETH reward is distributed across 200 mETH (all shares still exist)\n4. Only ~50 ETH is attributed to Bob instead of ~100 ETH\n5. Alice's locked shares continue to earn rewards until she claims",
    "fix_description": "Align withdrawal settlement with the latest protocol state to socialize slashing and adjust reward accounting so pending unstakes do not accrue or dilute rewards. The client acknowledged this as a protocol design trade-off.",
    "primary_file": {
      "path": "src/Staking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 amount);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 amount);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 amount);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 amount);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 amount);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\n    error UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 operatorID;\n        uint256 depositAmount;\n        bytes pubkey;\n        bytes withdrawalCredentials;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    mapping(bytes pubkey => bool exists) public usedValidators;\n    uint256 public totalDepositedInValidators;\n    uint256 public numInitiatedValidators;\n    uint256 public unallocatedETH;\n    uint256 public allocatedETHForDeposits;\n    uint256 public minimumStakeBound;\n    uint256 public minimumUnstakeBound;\n    uint16 public exchangeAdjustmentRate;\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n    uint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\n    uint256 public minimumDepositAmount;\n    uint256 public maximumDepositAmount;\n    IDepositContract public depositContract;\n    IMETH public mETH;\n    IOracleReadRecord public oracle;\n    IPauserRead public pauser;\n    IUnstakeRequestsManager public unstakeRequestsManager;\n    address public withdrawalWallet;\n    address public returnsAggregator;\n    bool public isStakingAllowlist;\n    uint256 public initializationBlockNumber;\n    uint256 public maximumMETHSupply;\n    ILiquidityBuffer public liquidityBuffer;\n\n    struct Init {\n        address admin;\n        address manager;\n        address allocatorService;\n        address initiatorService;\n        address returnsAggregator;\n        address withdrawalWallet;\n        IMETH mETH;\n        IDepositContract depositContract;\n        IOracleReadRecord oracle;\n        IPauserRead pauser;\n        IUnstakeRequestsManager unstakeRequestsManager;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(STAKING_MANAGER_ROLE, init.manager);\n        _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n        _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n\n        _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        mETH = init.mETH;\n        depositContract = init.depositContract;\n        oracle = init.oracle;\n        pauser = init.pauser;\n        returnsAggregator = init.returnsAggregator;\n        unstakeRequestsManager = init.unstakeRequestsManager;\n        withdrawalWallet = init.withdrawalWallet;\n\n        minimumStakeBound = 0.1 ether;\n        minimumUnstakeBound = 0.01 ether;\n        minimumDepositAmount = 32 ether;\n        maximumDepositAmount = 32 ether;\n        isStakingAllowlist = true;\n        initializationBlockNumber = block.number;\n        maximumMETHSupply = 1024 ether;\n    }\n        \n    function initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\n        liquidityBuffer = lb;\n    }\n\n    function stake(uint256 minMETHAmount) external payable {\n        if (pauser.isStakingPaused()) {\n            revert Paused();\n        }\n\n        if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 mETHMintAmount = ethToMETH(msg.value);\n        if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n        }\n\n        unallocatedETH += msg.value;\n\n        emit Staked(msg.sender, msg.value, mETHMintAmount);\n        mETH.mint(msg.sender, mETHMintAmount);\n    }\n\n    function unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function unstakeRequestWithPermit(\n        uint128 methAmount,\n        uint128 minETHAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\n        if (pauser.isUnstakeRequestsAndClaimsPaused()) {\n            revert Paused();\n        }\n\n        if (methAmount < minimumUnstakeBound) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 ethAmount = uint128(mETHToETH(methAmount));\n        if (ethAmount < minETHAmount) {\n            revert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n        }\n\n        uint256 requestID =\n            unstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\n        emit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\n\n        SafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\n\n        return requestID;\n    }\n\n    function ethToMETH(uint256 ethAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return ethAmount;\n        }\n        uint256 adjustedTotalControlled = Math.mulDiv(\n            totalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n        );\n        return Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n    }\n\n    function mETHToETH(uint256 mETHAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return mETHAmount;\n        }\n        return Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n    }\n\n    function totalControlled() public view returns (uint256) {\n        OracleRecord memory record = oracle.latestRecord();\n        uint256 total = 0;\n        total += unallocatedETH;\n        total += allocatedETHForDeposits;\n        total += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\n        total += record.currentTotalValidatorBalance;\n        total += liquidityBuffer.getAvailableBalance();\n        total -= liquidityBuffer.cumulativeDrawdown();\n        total += unstakeRequestsManager.balance();\n        return total;\n    }\n\n    function receiveReturns() external payable onlyReturnsAggregator {\n        emit ReturnsReceived(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    function receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    modifier onlyReturnsAggregator() {\n        if (msg.sender != returnsAggregator) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier onlyLiquidityBuffer() {\n        if (msg.sender != address(liquidityBuffer)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier onlyUnstakeRequestsManager() {\n        if (msg.sender != address(unstakeRequestsManager)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "vulnerable_lines": [207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228],
      "vulnerable_functions": ["_unstakeRequest", "mETHToETH"]
    },
    "context_files": [
      {
        "path": "src/UnstakeRequestsManager.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord} from \"./interfaces/IOracle.sol\";\nimport {\n    IUnstakeRequestsManager,\n    IUnstakeRequestsManagerWrite,\n    IUnstakeRequestsManagerRead,\n    UnstakeRequest\n} from \"./interfaces/IUnstakeRequestsManager.sol\";\nimport {IStakingReturnsWrite} from \"./interfaces/IStaking.sol\";\n\n/// @notice Events emitted by the unstake requests manager.\ninterface UnstakeRequestsManagerEvents {\n    event UnstakeRequestCreated(\n        uint256 indexed id,\n        address indexed requester,\n        uint256 mETHLocked,\n        uint256 ethRequested,\n        uint256 cumulativeETHRequested,\n        uint256 blockNumber\n    );\n\n    event UnstakeRequestClaimed(\n        uint256 indexed id,\n        address indexed requester,\n        uint256 mETHLocked,\n        uint256 ethRequested,\n        uint256 cumulativeETHRequested,\n        uint256 blockNumber\n    );\n\n    event UnstakeRequestCancelled(\n        uint256 indexed id,\n        address indexed requester,\n        uint256 mETHLocked,\n        uint256 ethRequested,\n        uint256 cumulativeETHRequested,\n        uint256 blockNumber\n    );\n}\n\n/// @title UnstakeRequestsManager\n/// @notice Manages unstake requests from the staking contract.\ncontract UnstakeRequestsManager is\n    Initializable,\n    AccessControlEnumerableUpgradeable,\n    IUnstakeRequestsManager,\n    UnstakeRequestsManagerEvents,\n    ProtocolEvents\n{\n    error AlreadyClaimed();\n    error DoesNotReceiveETH();\n    error NotEnoughFunds(uint256 cumulativeETHOnRequest, uint256 allocatedETHForClaims);\n    error NotFinalized();\n    error NotRequester();\n    error NotStakingContract();\n\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    bytes32 public constant REQUEST_CANCELLER_ROLE = keccak256(\"REQUEST_CANCELLER_ROLE\");\n\n    IStakingReturnsWrite public stakingContract;\n    IOracleReadRecord public oracle;\n    uint256 public allocatedETHForClaims;\n    uint256 public totalClaimed;\n    uint256 public numberOfBlocksToFinalize;\n    IMETH public mETH;\n    uint128 public latestCumulativeETHRequested;\n    UnstakeRequest[] internal _unstakeRequests;\n\n    struct Init {\n        address admin;\n        address manager;\n        address requestCanceller;\n        IMETH mETH;\n        IStakingReturnsWrite stakingContract;\n        IOracleReadRecord oracle;\n        uint256 numberOfBlocksToFinalize;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        numberOfBlocksToFinalize = init.numberOfBlocksToFinalize;\n        stakingContract = init.stakingContract;\n        oracle = init.oracle;\n        mETH = init.mETH;\n\n        _grantRole(MANAGER_ROLE, init.manager);\n        _grantRole(REQUEST_CANCELLER_ROLE, init.requestCanceller);\n    }\n\n    function create(address requester, uint128 mETHLocked, uint128 ethRequested)\n        external\n        onlyStakingContract\n        returns (uint256)\n    {\n        uint128 currentCumulativeETHRequested = latestCumulativeETHRequested + ethRequested;\n        uint256 requestID = _unstakeRequests.length;\n        UnstakeRequest memory unstakeRequest = UnstakeRequest({\n            id: uint128(requestID),\n            requester: requester,\n            mETHLocked: mETHLocked,\n            ethRequested: ethRequested,\n            cumulativeETHRequested: currentCumulativeETHRequested,\n            blockNumber: uint64(block.number)\n        });\n        _unstakeRequests.push(unstakeRequest);\n\n        latestCumulativeETHRequested = currentCumulativeETHRequested;\n        emit UnstakeRequestCreated(\n            requestID, requester, mETHLocked, ethRequested, currentCumulativeETHRequested, block.number\n        );\n        return requestID;\n    }\n\n    function claim(uint256 requestID, address requester) external onlyStakingContract {\n        UnstakeRequest memory request = _unstakeRequests[requestID];\n\n        if (request.requester == address(0)) {\n            revert AlreadyClaimed();\n        }\n        if (request.requester != requester) {\n            revert NotRequester();\n        }\n        if (!_isFinalized(request)) {\n            revert NotFinalized();\n        }\n        if (request.cumulativeETHRequested > allocatedETHForClaims) {\n            revert NotEnoughFunds(request.cumulativeETHRequested, allocatedETHForClaims);\n        }\n\n        delete _unstakeRequests[requestID];\n\n        totalClaimed += request.ethRequested;\n        emit UnstakeRequestClaimed(\n            request.id,\n            request.requester,\n            request.mETHLocked,\n            request.ethRequested,\n            request.cumulativeETHRequested,\n            request.blockNumber\n        );\n\n        // Burn the mETH tokens that were locked in this contract\n        mETH.burn(request.mETHLocked);\n\n        Address.sendValue(payable(requester), request.ethRequested);\n    }\n\n    function allocateETH() external payable onlyStakingContract {\n        allocatedETHForClaims += msg.value;\n    }\n\n    function balance() external view returns (uint256) {\n        if (allocatedETHForClaims > totalClaimed) {\n            return allocatedETHForClaims - totalClaimed;\n        }\n        return 0;\n    }\n\n    function _isFinalized(UnstakeRequest memory request) internal view returns (bool) {\n        return (request.blockNumber + numberOfBlocksToFinalize) <= oracle.latestRecord().updateEndBlock;\n    }\n\n    modifier onlyStakingContract() {\n        if (msg.sender != address(stakingContract)) {\n            revert NotStakingContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
        "relevance": "The UnstakeRequestsManager stores unstake requests with a fixed ethRequested amount calculated at request time. The mETH is locked but not burned until claim(), meaning these shares continue to participate in reward distribution."
      }
    ],
    "call_flow": "_unstakeRequest() -> mETHToETH() fixes rate at request time -> mETH transferred to UnstakeRequestsManager (not burned) -> claim() burns mETH and pays fixed ETH amount -> slashing/rewards between request and claim not reflected",
    "context_hint": "The _unstakeRequest function calculates ethRequested using the current exchange rate and locks mETH without burning it. Between request and claim, the mETH continues to earn rewards (diluting other holders) and any slashing is not reflected in the fixed rate, creating unfair loss distribution.",
    "is_vulnerable": true
  }
]
