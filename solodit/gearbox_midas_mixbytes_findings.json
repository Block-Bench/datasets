[
  {
    "id": "gs_mixbytes_gearbox-midas_H01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Gearbox Midas Integration Security Audit Report",
    "source_finding_id": "H-01",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Gearbox/Midas%20Integration",
    "github_repo_url": "https://github.com/Gearbox-protocol/integrations-v3",
    "contest_date": "2025-10-23",
    "severity": "high",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "rejectRequest() Leads to Adverse Consequences",
    "finding_description": "If the Midas vault admin calls rejectRequest() on a pending redemption request, the request status is set to Cancelled and the user's mTokens remain locked in the Midas vault. The Midas admin can transfer these mTokens back to any address, especially to the Gateway (which created the request). However, even if mTokens are transferred back to the Gateway, there's no mechanism to recover them from the Gateway to the user's credit account. Additionally, if mTokens are sent to the credit account or any address other than the Gateway, pendingTokenOutAmount() will continue to show a non-zero result despite the request being rejected, inflating the phantom token's balance and the credit account's collateral value.",
    "attack_scenario": "1. User creates a credit account and deposits mTokens\n2. User calls redeemRequest() through the adapter, which calls the Gateway's requestRedeem()\n3. Gateway records the pending redemption in pendingRedemptions[creditAccount] with isActive=true\n4. Midas vault admin (external trusted party) calls rejectRequest() on the pending request\n5. Request status in Midas vault is set to Cancelled, but mTokens remain locked in Midas vault\n6. Gateway's pendingRedemptions mapping still shows isActive=true\n7. pendingTokenOutAmount() returns non-zero value based on stale mTokenRate calculation\n8. Phantom token balanceOf() returns inflated value\n9. Credit account's collateral appears higher than actual recoverable value\n10. Consequences: (a) User funds permanently blocked with no recovery mechanism, (b) Inflated collateral can be exploited for additional borrowing, (c) If mTokens are sent back to Gateway, they're stuck with no transfer mechanism",
    "fix_description": "Implement functionality to handle rejected requests, allowing the system to clear rejected requests and transfer tokens out of the Gateway. The fix added manual processing capability for rejected requests to allow market curator collaboration with Midas to recover withdrawals.",
    "primary_file": {
      "path": "contracts/helpers/midas/MidasRedemptionVaultGateway.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n/// @title Midas Redemption Vault Gateway\n/// @notice Gateway contract that manages redemptions from Midas vault on behalf of users\n/// @dev Stores pending redemption requests and handles partial withdrawals\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant override contractType = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override version = 3_10;\n\n    address public immutable midasRedemptionVault;\n    address public immutable mToken;\n\n    mapping(address => PendingRedemption) public pendingRedemptions;\n\n    /// @notice Constructor\n    /// @param _midasRedemptionVault Address of the Midas Redemption Vault\n    constructor(address _midasRedemptionVault) {\n        midasRedemptionVault = _midasRedemptionVault;\n        mToken = IMidasRedemptionVault(_midasRedemptionVault).mToken();\n    }\n\n    /// @notice Performs instant redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    /// @dev Transfers mToken from sender, redeems, and transfers output token back\n    function redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount) external nonReentrant {\n        IERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\n\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n\n        IERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\n        IMidasRedemptionVault(midasRedemptionVault).redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\n\n        uint256 amount = IERC20(tokenOut).balanceOf(address(this)) - balanceBefore;\n\n        IERC20(tokenOut).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Stores the request ID and timestamp for tracking\n    function requestRedeem(address tokenOut, uint256 amountMTokenIn) external nonReentrant {\n        if (pendingRedemptions[msg.sender].isActive) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n        }\n\n        uint256 requestId = IMidasRedemptionVault(midasRedemptionVault).currentRequestId();\n\n        IERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\n\n        IERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\n        IMidasRedemptionVault(midasRedemptionVault).redeemRequest(tokenOut, amountMTokenIn);\n\n        pendingRedemptions[msg.sender] =\n            PendingRedemption({isActive: true, requestId: requestId, timestamp: block.timestamp, remainder: 0});\n    }\n\n    /// @notice Withdraws tokens from a fulfilled redemption request\n    /// @param amount Amount of output token to withdraw\n    /// @dev Supports partial withdrawals by tracking remainder\n    function withdraw(uint256 amount) external nonReentrant {\n        PendingRedemption memory pending = pendingRedemptions[msg.sender];\n\n        if (!pending.isActive) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n        }\n\n        (\n            address sender,\n            address tokenOut,\n            uint8 status,\n            uint256 amountMTokenIn,\n            uint256 mTokenRate,\n            uint256 tokenOutRate\n        ) = IMidasRedemptionVault(midasRedemptionVault).redeemRequests(pending.requestId);\n\n        if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n        }\n\n        if (status != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n        }\n\n        uint256 availableAmount;\n\n        if (pending.remainder > 0) {\n            availableAmount = pending.remainder;\n        } else {\n            availableAmount = _calculateTokenOutAmount(amountMTokenIn, mTokenRate, tokenOutRate, tokenOut);\n        }\n\n        if (amount > availableAmount) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n        }\n\n        if (amount == availableAmount) {\n            delete pendingRedemptions[msg.sender];\n        } else {\n            pendingRedemptions[msg.sender].remainder = availableAmount - amount;\n        }\n\n        IERC20(tokenOut).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice Returns the expected amount of output token for a user's pending redemption\n    /// @param user User address to check\n    /// @param tokenOut Output token to check\n    /// @return Expected amount of output token, considering any partial withdrawals\n    function pendingTokenOutAmount(address user, address tokenOut) external view returns (uint256) {\n        PendingRedemption memory pending = pendingRedemptions[user];\n\n        if (!pending.isActive) {\n            return 0;\n        }\n\n        (address sender, address requestTokenOut,, uint256 amountMTokenIn, uint256 mTokenRate, uint256 tokenOutRate) =\n            IMidasRedemptionVault(midasRedemptionVault).redeemRequests(pending.requestId);\n\n        if (sender != address(this) || requestTokenOut != tokenOut) {\n            return 0;\n        }\n\n        if (pending.remainder > 0) {\n            return pending.remainder;\n        } else {\n            return _calculateTokenOutAmount(amountMTokenIn, mTokenRate, tokenOutRate, tokenOut);\n        }\n    }\n\n    /// @dev Calculates the output token amount from mToken amount and rates\n    /// @param amountMTokenIn Amount of mToken\n    /// @param mTokenRate Rate of mToken\n    /// @param tokenOutRate Rate of output token\n    /// @param tokenOut Address of output token\n    /// @return Amount of output token in its native decimals\n    function _calculateTokenOutAmount(\n        uint256 amountMTokenIn,\n        uint256 mTokenRate,\n        uint256 tokenOutRate,\n        address tokenOut\n    ) internal view returns (uint256) {\n        uint256 amount1e18 = (amountMTokenIn * mTokenRate) / tokenOutRate;\n\n        uint256 tokenUnit = 10 ** IERC20Metadata(tokenOut).decimals();\n\n        return amount1e18 * tokenUnit / 1e18;\n    }\n}",
      "vulnerable_lines": [25, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143],
      "vulnerable_functions": ["requestRedeem", "pendingTokenOutAmount"]
    },
    "context_files": [
      {
        "path": "contracts/helpers/midas/MidasRedemptionVaultPhantomToken.sol",
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {PhantomERC20} from \"../PhantomERC20.sol\";\nimport {IPhantomToken} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IPhantomToken.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n/// @title Midas Redemption Vault phantom token\n/// @notice Phantom ERC-20 token that represents expected redemption amounts for a specific output token\ncontract MidasRedemptionVaultPhantomToken is PhantomERC20, IPhantomToken {\n    bytes32 public constant override contractType = \"PHANTOM_TOKEN::MIDAS_REDEMPTION\";\n\n    uint256 public constant override version = 3_10;\n\n    address public immutable gateway;\n\n    address public immutable tokenOut;\n\n    /// @notice Constructor\n    /// @param _gateway The gateway where redemptions are tracked\n    /// @param _tokenOut The specific output token this phantom token tracks\n    constructor(address _gateway, address _tokenOut)\n        PhantomERC20(\n            _tokenOut,\n            string.concat(\n                IERC20Metadata(IMidasRedemptionVaultGateway(_gateway).mToken()).symbol(),\n                \" redeemed to \",\n                IERC20Metadata(_tokenOut).name()\n            ),\n            string.concat(\n                IERC20Metadata(IMidasRedemptionVaultGateway(_gateway).mToken()).symbol(),\n                \"rd\",\n                IERC20Metadata(_tokenOut).symbol()\n            ),\n            IERC20Metadata(_tokenOut).decimals()\n        )\n    {\n        gateway = _gateway;\n        tokenOut = _tokenOut;\n    }\n\n    /// @notice Returns the expected amount of tokenOut from pending redemptions\n    /// @param account The account for which the calculation is performed\n    /// @return Expected amount of tokenOut that can be withdrawn\n    function balanceOf(address account) public view override returns (uint256) {\n        return IMidasRedemptionVaultGateway(gateway).pendingTokenOutAmount(account, tokenOut);\n    }\n\n    /// @notice Returns phantom token's target contract and underlying\n    /// @return gateway Gateway contract address\n    /// @return underlying Underlying token address (tokenOut)\n    function getPhantomTokenInfo() external view override returns (address, address) {\n        return (gateway, underlying);\n    }\n\n    /// @notice Serialized phantom token parameters\n    /// @return Encoded gateway and underlying token addresses\n    function serialize() external view override returns (bytes memory) {\n        return abi.encode(gateway, underlying);\n    }\n}",
        "relevance": "The phantom token's balanceOf() calls pendingTokenOutAmount() on the gateway. When a request is rejected but pendingRedemptions still shows isActive=true, this returns non-zero value, inflating the credit account's collateral."
      }
    ],
    "call_flow": "User -> MidasRedemptionVaultAdapter.redeemRequest() -> MidasRedemptionVaultGateway.requestRedeem() [records pendingRedemptions] -> Midas admin calls rejectRequest() [external, status=Cancelled] -> MidasRedemptionVaultPhantomToken.balanceOf() -> pendingTokenOutAmount() returns stale non-zero value -> Credit account collateral inflated",
    "context_hint": "The vulnerability exists because the Gateway has no mechanism to handle Midas vault admin rejecting a request. The pendingRedemptions mapping continues to show isActive=true even after rejection, and there's no way to clear it or recover the locked mTokens. The phantom token relies on pendingTokenOutAmount() which returns inflated values for rejected requests.",
    "is_vulnerable": true
  },
  {
    "id": "gs_mixbytes_gearbox-midas_M01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "mixbytes",
    "source_report": "Gearbox Midas Integration Security Audit Report",
    "source_finding_id": "M-01",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Gearbox/Midas%20Integration",
    "github_repo_url": "https://github.com/Gearbox-protocol/integrations-v3",
    "contest_date": "2025-10-23",
    "severity": "medium",
    "vulnerability_type": "input_validation",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "withdrawPhantomToken May Withdraw an Unexpected Underlying",
    "finding_description": "MidasRedemptionVaultAdapter.withdrawPhantomToken(token, amount) only checks that a phantom token is registered for the given token address (phantomTokenToOutputToken[token] != address(0)) and does not verify that the pending redemption's tokenOut matches the expected underlying. This means the integration may receive a different token than expected if the redemption request was made for a different output token than what the phantom token tracks.",
    "attack_scenario": "1. Configurator sets up phantom token A tracking output token USDC via setTokenAllowedStatusBatch()\n2. phantomTokenToOutputToken[phantomA] = USDC\n3. User makes a redemption request for output token USDT (different from USDC)\n4. pendingRedemptions records the request with tokenOut = USDT\n5. User calls withdrawPhantomToken(phantomA, amount)\n6. Function checks: phantomTokenToOutputToken[phantomA] != address(0) -> passes (it's USDC)\n7. Function calls _withdraw(amount) which executes Gateway.withdraw()\n8. Gateway.withdraw() transfers USDT (the actual redemption output) not USDC\n9. The phantom token (tracking USDC) and actual withdrawal (USDT) are mismatched\n10. Integration receives unexpected token, potentially causing accounting errors or failed operations",
    "fix_description": "Add validation in setTokenAllowedStatusBatch() to ensure that the phantom token's tokenOut matches the output token it was added alongside with. This prevents mismatched phantom token configurations.",
    "primary_file": {
      "path": "contracts/adapters/midas/MidasRedemptionVaultAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\n\n/// @title Midas Redemption Vault adapter\n/// @notice Implements logic for interacting with the Midas Redemption Vault through a gateway\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 public constant override contractType = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override version = 3_10;\n\n    /// @notice mToken\n    address public immutable override mToken;\n\n    /// @notice Gateway address\n    address public immutable override gateway;\n\n    /// @notice Mapping from phantom token to its tracked output token\n    mapping(address => address) public phantomTokenToOutputToken;\n\n    /// @notice Mapping from output token to its tracked phantom token\n    mapping(address => address) public outputTokenToPhantomToken;\n\n    /// @dev Set of allowed output tokens for redemptions\n    EnumerableSet.AddressSet internal _allowedTokens;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _gateway Midas Redemption Vault gateway address\n    constructor(address _creditManager, address _gateway) AbstractAdapter(_creditManager, _gateway) {\n        gateway = _gateway;\n        mToken = IMidasRedemptionVaultGateway(_gateway).mToken();\n\n        _getMaskOrRevert(mToken);\n    }\n\n    /// @notice Instantly redeems mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    function redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount)\n        external\n        override\n        creditFacadeOnly\n        returns (bool)\n    {\n        if (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\n\n        _redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\n\n        return false;\n    }\n\n    /// @notice Instantly redeems the entire balance of mToken for output token, except the specified amount\n    /// @param tokenOut Output token address\n    /// @param leftoverAmount Amount of mToken to keep in the account\n    /// @param rateMinRAY Minimum exchange rate from input token to mToken (in RAY format)\n    function redeemInstantDiff(address tokenOut, uint256 leftoverAmount, uint256 rateMinRAY)\n        external\n        override\n        creditFacadeOnly\n        returns (bool)\n    {\n        if (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\n\n        address creditAccount = _creditAccount();\n\n        uint256 balance = IERC20(mToken).balanceOf(creditAccount);\n        if (balance > leftoverAmount) {\n            unchecked {\n                uint256 amount = balance - leftoverAmount;\n                uint256 minReceiveAmount = (amount * rateMinRAY) / RAY;\n                _redeemInstant(tokenOut, amount, minReceiveAmount);\n            }\n        }\n        return false;\n    }\n\n    /// @dev Internal implementation of redeemInstant\n    function _redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount) internal {\n        _executeSwapSafeApprove(\n            mToken,\n            abi.encodeCall(\n                IMidasRedemptionVaultGateway.redeemInstant,\n                (tokenOut, amountMTokenIn, _convertToE18(minReceiveAmount, tokenOut))\n            )\n        );\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Returns `true` to allow safe pricing for the withdrawal phantom token\n    function redeemRequest(address tokenOut, uint256 amountMTokenIn)\n        external\n        override\n        creditFacadeOnly\n        returns (bool)\n    {\n        if (!isTokenAllowed(tokenOut) || outputTokenToPhantomToken[tokenOut] == address(0)) {\n            revert TokenNotAllowedException();\n        }\n\n        _executeSwapSafeApprove(\n            mToken, abi.encodeCall(IMidasRedemptionVaultGateway.requestRedeem, (tokenOut, amountMTokenIn))\n        );\n        return true;\n    }\n\n    /// @notice Withdraws redeemed tokens from the gateway\n    /// @param amount Amount to withdraw\n    function withdraw(uint256 amount) external override creditFacadeOnly returns (bool) {\n        _withdraw(amount);\n        return false;\n    }\n\n    /// @dev Internal implementation of withdraw\n    function _withdraw(uint256 amount) internal {\n        _execute(abi.encodeCall(IMidasRedemptionVaultGateway.withdraw, (amount)));\n    }\n\n    /// @notice Withdraws phantom token balance\n    /// @param token Phantom token address\n    /// @param amount Amount to withdraw\n    function withdrawPhantomToken(address token, uint256 amount) external override creditFacadeOnly returns (bool) {\n        if (phantomTokenToOutputToken[token] == address(0)) revert IncorrectStakedPhantomTokenException();\n        _withdraw(amount);\n        return false;\n    }\n\n    /// @notice Deposits phantom token (not implemented for redemption vaults)\n    /// @return Never returns (always reverts)\n    /// @dev Redemption vaults only support withdrawals, not deposits\n    function depositPhantomToken(address, uint256) external pure override returns (bool) {\n        revert NotImplementedException();\n    }\n\n    /// @dev Converts the token amount to 18 decimals, which is accepted by Midas\n    function _convertToE18(uint256 amount, address token) internal view returns (uint256) {\n        uint256 tokenUnit = 10 ** IERC20Metadata(token).decimals();\n        return amount * WAD / tokenUnit;\n    }\n\n    /// @notice Returns whether a token is allowed as output for redemptions\n    /// @param token Token address to check\n    /// @return True if token is allowed\n    function isTokenAllowed(address token) public view override returns (bool) {\n        return _allowedTokens.contains(token);\n    }\n\n    /// @notice Returns all allowed output tokens\n    /// @return Array of allowed token addresses\n    function allowedTokens() public view override returns (address[] memory) {\n        return _allowedTokens.values();\n    }\n\n    /// @notice Sets the allowed status for a batch of output tokens\n    /// @param configs Array of MidasAllowedTokenStatus structs\n    /// @dev Can only be called by the configurator\n    function setTokenAllowedStatusBatch(MidasAllowedTokenStatus[] calldata configs)\n        external\n        override\n        configuratorOnly\n    {\n        uint256 len = configs.length;\n\n        for (uint256 i; i < len; ++i) {\n            MidasAllowedTokenStatus memory config = configs[i];\n\n            if (config.allowed) {\n                _getMaskOrRevert(config.token);\n                _allowedTokens.add(config.token);\n\n                if (config.phantomToken != address(0)) {\n                    _getMaskOrRevert(config.phantomToken);\n                    phantomTokenToOutputToken[config.phantomToken] = config.token;\n                    outputTokenToPhantomToken[config.token] = config.phantomToken;\n                }\n            } else {\n                _allowedTokens.remove(config.token);\n\n                address phantomToken = outputTokenToPhantomToken[config.token];\n\n                if (phantomToken != address(0)) {\n                    delete outputTokenToPhantomToken[config.token];\n                    delete phantomTokenToOutputToken[phantomToken];\n                }\n            }\n\n            emit SetTokenAllowedStatus(config.token, config.phantomToken, config.allowed);\n        }\n    }\n\n    /// @notice Serialized adapter parameters\n    /// @return serializedData Encoded adapter configuration\n    function serialize() external view returns (bytes memory serializedData) {\n        serializedData = abi.encode(creditManager, targetContract, gateway, mToken, allowedTokens());\n    }\n}",
      "vulnerable_lines": [140, 141, 142, 143, 144],
      "vulnerable_functions": ["withdrawPhantomToken"]
    },
    "context_files": [],
    "call_flow": "User -> MidasRedemptionVaultAdapter.withdrawPhantomToken(phantomToken, amount) -> checks phantomTokenToOutputToken[token] != 0 (only checks registration, not tokenOut match) -> _withdraw(amount) -> Gateway.withdraw() -> transfers actual redemption tokenOut (may differ from phantom's tracked token)",
    "context_hint": "The withdrawPhantomToken function accepts a phantom token address and checks that it's registered in phantomTokenToOutputToken mapping. However, it doesn't verify that the pending redemption in the Gateway was actually made for the same output token that the phantom token tracks. The Gateway's withdraw() function will transfer whatever tokenOut was specified in the original redeemRequest(), which may differ from phantomTokenToOutputToken[token].",
    "is_vulnerable": true
  }
]
