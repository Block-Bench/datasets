[
  {
    "id": "gs_mixbytes_velodrome-pool-launcher_M01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "base",
    "source_platform": "mixbytes",
    "source_report": "Velodrome Pool Launcher Security Audit Report",
    "source_finding_id": "M-1",
    "report_url": "https://github.com/mixbytes/audits_public/tree/master/Velodrome/Pool%20Launcher",
    "github_repo_url": "https://github.com/velodrome-finance/pool-launcher",
    "contest_date": "2025-09-12",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "multi_file",
    "finding_title": "Unclaimed Fees Become Inaccessible After V2Locker.unlock()",
    "finding_description": "The Locker.claimFees() function is protected by the onlyLocked modifier, which requires lockedUntil != 0. Inside V2Locker.unlock(), the contract sets lockedUntil = 0 (via delete lockedUntil) before transferring the LP tokens to the recipient. During the LP token transfer, the underlying pool credits all accumulated fees to the locker contract. Once the LP tokens are transferred out, the locker can no longer call claimFees() because it is no longer locked (lockedUntil == 0), leaving those fees permanently stranded on the contract. A user who forgets to call claimFees() before unlocking will lose the entire fee balance earned up to that moment.",
    "attack_scenario": "1. User creates a V2Locker and deposits LP tokens into a Velodrome V2 pool\n2. Over time, the pool accumulates trading fees for the locker\n3. The lock period expires and the user calls unlock() to retrieve their LP tokens\n4. Inside unlock(), lockedUntil is set to 0 on line 46\n5. The LP tokens are transferred to the recipient on line 48\n6. During this transfer, the V2Pool.claimFees() is implicitly called, crediting fees to the locker contract\n7. User realizes they forgot to claim fees and tries to call claimFees()\n8. claimFees() reverts with NotLocked() because lockedUntil == 0 (onlyLocked modifier check fails)\n9. The accumulated fees (token0 and token1) are permanently stuck on the locker contract with no way to retrieve them",
    "fix_description": "Claim swap fees within the V2Locker.unlock() function before setting lockedUntil to 0. This ensures all accumulated fees are sent to the recipient before the lock state is cleared.",
    "primary_file": {
      "path": "src/extensions/v2/V2Locker.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19 <0.9.0;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\n\n/// @title V2Locker\n/// @author velodrome.finance\n/// @notice Manages locking liquidity, staking, and claiming rewards for V2 pools.\ncontract V2Locker is Locker, IV2Locker {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IV2Locker\n    address public immutable router;\n\n    uint256 internal _lp;\n\n    constructor(\n        bool _root,\n        address _owner,\n        address _pool,\n        address _router,\n        uint256 _lp_,\n        uint32 _lockedUntil,\n        address _beneficiary,\n        uint16 _beneficiaryShare,\n        uint16 _bribeableShare\n    ) Locker(_root, _owner, _pool, _lockedUntil, _beneficiary, _beneficiaryShare, _bribeableShare) {\n        router = _router;\n        _lp = _lp_;\n        (token0, token1) = IV2Pool(pool).tokens();\n    }\n\n    /// @inheritdoc Locker\n    function unlock(address _recipient) external override(Locker, ILocker) onlyLocked nonReentrant returns (uint256) {\n        if (msg.sender != factory) revert NotFactory();\n\n        delete staked;\n        delete lockedUntil;\n\n        IERC20(pool).safeTransfer({to: _recipient, value: _lp});\n\n        /// @dev Refund locked balances\n        uint256 leftover = IERC20(token0).balanceOf({account: address(this)});\n        if (leftover > 0) IERC20(token0).safeTransfer({to: _recipient, value: leftover});\n        leftover = IERC20(token1).balanceOf({account: address(this)});\n        if (leftover > 0) IERC20(token1).safeTransfer({to: _recipient, value: leftover});\n\n        emit Unlocked({recipient: _recipient});\n        return _lp;\n    }\n\n    /// @inheritdoc Locker\n    function stake() external override(Locker, ILocker) nonReentrant onlyOwner onlyLocked ensureGauge {\n        if (staked) revert AlreadyStaked();\n        staked = true;\n\n        _claimFees({_recipient: owner()});\n\n        IERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: _lp});\n        gauge.deposit({lp: _lp});\n        emit Staked();\n    }\n\n    /// @inheritdoc Locker\n    function increaseLiquidity(uint256 _amount0, uint256 _amount1, uint256 _amount0Min, uint256 _amount1Min)\n        external\n        override(ILocker, Locker)\n        nonReentrant\n        onlyOwner\n        onlyLocked\n        returns (uint256)\n    {\n        if (_amount0 == 0 && _amount1 == 0) revert ZeroAmount();\n\n        uint256 supplied0 = _fundLocker({_token: token0, _totalBal: _amount0});\n        uint256 supplied1 = _fundLocker({_token: token1, _totalBal: _amount1});\n\n        IERC20(token0).forceApprove({spender: router, value: _amount0});\n        IERC20(token1).forceApprove({spender: router, value: _amount1});\n\n        (uint256 amount0Deposited, uint256 amount1Deposited, uint256 liquidity) = IV2Router(router).addLiquidity({\n            tokenA: token0,\n            tokenB: token1,\n            stable: IV2Pool(pool).stable(),\n            amountADesired: _amount0,\n            amountBDesired: _amount1,\n            amountAMin: _amount0Min,\n            amountBMin: _amount1Min,\n            to: address(this),\n            deadline: block.timestamp\n        });\n\n        IERC20(token0).forceApprove({spender: router, value: 0});\n        IERC20(token1).forceApprove({spender: router, value: 0});\n\n        address recipient = owner();\n        _refundLeftover({_token: token0, _recipient: recipient, _maxAmount: supplied0});\n        _refundLeftover({_token: token1, _recipient: recipient, _maxAmount: supplied1});\n\n        if (staked) {\n            IERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: liquidity});\n            gauge.deposit({lp: liquidity});\n        }\n\n        _lp += liquidity;\n\n        emit LiquidityIncreased({amount0: amount0Deposited, amount1: amount1Deposited, liquidity: liquidity});\n        return liquidity;\n    }\n\n    function _collectFees() internal override returns (uint256 claimed0, uint256 claimed1) {\n        (claimed0, claimed1) = IV2Pool(pool).claimFees();\n\n        uint256 share0 = _deductShare({_amount: claimed0, _token: token0});\n        uint256 share1 = _deductShare({_amount: claimed1, _token: token1});\n        claimed0 -= share0;\n        claimed1 -= share1;\n\n        if (share0 > 0 || share1 > 0) {\n            emit FeesClaimed({recipient: beneficiary, claimed0: share0, claimed1: share1});\n        }\n    }\n\n    function _collectRewards() internal override returns (uint256 claimed) {\n        uint256 rewardsBefore = IERC20(rewardToken).balanceOf({account: address(this)});\n        gauge.getReward({account: address(this)});\n        uint256 rewardsAfter = IERC20(rewardToken).balanceOf({account: address(this)});\n\n        claimed = rewardsAfter - rewardsBefore;\n        uint256 share = _deductShare({_amount: claimed, _token: rewardToken});\n        claimed -= share;\n\n        if (share > 0) {\n            emit RewardsClaimed({recipient: beneficiary, claimed: share});\n        }\n    }\n\n    function lp() public view override(ILocker, Locker) returns (uint256) {\n        return _lp;\n    }\n}",
      "vulnerable_lines": [42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58],
      "vulnerable_functions": ["unlock"]
    },
    "context_files": [
      {
        "path": "src/Locker.sol",
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19 <0.9.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuardTransient} from \"@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IVoter} from \"./external/IVoter.sol\";\nimport {IVotingEscrow} from \"./external/IVotingEscrow.sol\";\nimport {IGauge} from \"./external/IGauge.sol\";\nimport {IBribeVotingReward} from \"./external/IBribeVotingReward.sol\";\nimport {ILockerFactory} from \"./interfaces/ILockerFactory.sol\";\nimport {ILocker} from \"./interfaces/ILocker.sol\";\n\n/// @title Locker\n/// @author velodrome.finance\n/// @notice Manages locking liquidity, staking, and claiming rewards\nabstract contract Locker is ILocker, Ownable, ReentrancyGuardTransient {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc ILocker\n    uint256 public constant MAX_BPS = 10_000;\n\n    /// @inheritdoc ILocker\n    uint256 public constant BASE_CHAIN_ID = 8453;\n\n    /// @inheritdoc ILocker\n    IVoter public immutable voter;\n    /// @inheritdoc ILocker\n    address public immutable factory;\n    /// @inheritdoc ILocker\n    ILockerFactory.PoolType public immutable poolType;\n\n    /// @inheritdoc ILocker\n    address public immutable pool;\n    /// @inheritdoc ILocker\n    address public immutable token0;\n    /// @inheritdoc ILocker\n    address public immutable token1;\n    /// @inheritdoc ILocker\n    address public immutable rewardToken;\n    /// @inheritdoc ILocker\n    address public immutable beneficiary;\n    /// @inheritdoc ILocker\n    uint16 public immutable beneficiaryShare;\n    /// @inheritdoc ILocker\n    bool public immutable root;\n\n    /// @inheritdoc ILocker\n    IGauge public gauge;\n    /// @inheritdoc ILocker\n    uint16 public bribeableShare;\n    /// @inheritdoc ILocker\n    uint32 public lockedUntil;\n    /// @inheritdoc ILocker\n    bool public staked;\n\n    constructor(\n        bool _root,\n        address _owner,\n        address _pool,\n        uint32 _lockedUntil,\n        address _beneficiary,\n        uint16 _beneficiaryShare,\n        uint16 _bribeableShare\n    ) Ownable(_owner) {\n        factory = msg.sender;\n        voter = IVoter(ILockerFactory(factory).voter());\n        rewardToken = IVotingEscrow(voter.ve()).token();\n        poolType = ILockerFactory(factory).poolType();\n\n        root = _root;\n        pool = _pool;\n        lockedUntil = _lockedUntil;\n\n        beneficiary = _beneficiary;\n        beneficiaryShare = _beneficiaryShare;\n        bribeableShare = _bribeableShare;\n    }\n\n    modifier onlyLocked() {\n        if (lockedUntil == 0) revert NotLocked();\n        _;\n    }\n\n    modifier ensureGauge() {\n        if (address(gauge) == address(0)) {\n            address _gauge = voter.gauges({pool: pool});\n            if (_gauge == address(0)) revert NoGauge();\n            gauge = IGauge(_gauge);\n        }\n        _;\n    }\n\n    /// @inheritdoc ILocker\n    function unlock(address _recipient) external virtual returns (uint256);\n\n    /// @inheritdoc ILocker\n    function stake() external virtual;\n\n    /// @inheritdoc ILocker\n    function unstake() external nonReentrant onlyOwner onlyLocked {\n        if (!staked) revert NotStaked();\n        delete staked;\n\n        _claimRewards({_recipient: owner()});\n        IGauge(gauge).withdraw({lp: lp()});\n        emit Unstaked();\n    }\n\n    /// @inheritdoc ILocker\n    function claimFees(address _recipient)\n        public\n        onlyOwner\n        onlyLocked\n        nonReentrant\n        returns (uint256 claimed0, uint256 claimed1)\n    {\n        if (staked) revert LockerStaked();\n        return _claimFees({_recipient: _recipient});\n    }\n\n    /// @inheritdoc ILocker\n    function claimRewards(address _recipient) external onlyOwner onlyLocked nonReentrant returns (uint256 claimed) {\n        if (!staked) revert NotStaked();\n\n        return _claimRewards({_recipient: _recipient});\n    }\n\n    /// @inheritdoc ILocker\n    function bribe(uint16 _percentage) external onlyOwner onlyLocked ensureGauge nonReentrant {\n        if (_percentage > bribeableShare) revert InvalidPercentage();\n\n        address briber = root || block.chainid == BASE_CHAIN_ID\n            ? voter.gaugeToBribe({gauge: address(gauge)})\n            : voter.gaugeToIncentive({gauge: address(gauge)});\n\n        if (staked) {\n            uint256 claimed = _collectRewards();\n            uint256 bribeAmount = _calculatePercentage({_amount: claimed, _percentage: _percentage});\n\n            _bribe({_briber: briber, _token: rewardToken, _amount: bribeAmount});\n            /// @dev msg.sender is the owner\n            IERC20(rewardToken).safeTransfer({to: msg.sender, value: claimed - bribeAmount});\n        } else {\n            (uint256 claimed0, uint256 claimed1) = _collectFees();\n            uint256 bribeAmount0 = _calculatePercentage({_amount: claimed0, _percentage: _percentage});\n            uint256 bribeAmount1 = _calculatePercentage({_amount: claimed1, _percentage: _percentage});\n\n            if (bribeAmount0 > 0) {\n                _bribe({_briber: briber, _token: token0, _amount: bribeAmount0});\n                IERC20(token0).safeTransfer({to: msg.sender, value: claimed0 - bribeAmount0});\n            }\n            if (bribeAmount1 > 0) {\n                _bribe({_briber: briber, _token: token1, _amount: bribeAmount1});\n                IERC20(token1).safeTransfer({to: msg.sender, value: claimed1 - bribeAmount1});\n            }\n        }\n    }\n\n    /// @inheritdoc ILocker\n    function increaseDuration(uint32 _duration) external onlyOwner nonReentrant {\n        if (_duration == 0) revert ZeroDuration();\n        uint32 _lockedUntil = lockedUntil;\n        if (block.timestamp >= _lockedUntil) revert NotLocked();\n        if (_lockedUntil == type(uint32).max) revert PermanentLock();\n\n        _lockedUntil = _duration == type(uint32).max ? type(uint32).max : _lockedUntil + _duration;\n        lockedUntil = _lockedUntil;\n        emit UnlockTimestampIncreased({newUnlockTimestamp: _lockedUntil});\n    }\n\n    /// @inheritdoc ILocker\n    function increaseLiquidity(uint256 _amount0, uint256 _amount1, uint256 _amount0Min, uint256 _amount1Min)\n        external\n        virtual\n        returns (uint256);\n\n    /// @inheritdoc ILocker\n    function setBribeableShare(uint16 _bribeableShare) external onlyOwner nonReentrant {\n        if (_bribeableShare > MAX_BPS) revert InvalidBribeableShare();\n        bribeableShare = _bribeableShare;\n        emit BribeableShareSet({newBribeableShare: _bribeableShare});\n    }\n\n    function _claimFees(address _recipient) internal returns (uint256 claimed0, uint256 claimed1) {\n        (claimed0, claimed1) = _collectFees();\n\n        IERC20(token0).safeTransfer({to: _recipient, value: claimed0});\n        IERC20(token1).safeTransfer({to: _recipient, value: claimed1});\n\n        emit FeesClaimed({recipient: _recipient, claimed0: claimed0, claimed1: claimed1});\n    }\n\n    function _collectFees() internal virtual returns (uint256 claimed0, uint256 claimed1);\n\n    function _claimRewards(address _recipient) internal returns (uint256 claimed) {\n        claimed = _collectRewards();\n\n        if (claimed > 0) {\n            IERC20(rewardToken).safeTransfer({to: _recipient, value: claimed});\n            emit RewardsClaimed({recipient: _recipient, claimed: claimed});\n        }\n    }\n\n    function _collectRewards() internal virtual returns (uint256 claimed);\n\n    function _bribe(address _briber, address _token, uint256 _amount) private {\n        IERC20(_token).safeIncreaseAllowance({spender: _briber, value: _amount});\n        IBribeVotingReward(_briber).notifyRewardAmount({token: _token, amount: _amount});\n        emit Bribed({pool: pool, token: _token, amount: _amount});\n    }\n\n    function _deductShare(uint256 _amount, address _token) internal returns (uint256 share) {\n        if (beneficiary == address(0)) return 0;\n\n        share = _calculatePercentage({_amount: _amount, _percentage: beneficiaryShare});\n\n        if (share > 0) {\n            IERC20(_token).safeTransfer({to: beneficiary, value: share});\n        }\n    }\n\n    function _calculatePercentage(uint256 _amount, uint16 _percentage) private pure returns (uint256) {\n        return (_amount * _percentage) / MAX_BPS;\n    }\n\n    /**\n     * @notice Funds up to a specified balance\n     * @dev Used to fund liquidity deposits\n     * @param _token The address of the token to transfer\n     * @param _totalBal The target balance this contract should be topped up to\n     * @return The amount of tokens transferred\n     */\n    function _fundLocker(address _token, uint256 _totalBal) internal returns (uint256) {\n        uint256 bal = IERC20(_token).balanceOf(address(this));\n        //slither-disable-next-line uninitialized-local\n        uint256 suppliedAmount;\n        if (bal < _totalBal) {\n            suppliedAmount = _totalBal - bal;\n            IERC20(_token).safeTransferFrom({from: msg.sender, to: address(this), value: suppliedAmount});\n        }\n        return suppliedAmount;\n    }\n\n    /**\n     * @notice Refunds any leftover tokens to a recipient, up to a max amount\n     * @dev Should be used after increasing the liquidity of a position\n     * @param _token The address of the token to refund\n     * @param _recipient The recipient for the refund\n     * @param _maxAmount The maximum amount of tokens that can be refunded\n     */\n    function _refundLeftover(address _token, address _recipient, uint256 _maxAmount) internal {\n        if (_maxAmount > 0) {\n            uint256 lockerBal = IERC20(_token).balanceOf(address(this));\n            if (lockerBal > 0) {\n                IERC20(_token).safeTransfer({to: _recipient, value: lockerBal < _maxAmount ? lockerBal : _maxAmount});\n            }\n        }\n    }\n\n    /// @inheritdoc ILocker\n    function lp() public view virtual returns (uint256);\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`)\n     * @dev Overrides Ownable._transferOwnership to update LockerFactory mappings\n     * @param newOwner The address of the new owner\n     */\n    function _transferOwnership(address newOwner) internal override {\n        /// @dev account for initial ownership transfer where owner() is address(0) and factory is not defined\n        if (owner() != address(0)) {\n            ILockerFactory(factory).transferLockerOwnership({_owner: owner(), _newOwner: newOwner, _pool: pool});\n        }\n        super._transferOwnership({newOwner: newOwner});\n    }\n}",
        "relevance": "Contains the onlyLocked modifier (lines 82-85) that checks 'if (lockedUntil == 0) revert NotLocked()' and the claimFees() function (lines 113-122) that is protected by this modifier. This is why fees become inaccessible after unlock() clears lockedUntil."
      }
    ],
    "call_flow": "User calls V2LockerFactory.unlock() -> V2Locker.unlock() -> delete lockedUntil (line 46) -> IERC20(pool).safeTransfer() triggers fee crediting -> fees stuck because claimFees() now reverts with NotLocked() due to lockedUntil == 0",
    "context_hint": "The unlock() function in V2Locker.sol sets lockedUntil to 0 before transferring LP tokens. The claimFees() function in the parent Locker.sol contract requires lockedUntil != 0 (onlyLocked modifier). When LP tokens are transferred, fees are credited to the locker, but they cannot be claimed afterward because the lock state has been cleared.",
    "is_vulnerable": true
  }
]
