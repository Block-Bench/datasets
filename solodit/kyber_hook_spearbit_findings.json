[
  {
    "id": "gs_spearbit_kyber-hook_M01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Uniswap Foundation: Kyber Hook Security Review",
    "source_finding_id": "M-01",
    "report_url": "https://github.com/spearbit/portfolio/tree/master/pdfs",
    "github_repo_url": "https://github.com/KyberNetwork/kyber-exclusive-amm-sc",
    "contest_date": "2025-10-01",
    "severity": "medium",
    "vulnerability_type": "signature_replay",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "Signed swap digest lacks a domain separator",
    "finding_description": "Both UniswapV4KEMHook and PancakeSwapInfinityKEMHook rebuild a quote digest by hashing sender, key, params.zeroForOne, maxAmountIn, maxExchangeRate, exchangeRateDenom, nonce, and expiryTime. The tuple ties the authorization to the router (sender), the full PoolKey (which includes the hook address), trade direction, price and input caps, nonce and expiry. Crucially, no domain separator is folded in: chain ID, deployment salt, and contract identity outside key are absent. If the same hook instance (or the same PoolKey) is deployed on multiple networks, as CREATE3-based salt mining allows, an attacker can lift any valid signature+nonce from chain A and replay it on chain B. Because the digest matches, SignatureChecker.isValidSignatureNow succeeds and the swap executes without the signer's intention. That breaks the core guarantee that signed quotes are single-instance authorizations, allowing cross-chain replay swaps.",
    "attack_scenario": "1. Kyber deploys UniswapV4KEMHook on Ethereum mainnet with a specific PoolKey\n2. Same hook (or same PoolKey configuration) is deployed on Arbitrum using CREATE3 salt mining to get matching address\n3. User requests a quote on Ethereum, quoteSigner signs: keccak256(abi.encode(sender, key, zeroForOne, maxAmountIn, maxExchangeRate, exchangeRateDenom, nonce, expiryTime))\n4. User broadcasts swap transaction on Ethereum mainnet\n5. Attacker observes the transaction in Ethereum mempool, extracts signature and hookData\n6. Attacker submits identical calldata on Arbitrum before expiryTime\n7. On Arbitrum: sender (router) matches, key matches (same pool configuration), all other parameters match\n8. SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature) returns true\n9. Swap executes on Arbitrum without signer's intention\n10. If nonce != 0, Ethereum swap may still succeed (different nonce storage per chain), causing double execution",
    "fix_description": "Introduce domain separation for the signed payload in both hooks. Adopt an EIP712 domain that at minimum commits to chainid. This ensures signatures are only valid on the intended chain.",
    "primary_file": {
      "path": "src/UniswapV4KEMHook.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable poolManager;\n\n  constructor(\n    IPoolManager _poolManager,\n    address initialOwner,\n    address[] memory initialClaimableAccounts,\n    address initialQuoteSigner,\n    address initialEgRecipient\n  ) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) {\n    poolManager = _poolManager;\n    Hooks.validateHookPermissions(IHooks(address(this)), getHookPermissions());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier onlyPoolManager() {\n    if (msg.sender != address(poolManager)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public {\n    require(claimable[msg.sender], NonClaimableAccount(msg.sender));\n    require(tokens.length == amounts.length, MismatchedArrayLengths());\n\n    poolManager.unlock(abi.encode(tokens, amounts));\n  }\n\n  function unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) {\n    (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint256 id = uint256(uint160(tokens[i]));\n      if (amounts[i] == 0) {\n        amounts[i] = poolManager.balanceOf(address(this), id);\n      }\n      if (amounts[i] > 0) {\n        poolManager.burn(address(this), id, amounts[i]);\n        poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n      }\n    }\n\n    emit ClaimEgTokens(egRecipient, tokens, amounts);\n  }\n\n  function getHookPermissions() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      beforeInitialize: false,\n      afterInitialize: false,\n      beforeAddLiquidity: false,\n      afterAddLiquidity: false,\n      beforeRemoveLiquidity: false,\n      afterRemoveLiquidity: false,\n      beforeSwap: true,\n      afterSwap: true,\n      beforeDonate: false,\n      afterDonate: false,\n      beforeSwapReturnDelta: false,\n      afterSwapReturnDelta: true,\n      afterAddLiquidityReturnDelta: false,\n      afterRemoveLiquidityReturnDelta: false\n    });\n  }\n\n  function beforeSwap(\n    address sender,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n    require(params.amountSpecified < 0, ExactOutputDisabled());\n\n    (\n      int256 maxAmountIn,\n      int256 maxExchangeRate,\n      int256 exchangeRateDenom,\n      uint256 nonce,\n      uint256 expiryTime,\n      bytes memory signature\n    ) = HookDataDecoder.decodeAllHookData(hookData);\n\n    require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\n    require(\n      -params.amountSpecified <= maxAmountIn,\n      ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n    );\n\n    _useUnorderedNonce(nonce);\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        sender,\n        key,\n        params.zeroForOne,\n        maxAmountIn,\n        maxExchangeRate,\n        exchangeRateDenom,\n        nonce,\n        expiryTime\n      )\n    );\n    require(\n      SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n    );\n\n    return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function afterSwap(\n    address,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    BalanceDelta delta,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, int128) {\n    (int256 maxExchangeRate, int256 exchangeRateDenom) =\n      HookDataDecoder.decodeExchangeRate(hookData);\n\n    int128 amountIn;\n    int128 amountOut;\n    Currency currencyOut;\n    unchecked {\n      if (params.zeroForOne) {\n        amountIn = -delta.amount0();\n        amountOut = delta.amount1();\n        currencyOut = key.currency1;\n      } else {\n        amountIn = -delta.amount1();\n        amountOut = delta.amount0();\n        currencyOut = key.currency0;\n      }\n    }\n\n    int256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom;\n\n    unchecked {\n      int256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0);\n      if (egAmount > 0) {\n        poolManager.mint(\n          address(this), uint256(uint160(Currency.unwrap(currencyOut))), uint256(egAmount)\n        );\n\n        emit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount);\n      }\n\n      return (this.afterSwap.selector, int128(egAmount));\n    }\n  }\n}",
      "vulnerable_lines": [118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129],
      "vulnerable_functions": ["beforeSwap"]
    },
    "context_files": [
      {
        "path": "src/PancakeSwapInfinityKEMHook.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\n\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IVault} from 'pancakeswap/infinity-core/src/interfaces/IVault.sol';\nimport {ICLPoolManager} from 'pancakeswap/infinity-core/src/pool-cl/interfaces/ICLPoolManager.sol';\n\nimport {BalanceDelta} from 'pancakeswap/infinity-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta,\n  BeforeSwapDeltaLibrary\n} from 'pancakeswap/infinity-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'pancakeswap/infinity-core/src/types/Currency.sol';\nimport {PoolId} from 'pancakeswap/infinity-core/src/types/PoolId.sol';\nimport {PoolKey} from 'pancakeswap/infinity-core/src/types/PoolKey.sol';\n\nimport {\n  HOOKS_AFTER_SWAP_OFFSET,\n  HOOKS_AFTER_SWAP_RETURNS_DELTA_OFFSET,\n  HOOKS_BEFORE_SWAP_OFFSET\n} from 'pancakeswap/infinity-core/src/pool-cl/interfaces/ICLHooks.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title PancakeSwapInfinityKEMHook\ncontract PancakeSwapInfinityKEMHook is BaseKEMHook {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice Thrown when the caller is not Vault\n  error NotVault();\n\n  /// @notice The address of the PoolManager contract\n  ICLPoolManager public immutable poolManager;\n\n  /// @notice The address of the Vault contract\n  IVault public immutable vault;\n\n  constructor(\n    ICLPoolManager _poolManager,\n    address initialOwner,\n    address[] memory initialClaimableAccounts,\n    address initialQuoteSigner,\n    address initialEgRecipient\n  ) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) {\n    poolManager = _poolManager;\n    vault = _poolManager.vault();\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier onlyPoolManager() {\n    if (msg.sender != address(poolManager)) revert NotPoolManager();\n    _;\n  }\n\n  /// @notice Only allow calls from the Vault contract\n  modifier onlyVault() {\n    if (msg.sender != address(vault)) revert NotVault();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public {\n    require(claimable[msg.sender], NonClaimableAccount(msg.sender));\n    require(tokens.length == amounts.length, MismatchedArrayLengths());\n\n    vault.lock(abi.encode(tokens, amounts));\n  }\n\n  function lockAcquired(bytes calldata data) public onlyVault returns (bytes memory) {\n    (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      Currency currency = Currency.wrap(tokens[i]);\n      if (amounts[i] == 0) {\n        amounts[i] = vault.balanceOf(address(this), currency);\n      }\n      if (amounts[i] > 0) {\n        vault.burn(address(this), currency, amounts[i]);\n        vault.take(currency, egRecipient, amounts[i]);\n      }\n    }\n\n    emit ClaimEgTokens(egRecipient, tokens, amounts);\n  }\n\n  function getHooksRegistrationBitmap() external pure returns (uint16) {\n    return uint16(\n      (1 << HOOKS_BEFORE_SWAP_OFFSET) | (1 << HOOKS_AFTER_SWAP_OFFSET)\n        | (1 << HOOKS_AFTER_SWAP_RETURNS_DELTA_OFFSET)\n    );\n  }\n\n  function beforeSwap(\n    address sender,\n    PoolKey calldata key,\n    ICLPoolManager.SwapParams calldata params,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n    require(params.amountSpecified < 0, ExactOutputDisabled());\n\n    (\n      int256 maxAmountIn,\n      int256 maxExchangeRate,\n      int256 exchangeRateDenom,\n      uint256 nonce,\n      uint256 expiryTime,\n      bytes memory signature\n    ) = HookDataDecoder.decodeAllHookData(hookData);\n\n    require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\n    require(\n      -params.amountSpecified <= maxAmountIn,\n      ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n    );\n\n    _useUnorderedNonce(nonce);\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        sender,\n        key,\n        params.zeroForOne,\n        maxAmountIn,\n        maxExchangeRate,\n        exchangeRateDenom,\n        nonce,\n        expiryTime\n      )\n    );\n    require(\n      SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n    );\n\n    return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function afterSwap(\n    address,\n    PoolKey calldata key,\n    ICLPoolManager.SwapParams calldata params,\n    BalanceDelta delta,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, int128) {\n    (int256 maxExchangeRate, int256 exchangeRateDenom) =\n      HookDataDecoder.decodeExchangeRate(hookData);\n\n    int128 amountIn;\n    int128 amountOut;\n    Currency currencyOut;\n    unchecked {\n      if (params.zeroForOne) {\n        amountIn = -delta.amount0();\n        amountOut = delta.amount1();\n        currencyOut = key.currency1;\n      } else {\n        amountIn = -delta.amount1();\n        amountOut = delta.amount0();\n        currencyOut = key.currency0;\n      }\n    }\n\n    int256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom;\n\n    unchecked {\n      int256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0);\n      if (egAmount > 0) {\n        vault.mint(address(this), currencyOut, uint256(egAmount));\n\n        emit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount);\n      }\n\n      return (this.afterSwap.selector, int128(egAmount));\n    }\n  }\n}",
        "relevance": "PancakeSwapInfinityKEMHook has identical vulnerability in beforeSwap() at lines 124-135. Same digest construction without domain separator enables cross-chain replay attacks on PancakeSwap Infinity pools."
      }
    ],
    "call_flow": "Router.swap() -> PoolManager.swap() -> UniswapV4KEMHook.beforeSwap(sender=router, key, params, hookData) -> HookDataDecoder.decodeAllHookData(hookData) extracts signature params -> keccak256(abi.encode(sender, key, zeroForOne, maxAmountIn, maxExchangeRate, exchangeRateDenom, nonce, expiryTime)) creates digest WITHOUT chainId -> SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature) validates -> Same signature valid on any chain with matching parameters",
    "context_hint": "The vulnerability is in the digest creation at lines 118-129. The keccak256 hash does not include chainId or any EIP712 domain separator. Since sender is the router contract (same on multiple chains), key is the PoolKey (can be identical across chains), and all other parameters are user-provided, an attacker can replay the exact same signature on a different chain where the same hook/pool configuration exists.",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_kyber-hook_M02",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Uniswap Foundation: Kyber Hook Security Review",
    "source_finding_id": "M-02",
    "report_url": "https://github.com/spearbit/portfolio/tree/master/pdfs",
    "github_repo_url": "https://github.com/KyberNetwork/kyber-exclusive-amm-sc",
    "contest_date": "2025-10-01",
    "severity": "medium",
    "vulnerability_type": "front_running",
    "difficulty_tier": 2,
    "context_level": "multi_file",
    "finding_title": "Quotes can be frontrun by replaying them through the router",
    "finding_description": "Both hooks accept swaps when SignatureChecker validates keccak256(abi.encode(sender, key, ..., nonce, expiryTime)). The sender field is the router contract that called the pool manager. That restricts execution to Kyber's router, but not to any particular user. Because the router is public, anyone can forward the calldata and signature. If Alice broadcasts a signed swap, an MEV bot can copy the calldata, submit it first and the hook sees the same router address and quote terms: the attacker's swap succeeds, consuming the nonce. Alice's transaction then reverts at _useUnorderedNonce because the nonce is already marked as used. The attacker, this way, can invalidate the quote with a dust swap. Designers intended router-level exclusivity, yet end users receive no front-running protection, exposing every quote to mempool sniping.",
    "attack_scenario": "1. Alice requests a quote from Kyber backend for swapping 100 ETH -> USDC\n2. Kyber quoteSigner signs the quote with parameters: sender=router, maxAmountIn=100e18, maxExchangeRate, nonce=12345, expiryTime=now+60s\n3. Alice constructs swap transaction and broadcasts to mempool\n4. MEV bot observes Alice's pending transaction, extracts hookData containing signature\n5. Bot constructs identical swap call through same router with minimal amountSpecified (e.g., 0.001 ETH)\n6. Bot submits with higher gas price, gets included first\n7. Hook.beforeSwap() validates: sender=router (matches), signature valid, nonce 12345 unused -> swap succeeds\n8. _useUnorderedNonce(12345) marks nonce as used\n9. Alice's transaction executes next: same signature, same nonce\n10. _useUnorderedNonce(12345) reverts with NonceAlreadyUsed(12345)\n11. Alice's swap fails, bot successfully griefed the quote (or profited if quote was favorable)",
    "fix_description": "Include the router's original caller in the signature. The original caller can be retrieved by the hook by calling router.msgSender() function. This ensures the signature is bound to a specific end user, not just the router contract.",
    "primary_file": {
      "path": "src/UniswapV4KEMHook.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable poolManager;\n\n  constructor(\n    IPoolManager _poolManager,\n    address initialOwner,\n    address[] memory initialClaimableAccounts,\n    address initialQuoteSigner,\n    address initialEgRecipient\n  ) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) {\n    poolManager = _poolManager;\n    Hooks.validateHookPermissions(IHooks(address(this)), getHookPermissions());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier onlyPoolManager() {\n    if (msg.sender != address(poolManager)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public {\n    require(claimable[msg.sender], NonClaimableAccount(msg.sender));\n    require(tokens.length == amounts.length, MismatchedArrayLengths());\n\n    poolManager.unlock(abi.encode(tokens, amounts));\n  }\n\n  function unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) {\n    (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint256 id = uint256(uint160(tokens[i]));\n      if (amounts[i] == 0) {\n        amounts[i] = poolManager.balanceOf(address(this), id);\n      }\n      if (amounts[i] > 0) {\n        poolManager.burn(address(this), id, amounts[i]);\n        poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n      }\n    }\n\n    emit ClaimEgTokens(egRecipient, tokens, amounts);\n  }\n\n  function getHookPermissions() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      beforeInitialize: false,\n      afterInitialize: false,\n      beforeAddLiquidity: false,\n      afterAddLiquidity: false,\n      beforeRemoveLiquidity: false,\n      afterRemoveLiquidity: false,\n      beforeSwap: true,\n      afterSwap: true,\n      beforeDonate: false,\n      afterDonate: false,\n      beforeSwapReturnDelta: false,\n      afterSwapReturnDelta: true,\n      afterAddLiquidityReturnDelta: false,\n      afterRemoveLiquidityReturnDelta: false\n    });\n  }\n\n  function beforeSwap(\n    address sender,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n    require(params.amountSpecified < 0, ExactOutputDisabled());\n\n    (\n      int256 maxAmountIn,\n      int256 maxExchangeRate,\n      int256 exchangeRateDenom,\n      uint256 nonce,\n      uint256 expiryTime,\n      bytes memory signature\n    ) = HookDataDecoder.decodeAllHookData(hookData);\n\n    require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\n    require(\n      -params.amountSpecified <= maxAmountIn,\n      ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n    );\n\n    _useUnorderedNonce(nonce);\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        sender,\n        key,\n        params.zeroForOne,\n        maxAmountIn,\n        maxExchangeRate,\n        exchangeRateDenom,\n        nonce,\n        expiryTime\n      )\n    );\n    require(\n      SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n    );\n\n    return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function afterSwap(\n    address,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    BalanceDelta delta,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, int128) {\n    (int256 maxExchangeRate, int256 exchangeRateDenom) =\n      HookDataDecoder.decodeExchangeRate(hookData);\n\n    int128 amountIn;\n    int128 amountOut;\n    Currency currencyOut;\n    unchecked {\n      if (params.zeroForOne) {\n        amountIn = -delta.amount0();\n        amountOut = delta.amount1();\n        currencyOut = key.currency1;\n      } else {\n        amountIn = -delta.amount1();\n        amountOut = delta.amount0();\n        currencyOut = key.currency0;\n      }\n    }\n\n    int256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom;\n\n    unchecked {\n      int256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0);\n      if (egAmount > 0) {\n        poolManager.mint(\n          address(this), uint256(uint160(Currency.unwrap(currencyOut))), uint256(egAmount)\n        );\n\n        emit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount);\n      }\n\n      return (this.afterSwap.selector, int128(egAmount));\n    }\n  }\n}",
      "vulnerable_lines": [93, 94, 116, 118, 119, 120, 130, 131],
      "vulnerable_functions": ["beforeSwap"]
    },
    "context_files": [
      {
        "path": "src/base/UnorderedNonce.sol",
        "content": "// Content not shown - contains _useUnorderedNonce implementation",
        "relevance": "The _useUnorderedNonce function marks nonces as used. Once an MEV bot front-runs and consumes the nonce, the original user's transaction reverts with NonceAlreadyUsed error."
      }
    ],
    "call_flow": "Alice.broadcast(swap) -> MEV bot observes mempool -> Bot extracts hookData with signature -> Bot.swap(router, sameHookData) with higher gas -> Router.swap() -> PoolManager.swap() -> Hook.beforeSwap(sender=router) -> signature valid (sender is router for both) -> _useUnorderedNonce(nonce) succeeds -> Bot's swap completes -> Alice's tx executes -> _useUnorderedNonce(nonce) reverts NonceAlreadyUsed",
    "context_hint": "The vulnerability is that 'sender' in the digest (line 120) is the router contract address, not the actual end user who initiated the swap. Since the router is a public contract anyone can call, an MEV bot can replay the same hookData through the same router, and the signature will still be valid. The nonce is then consumed, causing the original user's transaction to fail.",
    "is_vulnerable": true
  }
]
