[
    {
        "id": "gs_sherlock_ammplify_M23",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-23",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "The protocol doesn't support weird tokens like Tether Gold (that return false on every operation)",
        "finding_description": "The protocol uses the TransferHelper.safeTransferFrom(token, _currentTokenRequester, msg.sender, uint256(change)) for its token transfers. But this does not work if the token returns false for all the operations. Tokens like Tether gold will cause the transfer to always revert. Thus such tokens are not supported by the protocol.",
        "attack_scenario": "There is no attack path for this. However, the protocol claims to support tokens that it cannot support, leading to integration failures.",
        "fix_description": "No mitigation provided in the report.",
        "primary_file": {
            "path": "Ammplify/src/integrations/NFTManager.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                570,
                571,
                572,
                573,
                574,
                575,
                576,
                577,
                578,
                579,
                580,
                581,
                582
            ],
            "vulnerable_functions": [
                "transfer",
                "safeTransferFrom"
            ]
        },
        "context_files": [],
        "call_flow": "",
        "context_hint": "Token compatibility issue - tokens that return false instead of reverting are not handled correctly by the TransferHelper library.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M22",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-22",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Utilization Ratio Overflow Due to Incorrect uint64 Cast",
        "finding_description": "The chargeTrueFeeRate() and getLeftRightWeights() functions in walkers/Fee.sol incorrectly assume that calculateRateX64() requires a uint64 input. In reality, the function accepts a uint128. Because of this wrong assumption, utilization ratios are downcast from uint256 to uint64, which can silently overflow. At 100% utilization (totalTLiq == totalMLiq), the expression evaluates to 1 << 64, which cannot fit in uint64 and silently wraps to 0. As a result, instead of passing a correct utilization ratio, the function incorrectly sends 0 to calculateRateX64(), leading to fees being computed as if utilization was 0%.",
        "attack_scenario": "1. A liquidity pool reaches 100% utilization.\n2. Utilization ratio (totalTLiq << 64) / totalMLiq evaluates to 1 << 64. The cast to uint64 wraps this to 0.\n3. calculateRateX64() receives a utilization input of 0 instead of full utilization.\n4. Takers are charged incorrect (much lower) fees, and fee splits are misallocated.\n\nTakers at 100% utilization are undercharged and pay as if utilization was 0%. Protocol Makers lose fees during the highest utilization periods.",
        "fix_description": "Do not cast the utilX64 result into uint64. Compute it in uint256, then safely cast to uint128:\n\nuint256 rawUtilX64 = FullMath.mulDiv(totalTLiq, 1 << 64, totalMLiq);\nuint128 utilX64 = uint128(rawUtilX64);\nuint128 ratePerYearX64 = data.fees.rateConfig.calculateRateX64(utilX64);",
        "primary_file": {
            "path": "Ammplify/src/walkers/Fee.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                347,
                398
            ],
            "vulnerable_functions": [
                "chargeTrueFeeRate",
                "getLeftRightWeights"
            ]
        },
        "context_files": [],
        "call_flow": "Fee calculation -> incorrect uint64 cast -> overflow to 0 -> wrong fee charged",
        "context_hint": "Integer overflow in type casting - when utilization is 100%, the value 1<<64 cannot fit in uint64 and wraps to 0, causing completely wrong fee calculations.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M21",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-21",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "adjustMaker ignores recipient parameter when removing liquidity",
        "finding_description": "The adjustMaker function takes a recipient parameter. The NatSpec says this should define who gets the tokens when removing liquidity. But in the code, the function always sends tokens to msg.sender, even when removing liquidity. This means the recipient parameter is not used at all. The implementation always uses msg.sender for settlement, regardless of whether liquidity is being added or removed.",
        "attack_scenario": "1. Alice opens a maker position.\n2. Alice calls adjustMaker with recipient = Bob.\n3. Liquidity is removed.\n4. Tokens are sent to Alice (msg.sender) instead of Bob.\n5. The system relying on recipient for accounting or further operations now behaves incorrectly.\n\nThis breaks the function's documented behavior and can cause accounting problems or failed integrations.",
        "fix_description": "Update the function so that:\n- When adding liquidity → keep using msg.sender (since they are depositing)\n- When removing liquidity → use recipient (so the tokens go where the caller specified)",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                89
            ],
            "vulnerable_functions": [
                "adjustMaker"
            ]
        },
        "context_files": [],
        "call_flow": "adjustMaker(recipient) -> RFTLib.settle(msg.sender) -> tokens sent to wrong address",
        "context_hint": "Parameter ignored - the recipient parameter is specified but never used, causing funds to always go to msg.sender instead of the intended recipient.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M20",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-20",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Makers can permanently lock JIT penalty revenue from the protocol treasury",
        "finding_description": "Missing accounting and withdrawal for JIT penalties will cause a permanent lockup of protocol revenue for the protocol treasury as makers who withdraw shortly after adding liquidity will incur a penalty that remains as idle ERC20 on the contract with no path to claim or route it. The penalty calculation only scales down the user's redemption amounts and returns the reduced values; it does not emit, credit, or transfer the penalty to any accounting bucket or address. Settlement uses RFTLib.settle, which sends/receives the specified deltas with the counterparty. Since the deltas already include the penalty reduction, nothing explicitly transfers the penalty to a treasury; it simply remains in the diamond contract's balance.",
        "attack_scenario": "1. Maker adds liquidity and withdraws shortly after\n2. JIT penalty is applied, reducing the amounts returned to the maker\n3. The penalty difference stays in the contract as idle token balance\n4. No admin/treasury function exists to sweep or withdraw these balances\n5. Penalty funds are permanently locked in the contract",
        "fix_description": "Route penalties to a configured treasury address at the time of application. Add a configurable treasury address in the FeeStore struct and transfer the penalty amounts to this address when applying JIT penalties.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                117
            ],
            "vulnerable_functions": [
                "adjustMaker",
                "removeMaker"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/Fee.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains the applyJITPenalties function that reduces user balances but doesn't route the penalty to any recipient"
            }
        ],
        "call_flow": "adjustMaker/removeMaker -> FeeLib.applyJITPenalties -> amounts reduced -> RFTLib.settle with reduced amounts -> penalty stays in contract",
        "context_hint": "Penalty funds are calculated and deducted from user withdrawals but never credited to treasury or any beneficiary, causing them to accumulate as idle balances in the contract with no recovery mechanism.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M19",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-19",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "ViewFacet.queryAssetBalances doesn't include uncollected uniswap fees for compounded maker position",
        "finding_description": "When ViewFacet.queryAssetBalances calculates the earnings for compounded maker, it ignores the uncollected uniswap fees. When the actual compounded maker asset is removed, the uncollected uniswap fees are added to node.fees.xCFees and node.fees.yCFees and compounded as additional liquidity. If liquidity is not increased (fees below compound threshold), then these fees are simply added to xCfees/yCFees. Either way, the value of these uniswap uncollected fees is added to maker earnings, which doesn't happen for ViewFacet.",
        "attack_scenario": "Any time someone tries to query assets via ViewFacet, the amount for compounded maker earnings is under-reported. User can fail to account for these fees, breaking any further logic it has and possibly losing the difference as unrecoverable asset. The amount under-reported can often be more than 0.01% depending on the frequency of fees collection.",
        "fix_description": "Include uncollected uniswap fees in the calculation:\n\ndata.earningsX += FullMath.mulDiv(fee0DiffX128 + node.fees.xCFees, aNode.sliq, node.liq.shares);\ndata.earningsY += FullMath.mulDiv(fee1DiffX128 + node.fees.yCFees, aNode.sliq, node.liq.shares);",
        "primary_file": {
            "path": "Ammplify/src/walkers/View.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                335,
                336
            ],
            "vulnerable_functions": [
                "queryAssetBalances"
            ]
        },
        "context_files": [],
        "call_flow": "queryAssetBalances -> compounded maker earnings calculation -> uncollected fees omitted -> incorrect value returned",
        "context_hint": "View function returns incomplete earnings data by excluding uncollected Uniswap fees that would be included when actually withdrawing the position.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M18",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-18",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "Shift-Overflow in getEquivalentLiq Inflates LP Shares",
        "finding_description": "PoolLib.getEquivalentLiq computes the liquidity-equivalent value of token balances using left shifts prior to division. The term (lyX128 << 96) / sqrtPriceX96 can overflow 256 bits before division, silently truncating high bits and shrinking the denominator. This inflates equivLiq, corrupts share/compounding math, and causes unfair value reallocation between LPs. For wide ranges, lyX128 can be on the order of 2^192 (with liq = X128), so (lyX128 << 96) can exceed 2^256 and wrap, reducing liqValueX128. That inflates equivLiq and misprices compounding liquidity and shares.",
        "attack_scenario": "1. Set up a pool and deposit Maker liquidity so a high-level (wide-range) node accumulates compounding fees.\n2. Trigger a Maker modify on that node so Liq.modify calls PoolLib.getEquivalentLiq with a wide range.\n3. For wide ranges, lyX128 becomes large (~2^192). The expression (lyX128 << 96) / sqrtPriceX96 overflows 256 bits before the division and truncates high bits, reducing liqValueX128.\n4. Reduced liqValueX128 inflates equivLiq, which then inflates compoundingLiq and miscomputes shares. The caller receives an outsized share of future fees/principal; other LPs are diluted.",
        "fix_description": "Replace shift-before-division with precise 512-bit math:\n- FullMath.mulDiv(lyX128, 1 << 96, sqrtPriceX96) instead of (lyX128 << 96) / sqrtPriceX96\n- Likewise FullMath.mulDiv(y, 1 << 96, sqrtPriceX96) instead of (y << 96) / sqrtPriceX96",
        "primary_file": {
            "path": "Ammplify/src/Pool.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                257,
                258,
                259
            ],
            "vulnerable_functions": [
                "getEquivalentLiq"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/walkers/Liq.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Calls getEquivalentLiq for compounding calculations, where the inflated value corrupts share math"
            }
        ],
        "call_flow": "Maker modify -> Liq.modify -> PoolLib.getEquivalentLiq -> overflow in shift -> inflated equivLiq -> corrupted compoundingLiq -> wrong shares minted",
        "context_hint": "Arithmetic overflow in bit shift operations before division causes values to wrap around, leading to completely wrong liquidity calculations that favor attackers and dilute honest LPs.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M17",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-17",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Maker.adjustMaker always reverts when trying to reduce maker liquidity while current price is below position range",
        "finding_description": "When Maker.adjustMaker is called, it checks for the calculated amounts of 2 tokens to give to / take from the user to be of the same sign. In the case of x < 0, y == 0 (which corresponds to reducing liquidity when current price is below position range), the transaction incorrectly reverts. User will be unable to reduce position in such situation. If the price stays below the range for extended time, user will not be able to get his funds for extended time.",
        "attack_scenario": "1. User creates a maker position with price range above current price\n2. Current pool price is below the position range (all liquidity is in token X)\n3. User tries to reduce maker liquidity via adjustMaker\n4. Function calculates xBalance < 0, yBalance == 0\n5. Function incorrectly reverts due to require(data.yBalance < 0)\n6. User cannot reduce position and funds are temporarily stuck",
        "fix_description": "Handle case of x < 0, y == 0 correctly by changing the require statement:\n\nrequire(data.yBalance <= 0);",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82
            ],
            "vulnerable_functions": [
                "adjustMaker"
            ]
        },
        "context_files": [],
        "call_flow": "adjustMaker -> calculate balances -> xBalance < 0, yBalance == 0 -> require(yBalance < 0) fails -> revert",
        "context_hint": "Edge case in sign checking logic - when price is below range and liquidity is reduced, only token X is involved (yBalance = 0), but the code incorrectly requires yBalance < 0, causing legitimate operations to revert.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M16",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-16",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "UniV3Decomposer will always revert due to incorrect RFTPayer support and lack of token approvals to MakerFacet",
        "finding_description": "UniV3Decomposer takes Uniswap v3 NFT position and converts it into Ammplify Maker position. While UniV3Decomposer inherits from RFTPayer, it fails to conform to ERC165, because it doesn't have the correct supportsInterface function. It is not enough to just inherit from RFTPayer, because this only sets up interfaces storage in the constructor, but doesn't actually add the supportsInterface function. As a result, when Maker.newMaker is called, it doesn't recognize UniV3Decomposer as correct RFTPayer and falls back to simply transferring tokens from UniV3Decomposer using transferFrom. The issue is that UniV3Decomposer doesn't approve asset tokens to MakerFacet, thus transferFrom will always revert.",
        "attack_scenario": "1. User calls UniV3Decomposer.decompose with their Uniswap V3 NFT\n2. NFT is burned, tokens received by decomposer\n3. Decomposer calls Maker.newMaker\n4. MakerFacet checks if decomposer supports RFTPayer interface\n5. Check fails because supportsInterface is missing\n6. MakerFacet tries transferFrom without approval\n7. Transaction reverts\n\nCore functionality of decomposing Uniswap V3 NFT positions never works, rendering the composer contract useless.",
        "fix_description": "Add supportsInterface function similar to NFTManager:\n\nfunction supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return super.supportsInterface(interfaceId) || Auto165Lib.contains(interfaceId);\n}\n\nAdditionally, update MockERC20 contract with correct approvals usage and checks.",
        "primary_file": {
            "path": "Ammplify/src/integrations/UniV3Decomposer.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                22
            ],
            "vulnerable_functions": [
                "decompose"
            ]
        },
        "context_files": [],
        "call_flow": "decompose -> Maker.newMaker -> ERC165 check fails -> transferFrom without approval -> revert",
        "context_hint": "ERC165 interface support not properly implemented - contract inherits from RFTPayer but doesn't expose the supportsInterface function, causing interface detection to fail and leading to unapproved token transfers.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M15",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-15",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "rounding_error",
        "difficulty_tier": 3,
        "context_level": "single_file",
        "finding_title": "Some legitimate UniV3Decomposer decompose attempts will always revert due to incorrect liquidity offset calculation",
        "finding_description": "UniV3Decomposer takes Uniswap v3 NFT position and converts it into Ammplify Maker position by burning NFT position and minting Maker position with slightly reduced liquidity. The formula used to calculate liquidity offset is: liquidity offset = Q96 * 42 / (sqrtPrice(high) - sqrtPrice(low)). The issue is that this formula derives the liquidity offset only from amount1 calculation of the [a..b] range, ignoring the effect on amount0. In some cases there will be enough of asset1, but not enough of asset0 to mint Ammplify Maker liquidity. Moreover, liquidity offset for each segment minted in Ammplify Maker will be higher than liquidity offset for the [a..b] range, so liquidity offset of the [a..b] range can't be reliably used to estimate max liquidity offset of sub-segments.",
        "attack_scenario": "Example with specific ticks:\n- TickLower = 70020\n- TickUpper = 70080\n- Uniswap V3 NFT: token0 = 1e18, Liquidity = 11064726116504895354478\n- When burned, decomposer receives 999999999999999999 token0 (rounding down)\n- liquidityOffset = 421\n- Maker.newMaker called with liquidity = 11064726116504895354057\n- Required token0 payment = 1000000000000000000 (1 more than received)\n- Transaction reverts due to insufficient funds\n\nThe correct liquidity offset should be 11065, not 421.",
        "fix_description": "Calculate Liquidity offset as:\n- L0 = ceil(ceil(42 * a * b / (b - a)) / Q96)\n- L1 = ceil(42 * Q96 / (b - a))\n- Liquidity Offset = max(L0, L1)\n\nRecommended to choose a = sqrtPrice(upperTick - tickSpacing) to account for worst case segment.",
        "primary_file": {
            "path": "Ammplify/src/integrations/UniV3Decomposer.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71
            ],
            "vulnerable_functions": [
                "decompose"
            ]
        },
        "context_files": [],
        "call_flow": "decompose -> burn NFT -> calculate liquidityOffset (incorrect) -> newMaker -> insufficient token0 -> revert",
        "context_hint": "Rounding error accumulation - the liquidity offset calculation only accounts for one token and doesn't consider that minting across multiple segments (up to 42) amplifies rounding errors differently for each token.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M14",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-14",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "Vaults won't work with tokens that revert on a 0 value approval",
        "finding_description": "The README says current contracts in-scope shouldn't have issues with tokens that revert on a zero value approval. The contract is expected to work with tokens that revert on zero value approvals, but the E4626 vault implementation doesn't handle this case. After depositing assets, the code calls SafeERC20.forceApprove(self.token, address(self.vault), 0) to reset approval. Tokens like BNB revert when approval value is 0, causing the entire transaction to fail.",
        "attack_scenario": "1. User creates or uses an E4626 vault with BNB token\n2. User calls any function that triggers commit() with assetsToDeposit > 0\n3. Tokens are approved and deposited successfully\n4. Code attempts to reset approval to 0: forceApprove(..., 0)\n5. BNB token reverts on 0-value approval\n6. Entire transaction reverts\n7. BNB vaults become completely unusable",
        "fix_description": "No mitigation provided in the report. Team acknowledged but won't fix at this time.",
        "primary_file": {
            "path": "Ammplify/src/Vault/E4626.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                20,
                21,
                22,
                23,
                24
            ],
            "vulnerable_functions": [
                "commit"
            ]
        },
        "context_files": [],
        "call_flow": "Vault.transfer -> commit -> deposit -> forceApprove(0) -> token reverts",
        "context_hint": "Token compatibility issue - certain tokens like BNB revert on zero-value approvals, but the vault always resets approval to 0 after operations, making these tokens incompatible despite protocol claims.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M13",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-13",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "cross_contract",
        "finding_title": "NFTManager burnAsset always triggers JIT penalty on removal",
        "finding_description": "Updating the asset's timestamp inside MakerFacet.collectFees will cause an undue JIT penalty on removal for makers as NFTManager.burnAsset first calls collectFees (which resets timestamp) and then removeMaker. removeMaker computes lifetime from that just-reset timestamp, so the user loses a portion of principal upon burn even if the position has been held longer than jitLifetime. The collectFees() function calls AssetLib.updateTimestamp(asset) which resets asset.timestamp to block.timestamp. Then removeMaker() applies JIT penalty based on asset.timestamp, and the burnAsset() implementation guarantees duration < jitLifetime during removal in the same tx, applying penalty even for long-held positions.",
        "attack_scenario": "1. User holds a long-lived Maker NFT and wants to close via NFTManager.burnAsset().\n2. burnAsset first calls MakerFacet.collectFees(), which updates asset.timestamp to now.\n3. burnAsset then calls MakerFacet.removeMaker(), which checks duration = now - asset.timestamp = 0.\n4. FeeLib.applyJITPenalties applies the penalty to removedX/removedY even though the position was not JIT.\n\nThe user suffers loss equal to the configured JIT penalty fraction on their withdrawn principal.",
        "fix_description": "Don't update the timestamp inside collectFees().",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                117,
                147
            ],
            "vulnerable_functions": [
                "collectFees",
                "removeMaker"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/integrations/NFTManager.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains burnAsset() function that calls collectFees then removeMaker in sequence, creating the timestamp reset issue"
            }
        ],
        "call_flow": "NFTManager.burnAsset() -> MakerFacet.collectFees() -> updateTimestamp() -> MakerFacet.removeMaker() -> applyJITPenalties(with reset timestamp) -> incorrect penalty",
        "context_hint": "Timestamp manipulation through function call ordering - collectFees resets the timestamp before removeMaker checks it, causing the JIT penalty calculation to use duration of 0 instead of the actual position lifetime.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M12",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-12",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "View::queryAssetBalances does not account for JIT penalties",
        "finding_description": "View::queryAssetBalances is used to query how much assets a user would receive if they were to withdraw their funds at the moment. However, the value returned will be wrong as it does not account for potential JIT penalties that the position might incur. When a user removes their maker position it calculates the amount of assets to return and then applies a JIT penalty if needed afterwards. However, when the view function is used it does not properly account for the JIT penalty. This would cause a mismatch between the 2 values of more than 0.01% as long as the JIT penalty is more than 0.01% (which is likely the case).",
        "attack_scenario": "1. User creates a maker position\n2. Frontend queries View::queryAssetBalances in order to show the user how much they would be able to withdraw\n3. User calls removeMaker through the frontend but receives less funds due to the JIT penalty\n\nThis leads to incorrect return values that deviate from the withdrawal value by more than 0.01%, causing issues when executing other functions.",
        "fix_description": "Apply the JIT penalty to the view function for more realistic results.",
        "primary_file": {
            "path": "Ammplify/src/facets/View.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101
            ],
            "vulnerable_functions": [
                "queryAssetBalances"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/facets/Maker.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains removeMaker function that applies JIT penalties, showing the correct flow that View should mirror"
            }
        ],
        "call_flow": "queryAssetBalances -> calculate balances -> return without JIT penalty vs removeMaker -> calculate balances -> apply JIT penalty -> return",
        "context_hint": "View function returns incomplete data - it calculates withdrawal amounts but doesn't apply the same JIT penalty logic that the actual removal function uses, causing frontend displays to show higher amounts than users will actually receive.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M11",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-11",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "Wide cross-zero ranges revert (InvertedRange) due to sign-loss in tick→index and no wrap support",
        "finding_description": "TreeTickLib.tickToTreeIndex casts int→uint24 before adding the offset and never applies % rootWidth. RouteImpl.make reverts whenever _right < _left and does not accept wrapped intervals. For wide cross-zero ranges (e.g., [-k, +k] with k > rootWidth/2 * tickSpacing), left > right occurs and route construction reverts. Normal cross-zero bands succeed; the failure starts exactly at the threshold. The tickToTreeIndex function returns uint24(tick / tickSpacing) + rootWidth / 2 with cast-before-offset and no % rootWidth. The WalkerLib.modify builds the route without splitting wrapped spans.",
        "attack_scenario": "1. User calls a flow that computes route for [-k, +k] (wide cross-zero).\n2. TreeTickLib.tickToTreeIndex maps ticks so that leftIndex > rightIndex-1.\n3. Route construction RouteImpl.make(rootWidth, left, right) sees _right < _left and reverts InvertedRange.\n4. The walker bubbles the revert; the operation cannot proceed.\n\nOperational DoS of legitimate "very wide" cross-zero ranges: attempts to open/modify/close such ranges revert at route construction. This includes near-full-range on Uniswap v3–style pools when tickSpacing=60.",
        "fix_description": "Normalize indices after applying the signed offset (e.g., (q + rootWidth/2) % rootWidth) or accept wrap in RouteImpl.make or split wrapped spans in WalkerLib.modify before calling RouteImpl.make.",
        "primary_file": {
            "path": "Ammplify/src/tree/Tick.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "vulnerable_functions": [
                "tickToTreeIndex"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/tree/Route.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains RouteImpl.make that reverts on inverted ranges without handling wrap-around"
            },
            {
                "path": "Ammplify/src/walkers/Lib.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains WalkerLib.modify that builds routes without splitting wrapped spans"
            }
        ],
        "call_flow": "User operation -> WalkerLib.modify -> TreeTickLib.tickToTreeIndex -> uint24 overflow -> RouteImpl.make -> InvertedRange revert",
        "context_hint": "Sign loss in type conversion combined with modular arithmetic issue - when converting negative ticks to uint24 indices, very wide ranges cause the left index to be numerically greater than the right index, triggering an inverted range error. This is an edge case that blocks legitimate full-range positions.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M10",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-10",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "Incompatible library used for Fee on Transfer tokens",
        "finding_description": "From the competition details, the protocol is expected to work correctly with 'Transfer of less than amount' tokens (fee-on-transfer tokens). However, the protocol adopts the RFT library which is incompatible with tokens that have a fee on transfer. The library has a strict validation check that requires actualDeltas[i] >= balanceChanges[i]. When the library tries to transfer fee-on-transfer tokens, the actual deltas will always be less than balanceChanges therefore the protocol will always revert for any fee on transfer token.",
        "attack_scenario": "1. User holds fee-on-transfer tokens that the protocol explicitly claims to support.\n2. User attempts to create a maker position by calling newMaker() or similar functions\n3. Protocol attempts to transfer tokens through RFTLib.settle()\n4. Fee-on-transfer token deducts transfer fee e.g. 2% of transfer amount\n5. Protocol receives less tokens than expected due to fee deduction\n6. RFTLib validation fails with InsufficientReceive error, reverting the transaction\n7. User cannot create any positions with fee-on-transfer tokens despite protocol's compatibility claims\n\nDenial of service for any token that has a fee on transfer, a capability that should be possible based on the competition details.",
        "fix_description": "Implement proper fee-on-transfer token handling in the settlement system or use a different library. Alternatively, do not allow fee on transfer tokens in the protocol.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                49
            ],
            "vulnerable_functions": [
                "newMaker",
                "RFTLib.settle"
            ]
        },
        "context_files": [],
        "call_flow": "newMaker -> RFTLib.settle -> token transfer with fee -> balance check fails -> InsufficientReceive revert",
        "context_hint": "Token compatibility issue - the RFT library has strict balance validation that doesn't account for transfer fees, causing all fee-on-transfer token operations to revert despite protocol claims of compatibility.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M9",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-9",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Unchecked Underflow in TreeTickLib Causes Transaction Revert in Route Creation",
        "finding_description": "Unchecked arithmetic underflow in TreeTickLib.sol causes a transaction revert for users attempting to modify pool positions, as the system generates an invalid tree index that triggers a failure in the RouteImpl.make function's range validation. In tickToTreeIndex function, the calculation uint24(tick / tickSpacing) + rootWidth / 2 is performed inside an unchecked block. When tick / tickSpacing is sufficiently negative (e.g., less than -rootWidth / 2), the cast uint24(tick / tickSpacing) converts the negative result to a large positive value due to underflow (e.g., -524,289 becomes 16,252,927). Adding rootWidth / 2 to this does not cause another underflow but rather produces an incorrect tree index.",
        "attack_scenario": "1. A user initiates a pool position update by calling WalkerLib.modify with a valid negative lowTick (e.g., -524,289), a valid highTick (e.g., -200,000), tickSpacing = 1, and rootWidth = 524,288.\n2. The modify function calls PoolInfoImpl.treeTick for both ticks, which invokes TreeTickLib.tickToTreeIndex.\n3. For lowTick = -524,289, tickToTreeIndex computes tick / tickSpacing = -524,289. The cast uint24(-524,289) underflows to 2^24 - 524,289 = 16,252,927. Adding rootWidth / 2 yields 16,515,071.\n4. For highTick = -200,000, similar underflow occurs resulting in incorrect index.\n5. The modify function passes these indices to RouteImpl.make where the validation fails and reverts with InvertedRange error.\n\nUsers cannot successfully execute the modify function to update pool positions, effectively disabling the core functionality of the protocol.",
        "fix_description": "No mitigation provided in the report.",
        "primary_file": {
            "path": "Ammplify/src/tree/Tick.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                9
            ],
            "vulnerable_functions": [
                "tickToTreeIndex"
            ]
        },
        "context_files": [],
        "call_flow": "WalkerLib.modify -> PoolInfoImpl.treeTick -> TreeTickLib.tickToTreeIndex -> uint24 cast underflow -> RouteImpl.make -> InvertedRange revert",
        "context_hint": "Unchecked arithmetic in type casting - negative tick values are cast to uint24 before adding offset, causing underflow that produces astronomically large indices that fail downstream range validation.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M8",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-8",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "single_file",
        "finding_title": "Can't remove compounding maker asset if any visit node in route has only liquidity for it",
        "finding_description": "When removing a maker asset, it walks through route and removes liquidity for that maker asset in each relevant node. But because of wrong usage of FullMath.mulDivX256 in LiqWalker.modify function, it can't remove the maker asset if any visit node only has liquidity for that asset. The FullMath.mulDivX256 function requires denominator > num and if this condition isn't met, it reverts. If the processing node only contains the liquidity for this asset, aNode.sliq = node.liq.shares and because of that, it will revert when trying to call FullMath.mulDivX256 for shareRatioX256 calculation.",
        "attack_scenario": "Owner of a compounding maker asset that meets the internal pre-condition tries to remove the asset:\n1. User attempts to remove their compounding maker position\n2. Function walks through route nodes\n3. Reaches a node that only contains liquidity for this specific asset\n4. sliqDiff = aNode.sliq = node.liq.shares\n5. FullMath.mulDivX256(sliqDiff, node.liq.shares, false) is called where numerator equals denominator\n6. Function reverts because it requires denominator > numerator\n\nUsers may be unable to withdraw their compounding maker assets on demand if the asset is in certain liquidity conditions. Withdrawals can only succeed once all relevant nodes contain more liquidity than the removing asset's own liquidity within them. This restriction may temporarily lock user funds for an indeterminate period.",
        "fix_description": "Don't call FullMath.mulDivX256 function when sliqDiff == node.liq.shares. Replace:\n\nuint256 shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);\n\nWith:\n\nuint256 shareRatioX256;\nif (sliqDiff == node.liq.shares) {\n    shareRatioX256 = type(uint256).max;\n} else {\n    shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);\n}",
        "primary_file": {
            "path": "Ammplify/src/walkers/Liq.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                257,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                268,
                269,
                270,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                280,
                281,
                282,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                290,
                291,
                292,
                293,
                294,
                295,
                296
            ],
            "vulnerable_functions": [
                "modify"
            ]
        },
        "context_files": [],
        "call_flow": "removeMaker -> LiqWalker.modify -> node with only this asset's liquidity -> FullMath.mulDivX256(equal values) -> revert",
        "context_hint": "Edge case in division operation - when a node contains only the liquidity being removed, the calculation tries to divide by a value equal to the numerator, which the math library explicitly disallows, causing the entire removal to fail.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M7",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-7",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "X/Y mix-up in ViewWalker.down will underreport X fees and block taker closes",
        "finding_description": "The X/Y assignment bug in ViewWalker.down will cause an underreporting of token0 (X) taker fees for right-subtree positions, as the view walk writes the right-branch X remainder into a Y field, dropping it from propagation. In the X split, the code writes: data.leftChildUnpaidX = leftPaid; data.rightChildUnpaidY = unpaidX - leftPaid; (should be rightChildUnpaidX). This typo nukes the right branch's inherited X taker-fees; later reads use rightChildUnpaidX, which was never written for this branch. This makes queryAssetBalances() deviate by well over 0.01% for affected takers.",
        "attack_scenario": "1. A taker with a right-subtree position accrues X-fees upstream (unpaidTakerXFees > 0).\n2. User/automation queries queryAssetBalances(assetId). Due to the mix-up, fees0 (X) is underreported (potentially by almost the entire right-branch share), exceeding the 0.01% threshold.\n3. User approves token0 equal to the underreported fees0.\n4. User calls removeTaker(...). During RFTLib.settle, the contract tries to pull the true X owed (greater than approved), causing transferFrom to fail and the transaction to revert—blocking the close until the user increases approval.\n\nThe user cannot close taker positions (DoS) unless they over-approve or trial-and-error approvals. Gas is wasted on reverting txs. Deviation in queryAssetBalances() can be >>0.01%.",
        "fix_description": "Apply the one-line fix:\n\n- data.rightChildUnpaidY = unpaidX - leftPaid;\n+ data.rightChildUnpaidX = unpaidX - leftPaid;\n\nAdd symmetry tests asserting that after an X/Y split at a non-leaf:\n- X: leftChildUnpaidX + rightChildUnpaidX == unpaidX\n- Y: leftChildUnpaidY + rightChildUnpaidY == unpaidY",
        "primary_file": {
            "path": "Ammplify/src/walkers/View.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200
            ],
            "vulnerable_functions": [
                "down"
            ]
        },
        "context_files": [],
        "call_flow": "queryAssetBalances -> ViewWalker.down -> X split assigns to rightChildUnpaidY instead of rightChildUnpaidX -> underreported fees -> removeTaker -> insufficient approval -> revert",
        "context_hint": "Variable name typo in fee distribution - when splitting X (token0) fees between left and right child nodes, the right portion is mistakenly assigned to the Y field instead of X, causing fee calculations to be completely wrong for positions in the right subtree.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M6",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-6",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "access_control",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Pending Owner cannot accept ownership because of wrong implementation of transferOwnership and acceptOwnership functions",
        "finding_description": "When admin(owner) tries to transfer ownership, pending owner is unable to accept ownership even after the required delay has elapsed because of wrong implementation of transferOwnership and acceptOwnership functions in TimedAdminFacet which is the base contract of AdminFacet. It calls AdminLib.reassignOwner function in acceptOwnership function called by pending owner instead of calling it in transferOwnership function called by current owner. In reassignOwner function, it validates owner to check if msg.sender is current owner, so it will be reverted with NotOwner error as the caller of acceptOwnership(msg.sender) is pending owner, not the owner.",
        "attack_scenario": "1. Admin tries to transfer ownership to a new owner by calling transferOwnership.\n2. After delay (3 days according to codebase), the new owner tries to accept ownership by calling acceptOwnership.\n3. acceptOwnership calls AdminLib.reassignOwner which validates that msg.sender is the current owner\n4. Since msg.sender is the pending owner (not current owner), the call reverts with NotOwner error\n5. Pending owner cannot accept ownership\n\nThis prevents the ownership handover process from completing as intended, potentially leaving the contract without an effective admin.",
        "fix_description": "Call AdminLib.reassignOwner in transferOwnership function:\n\nfunction transferOwnership(address _newOwner) external virtual override {\n    AdminLib.validateOwner();\n    AdminLib.reassignOwner(_newOwner);  // call it here\n    Timed.memoryPrecommit(OWNER_USE_ID, abi.encode(_newOwner));\n}\n\nfunction acceptOwnership() external virtual override {\n    bytes memory entry = Timed.fetchPrecommit(OWNER_USE_ID, getDelay(true));\n    address _newOwner = abi.decode(entry, (address));\n    if (_newOwner != msg.sender) {\n        revert AdminLib.ImproperOwnershipAcceptance();\n    }\n    AdminLib.acceptOwnership();\n    emit IERC173.OwnershipTransferred(AdminLib.getOwner(), msg.sender);\n}",
        "primary_file": {
            "path": "Commons/src/Util/TimedAdmin.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                23,
                24,
                25,
                26,
                29,
                30,
                31,
                32,
                33,
                34,
                35
            ],
            "vulnerable_functions": [
                "transferOwnership",
                "acceptOwnership"
            ]
        },
        "context_files": [
            {
                "path": "Commons/src/Util/Admin.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains reassignOwner and validateOwner functions that cause the access control issue"
            }
        ],
        "call_flow": "transferOwnership (by owner) -> delay -> acceptOwnership (by pending owner) -> reassignOwner -> validateOwner -> revert NotOwner",
        "context_hint": "Access control logic error - the ownership validation is called in the wrong function, causing the pending owner to fail validation when they try to accept ownership. The reassignOwner call should happen during transfer (validated by current owner), not during acceptance (called by pending owner).",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M5",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-5",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "cross_contract",
        "finding_title": "transferVaultBalance function is unusable and mistransfers user's funds due to hardcoded asset ID",
        "finding_description": "The admin migration tool uses a hardcoded id (80085) when moving balances between vaults, so it targets a single arbitrary account instead of user's real assetIds. Because balances are accounted per position assetId elsewhere, the migration withdraw for id 80085 usually finds no shares and the entire admin call reverts. assetId will eventually collide with the hardcoded value, and when it does, this flaw will escalate to a vector for direct, unintentional theft of user funds. AdminFacet.transferVaultBalance imports TAKER_VAULT_ID and calls VaultLib.transfer(fromVault, toVault, TAKER_VAULT_ID, amount), forcing both withdraw and deposit to run against id 80085. The system's taker and view flows key balances by each position's assetId, so the migration's single-id pathway is incompatible with the storage model.",
        "attack_scenario": "1. Register an active and a backup ERC4626 vault for a token via AdminFacet.addVault so there is a source and destination vault to migrate between.\n2. Call AdminFacet.transferVaultBalance(fromVault, toVault, amount) with any nonzero amount to initiate migration.\n3. The function imports TAKER_VAULT_ID and forwards it to VaultLib.transfer as the userId, so the library executes withdraw(userId=80085, amount) from the source vault and then tries to deposit the same id into the destination.\n4. Because balances are tracked per real position assetId, userId 80085 typically has zero shares, withdraw fails, and the whole transaction reverts.\n5. When assetId eventually collides with the hardcoded value 80085, this function will unintentionally move that specific user's funds.\n\nThe admin's vault migration function is non-functional. As the protocol assigns assetIds sequentially, a user position will inevitably be assigned the hardcoded ID, creating a direct risk of non-consensual fund movement and asset misappropriation.",
        "fix_description": "The AdminFacet.transferVaultBalance function is fundamentally flawed and should be removed entirely. For vault migrations and upgrades, the protocol should exclusively use the existing VaultLib.hotSwap mechanism. The assetId 80085 should be explicitly reserved in the asset creation logic to prevent it from ever being assigned to a user.",
        "primary_file": {
            "path": "Ammplify/src/facets/Admin.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                133
            ],
            "vulnerable_functions": [
                "transferVaultBalance"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/facets/Taker.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains TAKER_VAULT_ID constant definition (80085) that is hardcoded in the transfer function"
            }
        ],
        "call_flow": "AdminFacet.transferVaultBalance -> VaultLib.transfer(userId=80085) -> withdraw from wrong user -> revert or theft",
        "context_hint": "Hardcoded ID mismatch - the admin migration function uses a single hardcoded user ID (80085) instead of iterating through actual user positions, causing it to either fail (no balance for that ID) or steal funds (when a position is eventually assigned that ID).",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M4",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-4",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "state_inconsistency",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "NFTManager will break NFT metadata for users as tokenURI() will revert",
        "finding_description": "The use of AssetLib.getAsset inside NFTManager._generateMetadata/_generateSVG will cause a revert for users requesting NFT metadata, as NFTManager will read diamond storage directly and always see asset.owner == address(0). In NFTManager.sol:_generateMetadata, the call to AssetLib.getAsset(assetId) reads from Store.assets() (diamond storage). Since the call originates from NFTManager, it resolves against the ERC721's own storage instead of the diamond's, making every asset appear unset.",
        "attack_scenario": "1. User calls NFTManager.mintNewMaker → NFT minted successfully, mappings updated.\n2. Any party calls NFTManager.tokenURI(tokenId) → _generateMetadata calls AssetLib.getAsset(assetId).\n3. AssetLib resolves Store.assets() against NFTManager storage, not the diamond.\n4. asset.owner == address(0) → require fails → transaction reverts.\n\nThe users cannot retrieve NFT metadata. As a result, wallets, explorers, and marketplaces cannot display Ammplify NFTs, effectively breaking NFT usability. This makes minted NFTs indistinguishable and practically unusable in external integrations.",
        "fix_description": "Refactor _generateMetadata and _generateSVG to avoid AssetLib. Fetch asset data through the IView facet (getAssetInfo and getPoolInfo) as already done in positions().",
        "primary_file": {
            "path": "Ammplify/src/integrations/NFTManager.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                421,
                422,
                423,
                424,
                425,
                426,
                427,
                428,
                429,
                430,
                431,
                432,
                433,
                434,
                435,
                436,
                437,
                438,
                439,
                440,
                441,
                442,
                443,
                444,
                445,
                446,
                447,
                448,
                449,
                450,
                451,
                452,
                453,
                454,
                455,
                456,
                457,
                458,
                459,
                460,
                461,
                462,
                463,
                464,
                465,
                466,
                467,
                468,
                469
            ],
            "vulnerable_functions": [
                "_generateMetadata",
                "_generateSVG",
                "tokenURI"
            ]
        },
        "context_files": [],
        "call_flow": "tokenURI -> _generateMetadata -> AssetLib.getAsset -> reads NFTManager storage instead of diamond storage -> asset.owner == address(0) -> revert",
        "context_hint": "Storage context confusion - NFTManager (external contract) calls a library function that accesses diamond storage slots, but since the call originates from NFTManager's context, it reads its own empty storage instead of the diamond's populated storage.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M3",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-3",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "dos",
        "difficulty_tier": 2,
        "context_level": "cross_contract",
        "finding_title": "An attacker can block a user from opening new Maker/Taker positions by donating 16 unwanted Maker assets, saturating their asset quota",
        "finding_description": "Because assets created via newMaker(recipient=...) are added directly to the recipient's quota without their consent or opt-in, an attacker can fill a user's MAX_ASSETS_PER_OWNER = 16 slots. This results in a functional denial-of-service: the user is prevented from ever opening any Maker or Taker position until they remove those unwanted assets. This blocks core protocol functionality for an extended period. The system has unfettered use of recipient in newMaker, adding assets to someone else's quota without permission, and a shared global cap for Maker + Taker per owner without opt-in.",
        "attack_scenario": "1. Attacker calls newMaker(recipient=victim, ...) 16 times, filling the asset quota.\n2. Victim attempts to call newMaker(...) or newTaker(...), but call reverts with ExcessiveAssetsPerOwner.\n\nComplete DoS of Maker/Taker creation for target users. If the victim does nothing (or cannot act), the block persists indefinitely. Disrupts time-sensitive core functionality: inability to provide liquidity or collect fees. Easily automatable/spammable by attacker at very low cost.",
        "fix_description": "Require explicit recipient consent/opt-in before adding assets to their account. Restrict newMaker to recipient == msg.sender and implement explicit transfer with acceptance. Separate Maker/Taker quotas. Add a free "clean-up" function for unwanted assets.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                20,
                32,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73
            ],
            "vulnerable_functions": [
                "newMaker"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/Asset.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains MAX_ASSETS_PER_OWNER constant and addAssetToOwner function that enforces the quota without consent checks"
            }
        ],
        "call_flow": "Attacker.newMaker(recipient=victim) x 16 -> Asset.addAssetToOwner -> quota filled -> victim.newMaker/newTaker -> ExcessiveAssetsPerOwner revert",
        "context_hint": "Quota enforcement without consent - the protocol allows anyone to create assets for any recipient, filling their fixed quota of 16 assets without permission, permanently blocking them from creating their own positions.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M2",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-2",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "JIT penalty on fresh fees can be bypassed",
        "finding_description": "Collect path pays without JIT penalty and resets the age. MakerFacet.collectFees computes the owed fees via a full walk, settles them to the user, and then updates the asset timestamp. There is no call to FeeLib.applyJITPenalties on the collected amounts. The penalty itself is binary on time - if duration < jitLifetime, the payout is multiplied by penaltyX64 (a factor < 1). Resetting the timestamp during collectFees means the next removal remains penalized, but crucially, the collected fees avoid any penalty entirely. The NFT wrapper bakes in the bypass - the default burn flow in NFTManager.burnAsset first calls collectFees and only then removeMaker, guaranteeing fees are paid without any JIT penalty even when the position is fresh. Let P = penaltyX64 < 1 and assume the position age is below jitLifetime. Baseline (remove only): user receives P * (principal + fees). Exploit (collect → remove): user receives 1 * (fees) + P * (principal). Because P < 1, the second path always yields extra fees * (1 − P) with no counter-balancing loss on the principal.",
        "attack_scenario": "Preconditions: jitLifetime > 0, penaltyX64 < 1; liquidity just minted (age < jitLifetime); a swap (or taker activity) accrued fees.\n\n1. LP provides liquidity for a short window around an anticipated large swap.\n2. Immediately after, call collectFees → all accrued fees are paid in full and the position timestamp is reset to now.\n3. Call removeMaker to exit principal; penalty applies to principal only (same penalty factor as if removed directly), but fees escaped the penalty entirely.\n\nThis enables classic JIT LPing around expected swaps to siphon fresh fees while the anti-JIT only bites the base liquidity.",
        "fix_description": "Apply the JIT penalty inside collectFees before settlement, then update the timestamp. Also update NFTManager.burnAsset if you want to keep the "collect then remove" ordering once collectFees penalizes, the flow is safe. If you prefer not to penalize collect, don't reset asset.timestamp on collectFees. Only update timestamps on liquidity-changing actions.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155
            ],
            "vulnerable_functions": [
                "collectFees"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/integrations/NFTManager.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains burnAsset function that calls collectFees then removeMaker, baking in the JIT penalty bypass"
            }
        ],
        "call_flow": "collectFees -> no JIT penalty applied -> timestamp reset -> removeMaker -> only principal penalized -> attacker keeps full fees",
        "context_hint": "JIT penalty bypass - the collectFees function doesn't apply penalties to collected fees and resets the timestamp, allowing users to collect fees penalty-free then remove principal with only the principal being penalized, enabling classic JIT attacks.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M1",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-1",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "DoS of pool if uniswapV3MintCallback's tokenAmountOwed is 0 for a Revert on Zero Value Transfers token",
        "finding_description": "The Readme states that 'Revert on Zero Value Transfers' are expected to work with the protocol, however as there is no amount > 0 check when transferring tokens in PoolFacet.sol#uniswapV3MintCallback() so the function will revert if amountOwed == 0 for the 'Revert on Zero Value Transfers' token. This will DoS all Maker functions & the newTaker/removeTaker functions in the affected tick range as the callback needs to succeed for the PoolWalker.sol#settle() function to complete.",
        "attack_scenario": "1. Create a Uniswap pool where 1 of the tokens is a Revert on Zero Value Transfers Token.\n2. Call any function that calls the PoolWalker.sol#settle() function for a tick range where the uniswap mint callback function will return 0.\n3. Revert when TransferHelper.safeTransfer(pInfo.token, activeMint, amountOwed); is called.\n\nDoS of any operations involving the affected tick range. This means users cannot create/modify/remove/collect fees for the given tick range.",
        "fix_description": "Update Pool.sol#uniswapV3MintCallback() to only perform the transfer if amount > 0:\n\nfunction uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata) external {\n    address activeMint = PoolLib.poolGuard();\n    require(msg.sender == activeMint, UnauthorizedMint(activeMint, msg.sender));\n    PoolInfo memory pInfo = PoolLib.getPoolInfo(activeMint);\n    if (amount0Owed > 0) {\n        TransferHelper.safeTransfer(pInfo.token0, activeMint, amount0Owed);\n    }\n    if (amount1Owed > 0) {\n        TransferHelper.safeTransfer(pInfo.token1, activeMint, amount1Owed);\n    }\n}",
        "primary_file": {
            "path": "Ammplify/src/facets/Pool.sol",
            "content": "// Content would need to be fetched from GitHub repo",
            "vulnerable_lines": [
                20,
                21
            ],
            "vulnerable_functions": [
                "uniswapV3MintCallback"
            ]
        },
        "context_files": [],
        "call_flow": "PoolWalker.settle -> PoolLib.mint -> IUniswapV3Pool.mint -> uniswapV3MintCallback(amount=0) -> token.transfer(0) -> revert",
        "context_hint": "Token compatibility issue - tokens that revert on zero-value transfers are not handled in the callback, causing DoS when callback is invoked with 0 amount despite protocol claiming support for these tokens.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_2025-09-ammplify_H6",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "2025-09-ammplify",
        "source_finding_id": "H-6",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "high",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 4,
        "context_level": "cross_contract",
        "finding_title": "User can lose all funds when creating or increasing compounded Maker position due to share inflation first deposit attack in any segment of the user's range",
        "finding_description": "Each segment in the Ammplify protocol functions as a vault for compounded Makers. This enables a first depositor share inflation attack whenever a segment has zero existing liquidity. An attacker can front-run a user’s deposit with a minimal amount of liquidity and then donate assets to the Uniswap pool to inflate the liquidity share price. When the user’s deposit executes, their liquidity rounds down to zero shares, while the deposited assets still increase total liquidity. The attacker can then withdraw all liquidity, stealing the user’s entire deposit.",
        "attack_scenario": "Attacker front-runs a victim depositing into an empty segment, deposits minimal liquidity, inflates share price via Uniswap donation, reduces shares to one, inflates again, then allows victim deposit which mints zero shares. Attacker later withdraws all liquidity, capturing the victim’s funds.",
        "fix_description": "Introduce virtual liquidity balances similar to ERC4626 or enforce minimum liquidity shares alongside minimum liquidity amounts.",
        "primary_file": {
            "path": "Ammplify/src/walkers/Liq.sol",
            "content": "// Full file content must be fetched from GitHub",
            "vulnerable_lines": [
                260,
                261,
                262,
                263
            ],
            "vulnerable_functions": [
                "modify"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/facets/Maker.sol",
                "content": "// Full file content must be fetched from GitHub",
                "relevance": "Minimum liquidity is enforced but minimum liquidity shares are not, enabling share inflation attacks."
            }
        ],
        "call_flow": "Maker.newMaker() -> Liq.modify() -> shares round down -> zero shares minted -> attacker withdraws inflated liquidity",
        "context_hint": "Liquidity share price can be externally inflated through donations, allowing attackers to cause victim deposits to mint zero shares.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_2025-09-ammplify_H5",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "2025-09-ammplify",
        "source_finding_id": "H-5",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "high",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Borrow fee uses APY as per-second rate, causing extreme overcharging",
        "finding_description": "The borrow fee rate returned by the smooth rate curve is an annual percentage yield (APY), but the implementation treats it as a per-second rate by multiplying it directly by elapsed time. This inflates borrow fees by roughly 31,536,000x, causing catastrophic overcharging even over short durations.",
        "attack_scenario": "Borrower opens a taker position and closes it after a short time. The system multiplies APY directly by seconds elapsed, resulting in massive and unjustified fees that can exceed principal.",
        "fix_description": "Convert APY to per-second rate by dividing by seconds per year using precise math such as FullMath.mulDiv.",
        "primary_file": {
            "path": "Ammplify/src/walkers/Fee.sol",
            "content": "// Full file content must be fetched from GitHub",
            "vulnerable_lines": [
                398
            ],
            "vulnerable_functions": [
                "chargeTrueFeeRate"
            ]
        },
        "context_files": [],
        "call_flow": "removeTaker -> chargeTrueFeeRate -> APY misused as per-second -> massive fee charged",
        "context_hint": "Annualized rate is incorrectly applied as a per-second rate.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_2025-09-ammplify_H4",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "2025-09-ammplify",
        "source_finding_id": "H-4",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "high",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "Uncollected fees from user's NFT position are stuck in NFTManager",
        "finding_description": "When NFTManager.decomposeAndMint is used, uncollected Uniswap V3 fees are transferred to the NFTManager contract instead of the user. NFTManager never forwards these funds, causing them to be permanently stuck.",
        "attack_scenario": "User decomposes Uniswap V3 NFT. Fees are collected and sent to NFTManager, but no mechanism exists to forward them back to the user, resulting in permanent loss.",
        "fix_description": "Ensure uncollected fees are transferred to the user after decomposition.",
        "primary_file": {
            "path": "Ammplify/src/integrations/NFTManager.sol",
            "content": "// Full file content must be fetched from GitHub",
            "vulnerable_lines": [],
            "vulnerable_functions": [
                "decomposeAndMint"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/integrations/UniV3Decomposer.sol",
                "content": "// Full file content must be fetched from GitHub",
                "relevance": "Collects Uniswap fees and transfers them to NFTManager instead of the user."
            }
        ],
        "call_flow": "NFTManager.decomposeAndMint -> UniV3Decomposer.decompose -> fees transferred to NFTManager -> funds stuck",
        "context_hint": "Funds are routed to an intermediate contract without a withdrawal path.",
        "is_vulnerable": true
    }
]