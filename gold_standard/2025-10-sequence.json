[
    {
        "id": "gs_c4_2025-10-sequence_H01",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-sequence",
        "source_finding_id": "H-01",
        "report_url": "https://code4rena.com/reports/2025-10-sequence",
        "github_repo_url": "https://github.com/code-423n4/2025-10-sequence",
        "contest_date": "2025-10-07",
        "severity": "high",
        "vulnerability_type": "access_control",
        "difficulty_tier": 3,
        "context_level": "multi_file",
        "finding_title": "Chained signature with checkpoint usage disabled can bypass all checkpointer validation",
        "finding_description": "When a wallet is behind a checkpointer and a chained signature is used with bit 6 (checkpointer usage flag) set to zero, BaseSig.recover skips the checkpointer validation block (BaseSig.sol:88-106). This leaves _checkpointer and snapshot unset (zero-valued). In recoverChained, the checkpointer is ignored, and the signature validation passes even if the checkpointer should be enforced. The final validation succeeds because snapshot.imageHash == bytes32(0) as the checkpointer is ignored.",
        "attack_scenario": "An evicted signer can sign a payload valid under stale wallet configuration and bypass checkpointer validation. PoC: Add test case to BaseSigTest and run forge test --match-test test_PoC_checkpointer_bypass. The test constructs a chained signature with checkpointer disabled, mocks the checkpointer response, and asserts successful recovery with correct image hash.",
        "fix_description": "Do not permit checkpointer to be disabled (bit 6 unset) if chained signature is used. Revert in this case with custom error. Example fix in BaseSig.sol:\nif (signatureFlag & 0x40 == 0) {\n    revert MissingCheckpointer();\n}",
        "primary_file": {
            "path": "src/modules/auth/BaseSig.sol",
            "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\r\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\r\nimport { Payload } from \"../Payload.sol\";\r\n\r\nimport { ICheckpointer, Snapshot } from \"../interfaces/ICheckpointer.sol\";\r\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\r\nimport { ISapient, ISapientCompact } from \"../interfaces/ISapient.sol\";\r\n\r\nusing LibBytes for bytes;\r\nusing Payload for Payload.Decoded;\r\n\r\n/// @title BaseSig\r\n/// @author Agustin Aguilar, Michael Standen, William Hua, Shun Kakinoki\r\n/// @notice Library for recovering signatures from the base-auth payload\r\nlibrary BaseSig {\r\n\r\n  uint256 internal constant FLAG_SIGNATURE_HASH = 0;\r\n  uint256 internal constant FLAG_ADDRESS = 1;\r\n  uint256 internal constant FLAG_SIGNATURE_ERC1271 = 2;\r\n  uint256 internal constant FLAG_NODE = 3;\r\n  uint256 internal constant FLAG_BRANCH = 4;\r\n  uint256 internal constant FLAG_SUBDIGEST = 5;\r\n  uint256 internal constant FLAG_NESTED = 6;\r\n  uint256 internal constant FLAG_SIGNATURE_ETH_SIGN = 7;\r\n  uint256 internal constant FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST = 8;\r\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT = 9;\r\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT_COMPACT = 10;\r\n\r\n  /// @notice Error thrown when the weight is too low for a chained signature\r\n  error LowWeightChainedSignature(bytes _signature, uint256 _threshold, uint256 _weight);\r\n  /// @notice Error thrown when the ERC1271 signature is invalid\r\n  error InvalidERC1271Signature(bytes32 _opHash, address _signer, bytes _signature);\r\n  /// @notice Error thrown when the checkpoint order is wrong\r\n  error WrongChainedCheckpointOrder(uint256 _nextCheckpoint, uint256 _checkpoint);\r\n  /// @notice Error thrown when the snapshot is unused\r\n  error UnusedSnapshot(Snapshot _snapshot);\r\n  /// @notice Error thrown when the signature flag is invalid\r\n  error InvalidSignatureFlag(uint256 _flag);\r\n\r\n  function _leafForAddressAndWeight(address _addr, uint256 _weight) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"Sequence signer:\\n\", _addr, _weight));\r\n  }\r\n\r\n  function _leafForNested(bytes32 _node, uint256 _threshold, uint256 _weight) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"Sequence nested config:\\n\", _node, _threshold, _weight));\r\n  }\r\n\r\n  function _leafForSapient(address _addr, uint256 _weight, bytes32 _imageHash) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"Sequence sapient config:\\n\", _addr, _weight, _imageHash));\r\n  }\r\n\r\n  function _leafForHardcodedSubdigest(\r\n    bytes32 _subdigest\r\n  ) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"Sequence static digest:\\n\", _subdigest));\r\n  }\r\n\r\n  function _leafForAnyAddressSubdigest(\r\n    bytes32 _anyAddressSubdigest\r\n  ) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"Sequence any address subdigest:\\n\", _anyAddressSubdigest));\r\n  }\r\n\r\n  function recover(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature,\r\n    bool _ignoreCheckpointer,\r\n    address _checkpointer\r\n  ) internal view returns (uint256 threshold, uint256 weight, bytes32 imageHash, uint256 checkpoint, bytes32 opHash) {\r\n    // First byte is the signature flag\r\n    (uint256 signatureFlag, uint256 rindex) = _signature.readFirstUint8();\r\n\r\n    // The possible flags are:\r\n    // - 0000 00XX (bits [1..0]): signature type (00 = normal, 01/11 = chained, 10 = no chain id)\r\n    // - 000X XX00 (bits [4..2]): checkpoint size (00 = 0 bytes, 001 = 1 byte, 010 = 2 bytes...)\r\n    // - 00X0 0000 (bit [5]): threshold size (0 = 1 byte, 1 = 2 bytes)\r\n    // - 0X00 0000 (bit [6]): set if imageHash checkpointer is used\r\n    // - X000 0000 (bit [7]): reserved by base-auth\r\n\r\n    Snapshot memory snapshot;\r\n\r\n    // Recover the imageHash checkpointer if any\r\n    // but checkpointer passed as argument takes precedence\r\n    // since it can be defined by the chained signatures\r\n    if (signatureFlag & 0x40 == 0x40 && _checkpointer == address(0)) {\r\n      // Override the checkpointer\r\n      // not ideal, but we don't have much room in the stack\r\n      (_checkpointer, rindex) = _signature.readAddress(rindex);\r\n\r\n      if (!_ignoreCheckpointer) {\r\n        // Next 3 bytes determine the checkpointer data size\r\n        uint256 checkpointerDataSize;\r\n        (checkpointerDataSize, rindex) = _signature.readUint24(rindex);\r\n\r\n        // Read the checkpointer data\r\n        bytes memory checkpointerData = _signature[rindex:rindex + checkpointerDataSize];\r\n\r\n        // Call the middleware\r\n        snapshot = ICheckpointer(_checkpointer).snapshotFor(address(this), checkpointerData);\r\n\r\n        rindex += checkpointerDataSize;\r\n      }\r\n    }\r\n\r\n    // If signature type is 01 or 11 we do a chained signature\r\n    if (signatureFlag & 0x01 == 0x01) {\r\n      return recoverChained(_payload, _checkpointer, snapshot, _signature[rindex:]);\r\n    }\r\n\r\n    // If the signature type is 10 we do a no chain id signature\r\n    _payload.noChainId = signatureFlag & 0x02 == 0x02;\r\n\r\n    {\r\n      // Recover the checkpoint using the size defined by the flag\r\n      uint256 checkpointSize = (signatureFlag & 0x1c) >> 2;\r\n      (checkpoint, rindex) = _signature.readUintX(rindex, checkpointSize);\r\n    }\r\n\r\n    // Recover the threshold, using the flag for the size\r\n    {\r\n      uint256 thresholdSize = ((signatureFlag & 0x20) >> 5) + 1;\r\n      (threshold, rindex) = _signature.readUintX(rindex, thresholdSize);\r\n    }\r\n\r\n    // Recover the tree\r\n    opHash = _payload.hash();\r\n    (weight, imageHash) = recoverBranch(_payload, opHash, _signature[rindex:]);\r\n\r\n    imageHash = LibOptim.fkeccak256(imageHash, bytes32(threshold));\r\n    imageHash = LibOptim.fkeccak256(imageHash, bytes32(checkpoint));\r\n    imageHash = LibOptim.fkeccak256(imageHash, bytes32(uint256(uint160(_checkpointer))));\r\n\r\n    // If the snapshot is used, either the imageHash must match\r\n    // or the checkpoint must be greater than the snapshot checkpoint\r\n    if (snapshot.imageHash != bytes32(0) && snapshot.imageHash != imageHash && checkpoint <= snapshot.checkpoint) {\r\n      revert UnusedSnapshot(snapshot);\r\n    }\r\n  }\r\n\r\n  function recoverChained(\r\n    Payload.Decoded memory _payload,\r\n    address _checkpointer,\r\n    Snapshot memory _snapshot,\r\n    bytes calldata _signature\r\n  ) internal view returns (uint256 threshold, uint256 weight, bytes32 imageHash, uint256 checkpoint, bytes32 opHash) {\r\n    Payload.Decoded memory linkedPayload;\r\n    linkedPayload.kind = Payload.KIND_CONFIG_UPDATE;\r\n\r\n    uint256 rindex;\r\n    uint256 prevCheckpoint = type(uint256).max;\r\n\r\n    while (rindex < _signature.length) {\r\n      uint256 nrindex;\r\n\r\n      {\r\n        uint256 sigSize;\r\n        (sigSize, rindex) = _signature.readUint24(rindex);\r\n        nrindex = sigSize + rindex;\r\n      }\r\n\r\n      address checkpointer = nrindex == _signature.length ? _checkpointer : address(0);\r\n\r\n      if (prevCheckpoint == type(uint256).max) {\r\n        (threshold, weight, imageHash, checkpoint, opHash) =\r\n          recover(_payload, _signature[rindex:nrindex], true, checkpointer);\r\n      } else {\r\n        (threshold, weight, imageHash, checkpoint,) =\r\n          recover(linkedPayload, _signature[rindex:nrindex], true, checkpointer);\r\n      }\r\n\r\n      if (weight < threshold) {\r\n        revert LowWeightChainedSignature(_signature[rindex:nrindex], threshold, weight);\r\n      }\r\n      rindex = nrindex;\r\n\r\n      if (_snapshot.imageHash == imageHash) {\r\n        _snapshot.imageHash = bytes32(0);\r\n      }\r\n\r\n      if (checkpoint >= prevCheckpoint) {\r\n        revert WrongChainedCheckpointOrder(checkpoint, prevCheckpoint);\r\n      }\r\n\r\n      linkedPayload.imageHash = imageHash;\r\n      prevCheckpoint = checkpoint;\r\n    }\r\n\r\n    if (_snapshot.imageHash != bytes32(0) && checkpoint <= _snapshot.checkpoint) {\r\n      revert UnusedSnapshot(_snapshot);\r\n    }\r\n  }\r\n\r\n  function recoverBranch(\r\n    Payload.Decoded memory _payload,\r\n    bytes32 _opHash,\r\n    bytes calldata _signature\r\n  ) internal view returns (uint256 weight, bytes32 root) {\r\n    unchecked {\r\n      uint256 rindex;\r\n\r\n      // Iterate until the image is completed\r\n      while (rindex < _signature.length) {\r\n        // The first byte is half flag (the top nibble)\r\n        // and the second set of 4 bits can freely be used by the part\r\n\r\n        // Read next item type\r\n        uint256 firstByte;\r\n        (firstByte, rindex) = _signature.readUint8(rindex);\r\n\r\n        // The top 4 bits are the flag\r\n        uint256 flag = (firstByte & 0xf0) >> 4;\r\n\r\n        // Signature hash (0x00)\r\n        if (flag == FLAG_SIGNATURE_HASH) {\r\n          // Free bits layout:\r\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\r\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\r\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\r\n\r\n          uint8 addrWeight = uint8(firstByte & 0x0f);\r\n          if (addrWeight == 0) {\r\n            (addrWeight, rindex) = _signature.readUint8(rindex);\r\n          }\r\n\r\n          bytes32 r;\r\n          bytes32 s;\r\n          uint8 v;\r\n          (r, s, v, rindex) = _signature.readRSVCompact(rindex);\r\n\r\n          address addr = ecrecover(_opHash, v, r, s);\r\n\r\n          weight += addrWeight;\r\n          bytes32 node = _leafForAddressAndWeight(addr, addrWeight);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Address (0x01) (without signature)\r\n        if (flag == FLAG_ADDRESS) {\r\n          // Free bits layout:\r\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, 0010 = 2, ...)\r\n\r\n          // Read weight\r\n          uint8 addrWeight = uint8(firstByte & 0x0f);\r\n          if (addrWeight == 0) {\r\n            (addrWeight, rindex) = _signature.readUint8(rindex);\r\n          }\r\n\r\n          // Read address\r\n          address addr;\r\n          (addr, rindex) = _signature.readAddress(rindex);\r\n\r\n          // Compute the merkle root WITHOUT adding the weight\r\n          bytes32 node = _leafForAddressAndWeight(addr, addrWeight);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Signature ERC1271 (0x02)\r\n        if (flag == FLAG_SIGNATURE_ERC1271) {\r\n          // Free bits layout:\r\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\r\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\r\n\r\n          // Read weight\r\n          uint8 addrWeight = uint8(firstByte & 0x03);\r\n          if (addrWeight == 0) {\r\n            (addrWeight, rindex) = _signature.readUint8(rindex);\r\n          }\r\n\r\n          // Read signer\r\n          address addr;\r\n          (addr, rindex) = _signature.readAddress(rindex);\r\n\r\n          // Read signature size\r\n          uint256 sizeSize = uint8(firstByte & 0x0c) >> 2;\r\n          uint256 size;\r\n          (size, rindex) = _signature.readUintX(rindex, sizeSize);\r\n\r\n          // Read dynamic size signature\r\n          uint256 nrindex = rindex + size;\r\n\r\n          // Call the ERC1271 contract to check if the signature is valid\r\n          if (IERC1271(addr).isValidSignature(_opHash, _signature[rindex:nrindex]) != IERC1271_MAGIC_VALUE_HASH) {\r\n            revert InvalidERC1271Signature(_opHash, addr, _signature[rindex:nrindex]);\r\n          }\r\n          rindex = nrindex;\r\n          // Add the weight and compute the merkle root\r\n          weight += addrWeight;\r\n          bytes32 node = _leafForAddressAndWeight(addr, addrWeight);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Node (0x03)\r\n        if (flag == FLAG_NODE) {\r\n          // Free bits left unused\r\n\r\n          // Read node hash\r\n          bytes32 node;\r\n          (node, rindex) = _signature.readBytes32(rindex);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Branch (0x04)\r\n        if (flag == FLAG_BRANCH) {\r\n          // Free bits layout:\r\n          // - XXXX : Size size (0000 = 0 byte, 0001 = 1 byte, 0010 = 2 bytes, ...)\r\n\r\n          // Read size\r\n          uint256 sizeSize = uint8(firstByte & 0x0f);\r\n          uint256 size;\r\n          (size, rindex) = _signature.readUintX(rindex, sizeSize);\r\n\r\n          // Enter a branch of the signature merkle tree\r\n          uint256 nrindex = rindex + size;\r\n\r\n          (uint256 nweight, bytes32 node) = recoverBranch(_payload, _opHash, _signature[rindex:nrindex]);\r\n          rindex = nrindex;\r\n\r\n          weight += nweight;\r\n          root = LibOptim.fkeccak256(root, node);\r\n          continue;\r\n        }\r\n\r\n        // Nested (0x06)\r\n        if (flag == FLAG_NESTED) {\r\n          // Unused free bits:\r\n          // - XX00 : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\r\n          // - 00XX : Threshold (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\r\n\r\n          // Enter a branch of the signature merkle tree\r\n          // but with an internal threshold and an external fixed weight\r\n          uint256 externalWeight = uint8(firstByte & 0x0c) >> 2;\r\n          if (externalWeight == 0) {\r\n            (externalWeight, rindex) = _signature.readUint8(rindex);\r\n          }\r\n\r\n          uint256 internalThreshold = uint8(firstByte & 0x03);\r\n          if (internalThreshold == 0) {\r\n            (internalThreshold, rindex) = _signature.readUint16(rindex);\r\n          }\r\n\r\n          uint256 size;\r\n          (size, rindex) = _signature.readUint24(rindex);\r\n          uint256 nrindex = rindex + size;\r\n\r\n          (uint256 internalWeight, bytes32 internalRoot) = recoverBranch(_payload, _opHash, _signature[rindex:nrindex]);\r\n          rindex = nrindex;\r\n\r\n          if (internalWeight >= internalThreshold) {\r\n            weight += externalWeight;\r\n          }\r\n\r\n          bytes32 node = _leafForNested(internalRoot, internalThreshold, externalWeight);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Subdigest (0x05)\r\n        if (flag == FLAG_SUBDIGEST) {\r\n          // Free bits left unused\r\n\r\n          // A hardcoded always accepted digest\r\n          // it pushes the weight to the maximum\r\n          bytes32 hardcoded;\r\n          (hardcoded, rindex) = _signature.readBytes32(rindex);\r\n          if (hardcoded == _opHash) {\r\n            weight = type(uint256).max;\r\n          }\r\n\r\n          bytes32 node = _leafForHardcodedSubdigest(hardcoded);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Signature ETH Sign (0x07)\r\n        if (flag == FLAG_SIGNATURE_ETH_SIGN) {\r\n          // Free bits layout:\r\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\r\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\r\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\r\n\r\n          uint8 addrWeight = uint8(firstByte & 0x0f);\r\n          if (addrWeight == 0) {\r\n            (addrWeight, rindex) = _signature.readUint8(rindex);\r\n          }\r\n\r\n          bytes32 r;\r\n          bytes32 s;\r\n          uint8 v;\r\n          (r, s, v, rindex) = _signature.readRSVCompact(rindex);\r\n\r\n          address addr = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _opHash)), v, r, s);\r\n\r\n          weight += addrWeight;\r\n          bytes32 node = _leafForAddressAndWeight(addr, addrWeight);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Signature Any address subdigest (0x08)\r\n        // similar to subdigest, but allows for counter-factual payloads\r\n        if (flag == FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST) {\r\n          // Free bits left unused\r\n\r\n          // A hardcoded always accepted digest\r\n          // it pushes the weight to the maximum\r\n          bytes32 hardcoded;\r\n          (hardcoded, rindex) = _signature.readBytes32(rindex);\r\n          bytes32 anyAddressOpHash = _payload.hashFor(address(0));\r\n          if (hardcoded == anyAddressOpHash) {\r\n            weight = type(uint256).max;\r\n          }\r\n\r\n          bytes32 node = _leafForAnyAddressSubdigest(hardcoded);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Signature Sapient (0x09)\r\n        if (flag == FLAG_SIGNATURE_SAPIENT) {\r\n          // Free bits layout:\r\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\r\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\r\n\r\n          // Read signer and weight\r\n          uint8 addrWeight = uint8(firstByte & 0x03);\r\n          if (addrWeight == 0) {\r\n            (addrWeight, rindex) = _signature.readUint8(rindex);\r\n          }\r\n\r\n          address addr;\r\n          (addr, rindex) = _signature.readAddress(rindex);\r\n\r\n          // Read signature size\r\n          uint256 size;\r\n          {\r\n            uint256 sizeSize = uint8(firstByte & 0x0c) >> 2;\r\n            (size, rindex) = _signature.readUintX(rindex, sizeSize);\r\n          }\r\n\r\n          // Read dynamic size signature\r\n          uint256 nrindex = rindex + size;\r\n\r\n          // Call the ERC1271 contract to check if the signature is valid\r\n          bytes32 sapientImageHash = ISapient(addr).recoverSapientSignature(_payload, _signature[rindex:nrindex]);\r\n          rindex = nrindex;\r\n\r\n          // Add the weight and compute the merkle root\r\n          weight += addrWeight;\r\n          bytes32 node = _leafForSapient(addr, addrWeight, sapientImageHash);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        // Signature Sapient Compact (0x0A)\r\n        if (flag == FLAG_SIGNATURE_SAPIENT_COMPACT) {\r\n          // Free bits layout:\r\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\r\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\r\n\r\n          // Read signer and weight\r\n          uint8 addrWeight = uint8(firstByte & 0x03);\r\n          if (addrWeight == 0) {\r\n            (addrWeight, rindex) = _signature.readUint8(rindex);\r\n          }\r\n\r\n          address addr;\r\n          (addr, rindex) = _signature.readAddress(rindex);\r\n\r\n          // Read signature size\r\n          uint256 sizeSize = uint8(firstByte & 0x0c) >> 2;\r\n          uint256 size;\r\n          (size, rindex) = _signature.readUintX(rindex, sizeSize);\r\n\r\n          // Read dynamic size signature\r\n          uint256 nrindex = rindex + size;\r\n\r\n          // Call the Sapient contract to check if the signature is valid\r\n          bytes32 sapientImageHash =\r\n            ISapientCompact(addr).recoverSapientSignatureCompact(_opHash, _signature[rindex:nrindex]);\r\n          rindex = nrindex;\r\n          // Add the weight and compute the merkle root\r\n          weight += addrWeight;\r\n          bytes32 node = _leafForSapient(addr, addrWeight, sapientImageHash);\r\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\r\n          continue;\r\n        }\r\n\r\n        revert InvalidSignatureFlag(flag);\r\n      }\r\n    }\r\n  }\r\n\r\n}",
            "vulnerable_lines": [
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                138,
                139,
                140,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193
            ],
            "vulnerable_functions": [
                "recover",
                "recoverChained"
            ]
        },
        "context_files": [],
        "call_flow": "User.submit(chained sig with checkpointer flag off) -> BaseSig.recover() skips checkpointer -> recoverChained() ignores checkpointer -> validation passes with stale config",
        "context_hint": "Chained signatures can disable checkpointer enforcement via flag, allowing bypass of intended validation and use of evicted/stale signers.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-sequence_H02",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_finding_id": "H-02",
        "report_url": "https://code4rena.com/reports/2025-10-sequence",
        "github_repo_url": "https://github.com/code-423n4/2025-10-sequence",
        "contest_date": "2025-10-07",
        "severity": "high",
        "vulnerability_type": "signature_replay",
        "difficulty_tier": 3,
        "context_level": "multi_file",
        "finding_title": "Partial signature replay/frontrunning attack on session calls",
        "finding_description": "When a session call with BEHAVIOR_REVERT_ON_ERROR fails, the transaction reverts but nonce is not consumed. The signature remains valid and can be replayed for partial calls. Session signatures are validated per-call using individual call hashes, enabling partial replay. Frontrunners can execute subsets of calls to grief or cause financial loss.",
        "attack_scenario": "Original payload: Calls [A, B, C] with signatures [SigA, SigB, SigC]. Execution: [A succeed, B succeed, C revert]. Result: Revert, nonce unused. Attack: Replay [A, B] with [SigA, SigB]. PoC: File POC.t.sol with test testSubmissionValidity. It builds a 2-call payload, expects revert on second call, then replays partial payload successfully.",
        "fix_description": "Bind session call signatures to the complete payload hash to prevent partial signature replay.",
        "primary_file": {
            "path": "src/modules/Calls.sol",
            "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { LibOptim } from \"../utils/LibOptim.sol\";\r\nimport { Nonce } from \"./Nonce.sol\";\r\nimport { Payload } from \"./Payload.sol\";\r\n\r\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\r\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\r\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\r\n\r\n/// @title Calls\r\n/// @author Agustin Aguilar, Michael Standen, William Hua\r\n/// @notice Contract for executing calls\r\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\r\n\r\n  /// @notice Emitted when a call succeeds\r\n  event CallSucceeded(bytes32 _opHash, uint256 _index);\r\n  /// @notice Emitted when a call fails\r\n  event CallFailed(bytes32 _opHash, uint256 _index, bytes _returnData);\r\n  /// @notice Emitted when a call is aborted\r\n  event CallAborted(bytes32 _opHash, uint256 _index, bytes _returnData);\r\n  /// @notice Emitted when a call is skipped\r\n  event CallSkipped(bytes32 _opHash, uint256 _index);\r\n\r\n  /// @notice Error thrown when a call reverts\r\n  error Reverted(Payload.Decoded _payload, uint256 _index, bytes _returnData);\r\n  /// @notice Error thrown when a signature is invalid\r\n  error InvalidSignature(Payload.Decoded _payload, bytes _signature);\r\n  /// @notice Error thrown when there is not enough gas\r\n  error NotEnoughGas(Payload.Decoded _payload, uint256 _index, uint256 _gasLeft);\r\n\r\n  /// @notice Execute a call\r\n  /// @param _payload The payload\r\n  /// @param _signature The signature\r\n  function execute(bytes calldata _payload, bytes calldata _signature) external payable virtual nonReentrant {\r\n    uint256 startingGas = gasleft();\r\n    Payload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\r\n\r\n    _consumeNonce(decoded.space, decoded.nonce);\r\n    (bool isValid, bytes32 opHash) = signatureValidation(decoded, _signature);\r\n\r\n    if (!isValid) {\r\n      revert InvalidSignature(decoded, _signature);\r\n    }\r\n\r\n    _execute(startingGas, opHash, decoded);\r\n  }\r\n\r\n  /// @notice Execute a call\r\n  /// @dev Callable only by the contract itself\r\n  /// @param _payload The payload\r\n  function selfExecute(\r\n    bytes calldata _payload\r\n  ) external payable virtual onlySelf {\r\n    uint256 startingGas = gasleft();\r\n    Payload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\r\n    bytes32 opHash = Payload.hash(decoded);\r\n    _execute(startingGas, opHash, decoded);\r\n  }\r\n\r\n  function _execute(uint256 _startingGas, bytes32 _opHash, Payload.Decoded memory _decoded) private {\r\n    bool errorFlag = false;\r\n\r\n    uint256 numCalls = _decoded.calls.length;\r\n    for (uint256 i = 0; i < numCalls; i++) {\r\n      Payload.Call memory call = _decoded.calls[i];\r\n\r\n      // Skip onlyFallback calls if no error occurred\r\n      if (call.onlyFallback && !errorFlag) {\r\n        emit CallSkipped(_opHash, i);\r\n        continue;\r\n      }\r\n\r\n      // Reset the error flag\r\n      // onlyFallback calls only apply when the immediately preceding transaction fails\r\n      errorFlag = false;\r\n\r\n      uint256 gasLimit = call.gasLimit;\r\n      if (gasLimit != 0 && gasleft() < gasLimit) {\r\n        revert NotEnoughGas(_decoded, i, gasleft());\r\n      }\r\n\r\n      bool success;\r\n      if (call.delegateCall) {\r\n        (success) = LibOptim.delegatecall(\r\n          call.to,\r\n          gasLimit == 0 ? gasleft() : gasLimit,\r\n          abi.encodeWithSelector(\r\n            IDelegatedExtension.handleSequenceDelegateCall.selector,\r\n            _opHash,\r\n            _startingGas,\r\n            i,\r\n            numCalls,\r\n            _decoded.space,\r\n            call.data\r\n          )\r\n        );\r\n      } else {\r\n        (success) = LibOptim.call(call.to, call.value, gasLimit == 0 ? gasleft() : gasLimit, call.data);\r\n      }\r\n\r\n      if (!success) {\r\n        if (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\r\n          errorFlag = true;\r\n          emit CallFailed(_opHash, i, LibOptim.returnData());\r\n          continue;\r\n        }\r\n\r\n        if (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\r\n          revert Reverted(_decoded, i, LibOptim.returnData());\r\n        }\r\n\r\n        if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\r\n          emit CallAborted(_opHash, i, LibOptim.returnData());\r\n          break;\r\n        }\r\n      }\r\n\r\n      emit CallSucceeded(_opHash, i);\r\n    }\r\n  }\r\n\r\n}",
            "vulnerable_lines": [
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123
            ],
            "vulnerable_functions": [
                "executeSessionCalls"
            ]
        },
        "context_files": [
            {
                "path": "src/extensions/sessions/SessionSig.sol",
                "content": "// Full content not retrievable; relevance: L136-L176 (per-call signature hashing)",
                "relevance": "SessionSig hashes individual calls rather than full payload, enabling partial replay."
            }
        ],
        "call_flow": "User.submit(session calls [A,B,C]) -> C fails -> revert (nonce preserved) -> Attacker/Frontrunner.submit([A,B]) -> succeeds with partial sigs",
        "context_hint": "Session signatures are per-call, and failed batches preserve nonce, allowing replay of successful subsets for griefing or frontrunning.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-sequence_M01",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_report": "2025-10-sequence",
        "source_finding_id": "M-01",
        "report_url": "https://code4rena.com/reports/2025-10-sequence",
        "github_repo_url": "https://github.com/code-423n4/2025-10-sequence",
        "contest_date": "2025-10-07",
        "severity": "medium",
        "vulnerability_type": "signature_replay",
        "difficulty_tier": 3,
        "context_level": "multi_file",
        "finding_title": "Session signatures replay across wallets due to missing wallet binding",
        "finding_description": "SessionSig.hashCallWithReplayProtection omits wallet address in hash, allowing signatures for one wallet to replay on another with same config and nonce. SessionManager.recoverSapientSignature and BaseAuth.signatureValidation do not bind to msg.sender.",
        "attack_scenario": "Sign payload for Wallet A, replay on Wallet B (same config, nonce). Drains both wallets. PoC: test/extensions/sessions/SessionReplay.t.sol, run forge test --match-test test_crossWalletSessionReplayDrainsSiblingWallet -vv. Logs show attacker draining two wallets.",
        "fix_description": "Include address(this) in hashCallWithReplayProtection. Update SDK to hash (wallet, chainId, space, nonce, callIdx, call details).",
        "primary_file": {
            "path": "src/extensions/sessions/SessionSig.sol",
            "content": "// Full file content not directly retrievable; vulnerable sections: L406-L421 (hashCallWithReplayProtection missing wallet)",
            "vulnerable_lines": [
                406,
                407,
                408,
                409,
                410,
                411,
                412,
                413,
                414,
                415,
                416,
                417,
                418,
                419,
                420,
                421
            ],
            "vulnerable_functions": [
                "hashCallWithReplayProtection"
            ]
        },
        "context_files": [
            {
                "path": "src/extensions/sessions/SessionManager.sol",
                "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { Payload } from \"../../modules/Payload.sol\";\r\nimport { ISapient } from \"../../modules/interfaces/ISapient.sol\";\r\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\r\n\r\nimport { SessionErrors } from \"./SessionErrors.sol\";\r\nimport { SessionSig } from \"./SessionSig.sol\";\r\nimport {\r\n  ExplicitSessionManager,\r\n  IExplicitSessionManager,\r\n  SessionPermissions,\r\n  SessionUsageLimits\r\n} from \"./explicit/ExplicitSessionManager.sol\";\r\nimport { Permission, UsageLimit } from \"./explicit/Permission.sol\";\r\nimport { ImplicitSessionManager } from \"./implicit/ImplicitSessionManager.sol\";\r\n\r\nusing LibBytes for bytes;\r\n\r\n/// @title SessionManager\r\n/// @author Michael Standen, Agustin Aguilar\r\n/// @notice Manager for smart sessions\r\ncontract SessionManager is ISapient, ImplicitSessionManager, ExplicitSessionManager {\r\n\r\n  /// @notice Maximum nonce space allowed for sessions use.\r\n  /// @dev This excludes half the possible bits (uint160 vs uint80)\r\n  uint256 public constant MAX_SPACE = type(uint80).max - 1;\r\n\r\n  /// @inheritdoc ISapient\r\n  function recoverSapientSignature(\r\n    Payload.Decoded calldata payload,\r\n    bytes calldata encodedSignature\r\n  ) external view returns (bytes32) {\r\n    // Validate outer Payload\r\n    if (payload.kind != Payload.KIND_TRANSACTIONS) {\r\n      revert SessionErrors.InvalidPayloadKind();\r\n    }\r\n    if (payload.space > MAX_SPACE) {\r\n      revert SessionErrors.InvalidSpace(payload.space);\r\n    }\r\n    if (payload.calls.length == 0) {\r\n      revert SessionErrors.InvalidCallsLength();\r\n    }\r\n\r\n    // Decode signature\r\n    SessionSig.DecodedSignature memory sig = SessionSig.recoverSignature(payload, encodedSignature);\r\n\r\n    address wallet = msg.sender;\r\n\r\n    // Initialize session usage limits for explicit session\r\n    SessionUsageLimits[] memory sessionUsageLimits = new SessionUsageLimits[](payload.calls.length);\r\n\r\n    for (uint256 i = 0; i < payload.calls.length; i++) {\r\n      Payload.Call calldata call = payload.calls[i];\r\n\r\n      // Ban delegate calls\r\n      if (call.delegateCall) {\r\n        revert SessionErrors.InvalidDelegateCall();\r\n      }\r\n      // Ban self calls to the wallet\r\n      if (call.to == wallet) {\r\n        revert SessionErrors.InvalidSelfCall();\r\n      }\r\n\r\n      // Check if this call could cause usage limits to be skipped\r\n      if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\r\n        revert SessionErrors.InvalidBehavior();\r\n      }\r\n\r\n      // Validate call signature\r\n      SessionSig.CallSignature memory callSignature = sig.callSignatures[i];\r\n      if (callSignature.isImplicit) {\r\n        // Validate implicit calls\r\n        _validateImplicitCall(\r\n          call, wallet, callSignature.sessionSigner, callSignature.attestation, sig.implicitBlacklist\r\n        );\r\n      } else {\r\n        // Find the session usage limits for the current call\r\n        SessionUsageLimits memory limits;\r\n        uint256 limitsIdx;\r\n        for (limitsIdx = 0; limitsIdx < sessionUsageLimits.length; limitsIdx++) {\r\n          if (sessionUsageLimits[limitsIdx].signer == address(0)) {\r\n            // Initialize new session usage limits\r\n            limits.signer = callSignature.sessionSigner;\r\n            limits.limits = new UsageLimit[](0);\r\n            bytes32 usageHash = keccak256(abi.encode(callSignature.sessionSigner, VALUE_TRACKING_ADDRESS));\r\n            limits.totalValueUsed = getLimitUsage(wallet, usageHash);\r\n            break;\r\n          }\r\n          if (sessionUsageLimits[limitsIdx].signer == callSignature.sessionSigner) {\r\n            limits = sessionUsageLimits[limitsIdx];\r\n            break;\r\n          }\r\n        }\r\n        // Validate explicit calls. Obtain usage limits for increment validation.\r\n        (limits) = _validateExplicitCall(\r\n          payload,\r\n          i,\r\n          wallet,\r\n          callSignature.sessionSigner,\r\n          sig.sessionPermissions,\r\n          callSignature.sessionPermission,\r\n          limits\r\n        );\r\n        sessionUsageLimits[limitsIdx] = limits;\r\n      }\r\n    }\r\n\r\n    {\r\n      // Reduce the size of the sessionUsageLimits array\r\n      SessionUsageLimits[] memory actualSessionUsageLimits = new SessionUsageLimits[](sessionUsageLimits.length);\r\n      uint256 actualSize;\r\n      for (uint256 i = 0; i < sessionUsageLimits.length; i++) {\r\n        if (sessionUsageLimits[i].limits.length > 0 || sessionUsageLimits[i].totalValueUsed > 0) {\r\n          actualSessionUsageLimits[actualSize] = sessionUsageLimits[i];\r\n          actualSize++;\r\n        }\r\n      }\r\n      assembly {\r\n        mstore(actualSessionUsageLimits, actualSize)\r\n      }\r\n\r\n      // Bulk validate the updated usage limits\r\n      Payload.Call calldata firstCall = payload.calls[0];\r\n      _validateLimitUsageIncrement(firstCall, actualSessionUsageLimits);\r\n    }\r\n\r\n    // Return the image hash\r\n    return sig.imageHash;\r\n  }\r\n\r\n}",
                "relevance": "SessionManager recovery does not enforce wallet binding."
            },
            {
                "path": "src/modules/auth/BaseAuth.sol",
                "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { Payload } from \"../Payload.sol\";\r\n\r\nimport { Storage } from \"../Storage.sol\";\r\nimport { IAuth } from \"../interfaces/IAuth.sol\";\r\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\r\n\r\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\r\nimport { ISapient } from \"../interfaces/ISapient.sol\";\r\nimport { BaseSig } from \"./BaseSig.sol\";\r\n\r\nimport { SelfAuth } from \"./SelfAuth.sol\";\r\n\r\nusing Payload for Payload.Decoded;\r\n\r\n/// @title BaseAuth\r\n/// @author Agustin Aguilar, Michael Standen\r\n/// @notice Base contract for the auth module\r\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\r\n\r\n  /// @dev keccak256(\"org.sequence.module.auth.static\")\r\n  bytes32 private constant STATIC_SIGNATURE_KEY =\r\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\r\n\r\n  /// @notice Error thrown when the sapient signature is invalid\r\n  error InvalidSapientSignature(Payload.Decoded _payload, bytes _signature);\r\n  /// @notice Error thrown when the signature weight is invalid\r\n  error InvalidSignatureWeight(uint256 _threshold, uint256 _weight);\r\n  /// @notice Error thrown when the static signature has expired\r\n  error InvalidStaticSignatureExpired(bytes32 _opHash, uint256 _expires);\r\n  /// @notice Error thrown when the static signature has the wrong caller\r\n  error InvalidStaticSignatureWrongCaller(bytes32 _opHash, address _caller, address _expectedCaller);\r\n\r\n  /// @notice Event emitted when a static signature is set\r\n  event StaticSignatureSet(bytes32 _hash, address _address, uint96 _timestamp);\r\n\r\n  function _getStaticSignature(\r\n    bytes32 _hash\r\n  ) internal view returns (address, uint256) {\r\n    uint256 word = uint256(Storage.readBytes32Map(STATIC_SIGNATURE_KEY, _hash));\r\n    return (address(uint160(word >> 96)), uint256(uint96(word)));\r\n  }\r\n\r\n  function _setStaticSignature(bytes32 _hash, address _address, uint256 _timestamp) internal {\r\n    Storage.writeBytes32Map(\r\n      STATIC_SIGNATURE_KEY, _hash, bytes32(uint256(uint160(_address)) << 96 | (_timestamp & 0xffffffffffffffffffffffff))\r\n    );\r\n  }\r\n\r\n  /// @notice Get the static signature for a specific hash\r\n  /// @param _hash The hash to get the static signature for\r\n  /// @return address The address associated with the static signature\r\n  /// @return timestamp The timestamp of the static signature\r\n  function getStaticSignature(\r\n    bytes32 _hash\r\n  ) external view returns (address, uint256) {\r\n    return _getStaticSignature(_hash);\r\n  }\r\n\r\n  /// @notice Set the static signature for a specific hash\r\n  /// @param _hash The hash to set the static signature for\r\n  /// @param _address The address to associate with the static signature\r\n  /// @param _timestamp The timestamp of the static signature\r\n  /// @dev Only callable by the wallet itself\r\n  function setStaticSignature(bytes32 _hash, address _address, uint96 _timestamp) external onlySelf {\r\n    _setStaticSignature(_hash, _address, _timestamp);\r\n    emit StaticSignatureSet(_hash, _address, _timestamp);\r\n  }\r\n\r\n  /// @notice Update the image hash\r\n  /// @param _imageHash The new image hash\r\n  /// @dev Only callable by the wallet itself\r\n  function updateImageHash(\r\n    bytes32 _imageHash\r\n  ) external virtual onlySelf {\r\n    _updateImageHash(_imageHash);\r\n  }\r\n\r\n  function signatureValidation(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  ) internal view virtual returns (bool isValid, bytes32 opHash) {\r\n    // Read first bit to determine if static signature is used\r\n    bytes1 signatureFlag = _signature[0];\r\n\r\n    if (signatureFlag & 0x80 == 0x80) {\r\n      opHash = _payload.hash();\r\n\r\n      (address addr, uint256 timestamp) = _getStaticSignature(opHash);\r\n      if (timestamp <= block.timestamp) {\r\n        revert InvalidStaticSignatureExpired(opHash, timestamp);\r\n      }\r\n\r\n      if (addr != address(0) && addr != msg.sender) {\r\n        revert InvalidStaticSignatureWrongCaller(opHash, msg.sender, addr);\r\n      }\r\n\r\n      return (true, opHash);\r\n    }\r\n\r\n    // Static signature is not used, recover and validate imageHash\r\n\r\n    uint256 threshold;\r\n    uint256 weight;\r\n    bytes32 imageHash;\r\n\r\n    (threshold, weight, imageHash,, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\r\n\r\n    // Validate the weight\r\n    if (weight < threshold) {\r\n      revert InvalidSignatureWeight(threshold, weight);\r\n    }\r\n\r\n    isValid = _isValidImage(imageHash);\r\n  }\r\n\r\n  /// @inheritdoc ISapient\r\n  function recoverSapientSignature(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  ) external view returns (bytes32) {\r\n    // Copy parent wallets + add caller at the end\r\n    address[] memory parentWallets = new address[](_payload.parentWallets.length + 1);\r\n\r\n    for (uint256 i = 0; i < _payload.parentWallets.length; i++) {\r\n      parentWallets[i] = _payload.parentWallets[i];\r\n    }\r\n\r\n    parentWallets[_payload.parentWallets.length] = msg.sender;\r\n    _payload.parentWallets = parentWallets;\r\n\r\n    (bool isValid,) = signatureValidation(_payload, _signature);\r\n    if (!isValid) {\r\n      revert InvalidSapientSignature(_payload, _signature);\r\n    }\r\n\r\n    return bytes32(uint256(1));\r\n  }\r\n\r\n  /// @inheritdoc IERC1271\r\n  function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {\r\n    Payload.Decoded memory payload = Payload.fromDigest(_hash);\r\n\r\n    (bool isValid,) = signatureValidation(payload, _signature);\r\n    if (!isValid) {\r\n      return bytes4(0);\r\n    }\r\n\r\n    return IERC1271_MAGIC_VALUE_HASH;\r\n  }\r\n\r\n  /// @inheritdoc IPartialAuth\r\n  function recoverPartialSignature(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 threshold,\r\n      uint256 weight,\r\n      bool isValidImage,\r\n      bytes32 imageHash,\r\n      uint256 checkpoint,\r\n      bytes32 opHash\r\n    )\r\n  {\r\n    (threshold, weight, imageHash, checkpoint, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\r\n    isValidImage = _isValidImage(imageHash);\r\n  }\r\n\r\n}",
                "relevance": "BaseAuth validation lacks wallet-specific checks."
            },
            {
                "path": "src/modules/auth/Stage2Auth.sol",
                "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { Wallet } from \"../../Wallet.sol\";\r\nimport { Implementation } from \"../Implementation.sol\";\r\nimport { Storage } from \"../Storage.sol\";\r\nimport { BaseAuth } from \"./BaseAuth.sol\";\r\n\r\n/// @title Stage2Auth\r\n/// @author Agustin Aguilar\r\n/// @notice Stage 2 auth contract\r\ncontract Stage2Auth is BaseAuth, Implementation {\r\n\r\n  /// @dev keccak256(\"org.arcadeum.module.auth.upgradable.image.hash\")\r\n  bytes32 internal constant IMAGE_HASH_KEY = bytes32(0xea7157fa25e3aa17d0ae2d5280fa4e24d421c61842aa85e45194e1145aa72bf8);\r\n\r\n  /// @notice Emitted when the image hash is updated\r\n  event ImageHashUpdated(bytes32 newImageHash);\r\n\r\n  /// @notice Error thrown when the image hash is zero\r\n  error ImageHashIsZero();\r\n\r\n  /// @notice Get the image hash\r\n  /// @return imageHash The image hash\r\n  function imageHash() external view virtual returns (bytes32) {\r\n    return Storage.readBytes32(IMAGE_HASH_KEY);\r\n  }\r\n\r\n  function _isValidImage(\r\n    bytes32 _imageHash\r\n  ) internal view virtual override returns (bool) {\r\n    return _imageHash != bytes32(0) && _imageHash == Storage.readBytes32(IMAGE_HASH_KEY);\r\n  }\r\n\r\n  function _updateImageHash(\r\n    bytes32 _imageHash\r\n  ) internal virtual override {\r\n    if (_imageHash == bytes32(0)) {\r\n      revert ImageHashIsZero();\r\n    }\r\n    Storage.writeBytes32(IMAGE_HASH_KEY, _imageHash);\r\n    emit ImageHashUpdated(_imageHash);\r\n  }\r\n\r\n}",
                "relevance": "Stage2Auth contributes to the overall signature validation flow that fails to bind to the specific wallet."
            }
        ],
        "call_flow": "Sign session for WalletA -> Submit to WalletB (same config/nonce) -> Validation passes -> Drain WalletB",
        "context_hint": "Session signature hashes omit the wallet address, enabling cross-wallet replay attacks on identically configured wallets.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-sequence_M02",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_finding_id": "M-02",
        "report_url": "https://code4rena.com/reports/2025-10-sequence",
        "github_repo_url": "https://github.com/code-423n4/2025-10-sequence",
        "contest_date": "2025-10-07",
        "severity": "medium",
        "vulnerability_type": "dos",
        "difficulty_tier": 2,
        "context_level": "multi_file",
        "finding_title": "Static signatures bound to caller revert under ERC-4337, causing DoS",
        "finding_description": "In ERC-4337, validateUserOp uses external self-call to isValidSignature, changing msg.sender to wallet instead of entrypoint. BaseAuth.signatureValidation enforces caller binding, causing revert for static signatures bound to entrypoint.",
        "attack_scenario": "Deploy wallet with static signature bound to entrypoint. Attempt validateUserOp â†’ reverts with InvalidStaticSignatureWrongCaller. PoC: Add test to test/modules/ERC4337v07.t.sol: test_validateUserOp_staticSig_callerMismatch_reverts. Uses server and forge test.",
        "fix_description": "Avoid external self-call; propagate intended caller into validation.",
        "primary_file": {
            "path": "src/modules/ERC4337v07.sol",
            "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.18;\r\n\r\nimport { Calls } from \"./Calls.sol\";\r\n\r\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\r\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\r\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\r\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\r\n\r\n/// @title ERC4337v07\r\n/// @author Agustin Aguilar, Michael Standen\r\n/// @notice ERC4337 v7 support\r\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\r\n\r\n  uint256 internal constant SIG_VALIDATION_FAILED = 1;\r\n\r\n  address public immutable entrypoint;\r\n\r\n  error InvalidEntryPoint(address _entrypoint);\r\n  error ERC4337Disabled();\r\n\r\n  constructor(\r\n    address _entrypoint\r\n  ) {\r\n    entrypoint = _entrypoint;\r\n  }\r\n\r\n  /// @inheritdoc IAccount\r\n  function validateUserOp(\r\n    PackedUserOperation calldata userOp,\r\n    bytes32 userOpHash,\r\n    uint256 missingAccountFunds\r\n  ) external returns (uint256 validationData) {\r\n    if (entrypoint == address(0)) {\r\n      revert ERC4337Disabled();\r\n    }\r\n\r\n    if (msg.sender != entrypoint) {\r\n      revert InvalidEntryPoint(msg.sender);\r\n    }\r\n\r\n    // userOp.nonce is validated by the entrypoint\r\n\r\n    if (missingAccountFunds != 0) {\r\n      IEntryPoint(entrypoint).depositTo{ value: missingAccountFunds }(address(this));\r\n    }\r\n\r\n    if (this.isValidSignature(userOpHash, userOp.signature) != IERC1271_MAGIC_VALUE_HASH) {\r\n      return SIG_VALIDATION_FAILED;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /// @notice Execute a user operation\r\n  /// @param _payload The packed payload\r\n  /// @dev This is the execute function for the EntryPoint to call.\r\n  function executeUserOp(\r\n    bytes calldata _payload\r\n  ) external nonReentrant {\r\n    if (entrypoint == address(0)) {\r\n      revert ERC4337Disabled();\r\n    }\r\n\r\n    if (msg.sender != entrypoint) {\r\n      revert InvalidEntryPoint(msg.sender);\r\n    }\r\n\r\n    this.selfExecute(_payload);\r\n  }\r\n\r\n}",
            "vulnerable_lines": [
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54
            ],
            "vulnerable_functions": [
                "validateUserOp"
            ]
        },
        "context_files": [
            {
                "path": "src/modules/auth/BaseAuth.sol",
                "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { Payload } from \"../Payload.sol\";\r\n\r\nimport { Storage } from \"../Storage.sol\";\r\nimport { IAuth } from \"../interfaces/IAuth.sol\";\r\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\r\n\r\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\r\nimport { ISapient } from \"../interfaces/ISapient.sol\";\r\nimport { BaseSig } from \"./BaseSig.sol\";\r\n\r\nimport { SelfAuth } from \"./SelfAuth.sol\";\r\n\r\nusing Payload for Payload.Decoded;\r\n\r\n/// @title BaseAuth\r\n/// @author Agustin Aguilar, Michael Standen\r\n/// @notice Base contract for the auth module\r\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\r\n\r\n  /// @dev keccak256(\"org.sequence.module.auth.static\")\r\n  bytes32 private constant STATIC_SIGNATURE_KEY =\r\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\r\n\r\n  /// @notice Error thrown when the sapient signature is invalid\r\n  error InvalidSapientSignature(Payload.Decoded _payload, bytes _signature);\r\n  /// @notice Error thrown when the signature weight is invalid\r\n  error InvalidSignatureWeight(uint256 _threshold, uint256 _weight);\r\n  /// @notice Error thrown when the static signature has expired\r\n  error InvalidStaticSignatureExpired(bytes32 _opHash, uint256 _expires);\r\n  /// @notice Error thrown when the static signature has the wrong caller\r\n  error InvalidStaticSignatureWrongCaller(bytes32 _opHash, address _caller, address _expectedCaller);\r\n\r\n  /// @notice Event emitted when a static signature is set\r\n  event StaticSignatureSet(bytes32 _hash, address _address, uint96 _timestamp);\r\n\r\n  function _getStaticSignature(\r\n    bytes32 _hash\r\n  ) internal view returns (address, uint256) {\r\n    uint256 word = uint256(Storage.readBytes32Map(STATIC_SIGNATURE_KEY, _hash));\r\n    return (address(uint160(word >> 96)), uint256(uint96(word)));\r\n  }\r\n\r\n  function _setStaticSignature(bytes32 _hash, address _address, uint256 _timestamp) internal {\r\n    Storage.writeBytes32Map(\r\n      STATIC_SIGNATURE_KEY, _hash, bytes32(uint256(uint160(_address)) << 96 | (_timestamp & 0xffffffffffffffffffffffff))\r\n    );\r\n  }\r\n\r\n  /// @notice Get the static signature for a specific hash\r\n  /// @param _hash The hash to get the static signature for\r\n  /// @return address The address associated with the static signature\r\n  /// @return timestamp The timestamp of the static signature\r\n  function getStaticSignature(\r\n    bytes32 _hash\r\n  ) external view returns (address, uint256) {\r\n    return _getStaticSignature(_hash);\r\n  }\r\n\r\n  /// @notice Set the static signature for a specific hash\r\n  /// @param _hash The hash to set the static signature for\r\n  /// @param _address The address to associate with the static signature\r\n  /// @param _timestamp The timestamp of the static signature\r\n  /// @dev Only callable by the wallet itself\r\n  function setStaticSignature(bytes32 _hash, address _address, uint96 _timestamp) external onlySelf {\r\n    _setStaticSignature(_hash, _address, _timestamp);\r\n    emit StaticSignatureSet(_hash, _address, _timestamp);\r\n  }\r\n\r\n  /// @notice Update the image hash\r\n  /// @param _imageHash The new image hash\r\n  /// @dev Only callable by the wallet itself\r\n  function updateImageHash(\r\n    bytes32 _imageHash\r\n  ) external virtual onlySelf {\r\n    _updateImageHash(_imageHash);\r\n  }\r\n\r\n  function signatureValidation(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  ) internal view virtual returns (bool isValid, bytes32 opHash) {\r\n    // Read first bit to determine if static signature is used\r\n    bytes1 signatureFlag = _signature[0];\r\n\r\n    if (signatureFlag & 0x80 == 0x80) {\r\n      opHash = _payload.hash();\r\n\r\n      (address addr, uint256 timestamp) = _getStaticSignature(opHash);\r\n      if (timestamp <= block.timestamp) {\r\n        revert InvalidStaticSignatureExpired(opHash, timestamp);\r\n      }\r\n\r\n      if (addr != address(0) && addr != msg.sender) {\r\n        revert InvalidStaticSignatureWrongCaller(opHash, msg.sender, addr);\r\n      }\r\n\r\n      return (true, opHash);\r\n    }\r\n\r\n    // Static signature is not used, recover and validate imageHash\r\n\r\n    uint256 threshold;\r\n    uint256 weight;\r\n    bytes32 imageHash;\r\n\r\n    (threshold, weight, imageHash,, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\r\n\r\n    // Validate the weight\r\n    if (weight < threshold) {\r\n      revert InvalidSignatureWeight(threshold, weight);\r\n    }\r\n\r\n    isValid = _isValidImage(imageHash);\r\n  }\r\n\r\n  /// @inheritdoc ISapient\r\n  function recoverSapientSignature(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  ) external view returns (bytes32) {\r\n    // Copy parent wallets + add caller at the end\r\n    address[] memory parentWallets = new address[](_payload.parentWallets.length + 1);\r\n\r\n    for (uint256 i = 0; i < _payload.parentWallets.length; i++) {\r\n      parentWallets[i] = _payload.parentWallets[i];\r\n    }\r\n\r\n    parentWallets[_payload.parentWallets.length] = msg.sender;\r\n    _payload.parentWallets = parentWallets;\r\n\r\n    (bool isValid,) = signatureValidation(_payload, _signature);\r\n    if (!isValid) {\r\n      revert InvalidSapientSignature(_payload, _signature);\r\n    }\r\n\r\n    return bytes32(uint256(1));\r\n  }\r\n\r\n  /// @inheritdoc IERC1271\r\n  function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {\r\n    Payload.Decoded memory payload = Payload.fromDigest(_hash);\r\n\r\n    (bool isValid,) = signatureValidation(payload, _signature);\r\n    if (!isValid) {\r\n      return bytes4(0);\r\n    }\r\n\r\n    return IERC1271_MAGIC_VALUE_HASH;\r\n  }\r\n\r\n  /// @inheritdoc IPartialAuth\r\n  function recoverPartialSignature(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 threshold,\r\n      uint256 weight,\r\n      bool isValidImage,\r\n      bytes32 imageHash,\r\n      uint256 checkpoint,\r\n      bytes32 opHash\r\n    )\r\n  {\r\n    (threshold, weight, imageHash, checkpoint, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\r\n    isValidImage = _isValidImage(imageHash);\r\n  }\r\n\r\n}",
                "relevance": "BaseAuth enforces strict caller check incompatible with ERC-4337 self-call."
            }
        ],
        "call_flow": "EntryPoint.validateUserOp() -> Wallet.self-call isValidSignature() -> msg.sender = wallet -> BaseAuth check fails for entrypoint-bound sig",
        "context_hint": "ERC-4337 validation changes msg.sender via self-call, breaking static signatures bound to the original caller (EntryPoint).",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-sequence_M03",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_finding_id": "M-03",
        "report_url": "https://code4rena.com/reports/2025-10-sequence",
        "github_repo_url": "https://github.com/code-423n4/2025-10-sequence",
        "contest_date": "2025-10-07",
        "severity": "medium",
        "vulnerability_type": "logic_error",
        "difficulty_tier": 2,
        "context_level": "multi_file",
        "finding_title": "BaseAuth.recoverSapientSignature returns a constant instead of signer image hash, breaking sapient signer flows",
        "finding_description": "BaseAuth.recoverSapientSignature returns bytes32(uint256(1)) instead of actual signer imageHash, violating ISapient interface. Breaks Merkle leaf construction in BaseSig.recoverBranch.",
        "attack_scenario": "Wallet uses another wallet as sapient signer â†’ signature validation fails due to incorrect image hash. PoC: Add test to test/modules/BaseSig.t.sol: test_BaseAuth_recoverSapientSignature_ReturnsConstant. Deploys MinimalSapient, crafts signature, asserts constant return.",
        "fix_description": "Return actual image hash from recoverSapientSignature. Extend signatureValidation to return imageHash or call BaseSig.recover.",
        "primary_file": {
            "path": "src/modules/auth/BaseAuth.sol",
            "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { Payload } from \"../Payload.sol\";\r\n\r\nimport { Storage } from \"../Storage.sol\";\r\nimport { IAuth } from \"../interfaces/IAuth.sol\";\r\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\r\n\r\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\r\nimport { ISapient } from \"../interfaces/ISapient.sol\";\r\nimport { BaseSig } from \"./BaseSig.sol\";\r\n\r\nimport { SelfAuth } from \"./SelfAuth.sol\";\r\n\r\nusing Payload for Payload.Decoded;\r\n\r\n/// @title BaseAuth\r\n/// @author Agustin Aguilar, Michael Standen\r\n/// @notice Base contract for the auth module\r\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\r\n\r\n  /// @dev keccak256(\"org.sequence.module.auth.static\")\r\n  bytes32 private constant STATIC_SIGNATURE_KEY =\r\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\r\n\r\n  /// @notice Error thrown when the sapient signature is invalid\r\n  error InvalidSapientSignature(Payload.Decoded _payload, bytes _signature);\r\n  /// @notice Error thrown when the signature weight is invalid\r\n  error InvalidSignatureWeight(uint256 _threshold, uint256 _weight);\r\n  /// @notice Error thrown when the static signature has expired\r\n  error InvalidStaticSignatureExpired(bytes32 _opHash, uint256 _expires);\r\n  /// @notice Error thrown when the static signature has the wrong caller\r\n  error InvalidStaticSignatureWrongCaller(bytes32 _opHash, address _caller, address _expectedCaller);\r\n\r\n  /// @notice Event emitted when a static signature is set\r\n  event StaticSignatureSet(bytes32 _hash, address _address, uint96 _timestamp);\r\n\r\n  function _getStaticSignature(\r\n    bytes32 _hash\r\n  ) internal view returns (address, uint256) {\r\n    uint256 word = uint256(Storage.readBytes32Map(STATIC_SIGNATURE_KEY, _hash));\r\n    return (address(uint160(word >> 96)), uint256(uint96(word)));\r\n  }\r\n\r\n  function _setStaticSignature(bytes32 _hash, address _address, uint256 _timestamp) internal {\r\n    Storage.writeBytes32Map(\r\n      STATIC_SIGNATURE_KEY, _hash, bytes32(uint256(uint160(_address)) << 96 | (_timestamp & 0xffffffffffffffffffffffff))\r\n    );\r\n  }\r\n\r\n  /// @notice Get the static signature for a specific hash\r\n  /// @param _hash The hash to get the static signature for\r\n  /// @return address The address associated with the static signature\r\n  /// @return timestamp The timestamp of the static signature\r\n  function getStaticSignature(\r\n    bytes32 _hash\r\n  ) external view returns (address, uint256) {\r\n    return _getStaticSignature(_hash);\r\n  }\r\n\r\n  /// @notice Set the static signature for a specific hash\r\n  /// @param _hash The hash to set the static signature for\r\n  /// @param _address The address to associate with the static signature\r\n  /// @param _timestamp The timestamp of the static signature\r\n  /// @dev Only callable by the wallet itself\r\n  function setStaticSignature(bytes32 _hash, address _address, uint96 _timestamp) external onlySelf {\r\n    _setStaticSignature(_hash, _address, _timestamp);\r\n    emit StaticSignatureSet(_hash, _address, _timestamp);\r\n  }\r\n\r\n  /// @notice Update the image hash\r\n  /// @param _imageHash The new image hash\r\n  /// @dev Only callable by the wallet itself\r\n  function updateImageHash(\r\n    bytes32 _imageHash\r\n  ) external virtual onlySelf {\r\n    _updateImageHash(_imageHash);\r\n  }\r\n\r\n  function signatureValidation(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  ) internal view virtual returns (bool isValid, bytes32 opHash) {\r\n    // Read first bit to determine if static signature is used\r\n    bytes1 signatureFlag = _signature[0];\r\n\r\n    if (signatureFlag & 0x80 == 0x80) {\r\n      opHash = _payload.hash();\r\n\r\n      (address addr, uint256 timestamp) = _getStaticSignature(opHash);\r\n      if (timestamp <= block.timestamp) {\r\n        revert InvalidStaticSignatureExpired(opHash, timestamp);\r\n      }\r\n\r\n      if (addr != address(0) && addr != msg.sender) {\r\n        revert InvalidStaticSignatureWrongCaller(opHash, msg.sender, addr);\r\n      }\r\n\r\n      return (true, opHash);\r\n    }\r\n\r\n    // Static signature is not used, recover and validate imageHash\r\n\r\n    uint256 threshold;\r\n    uint256 weight;\r\n    bytes32 imageHash;\r\n\r\n    (threshold, weight, imageHash,, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\r\n\r\n    // Validate the weight\r\n    if (weight < threshold) {\r\n      revert InvalidSignatureWeight(threshold, weight);\r\n    }\r\n\r\n    isValid = _isValidImage(imageHash);\r\n  }\r\n\r\n  /// @inheritdoc ISapient\r\n  function recoverSapientSignature(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  ) external view returns (bytes32) {\r\n    // Copy parent wallets + add caller at the end\r\n    address[] memory parentWallets = new address[](_payload.parentWallets.length + 1);\r\n\r\n    for (uint256 i = 0; i < _payload.parentWallets.length; i++) {\r\n      parentWallets[i] = _payload.parentWallets[i];\r\n    }\r\n\r\n    parentWallets[_payload.parentWallets.length] = msg.sender;\r\n    _payload.parentWallets = parentWallets;\r\n\r\n    (bool isValid,) = signatureValidation(_payload, _signature);\r\n    if (!isValid) {\r\n      revert InvalidSapientSignature(_payload, _signature);\r\n    }\r\n\r\n    return bytes32(uint256(1));\r\n  }\r\n\r\n  /// @inheritdoc IERC1271\r\n  function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {\r\n    Payload.Decoded memory payload = Payload.fromDigest(_hash);\r\n\r\n    (bool isValid,) = signatureValidation(payload, _signature);\r\n    if (!isValid) {\r\n      return bytes4(0);\r\n    }\r\n\r\n    return IERC1271_MAGIC_VALUE_HASH;\r\n  }\r\n\r\n  /// @inheritdoc IPartialAuth\r\n  function recoverPartialSignature(\r\n    Payload.Decoded memory _payload,\r\n    bytes calldata _signature\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 threshold,\r\n      uint256 weight,\r\n      bool isValidImage,\r\n      bytes32 imageHash,\r\n      uint256 checkpoint,\r\n      bytes32 opHash\r\n    )\r\n  {\r\n    (threshold, weight, imageHash, checkpoint, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\r\n    isValidImage = _isValidImage(imageHash);\r\n  }\r\n\r\n}",
            "vulnerable_lines": [
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140
            ],
            "vulnerable_functions": [
                "recoverSapientSignature"
            ]
        },
        "context_files": [
            {
                "path": "src/modules/interfaces/ISapient.sol",
                "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport { Payload } from \"../Payload.sol\";\r\n\r\n/// @title ISapient\r\n/// @author Agustin Aguilar, Michael Standen\r\n/// @notice Sapient signers take an explicit payload and return their own \"imageHash\" as result\r\n/// @dev The consumer of this signer must validate if the imageHash is valid or not, for the desired configuration\r\ninterface ISapient {\r\n\r\n  /// @notice Recovers the image hash of a given signature\r\n  /// @param payload The payload to recover the signature from\r\n  /// @param signature The signature to recover the image hash from\r\n  /// @return imageHash The recovered image hash\r\n  function recoverSapientSignature(\r\n    Payload.Decoded calldata payload,\r\n    bytes calldata signature\r\n  ) external view returns (bytes32 imageHash);\r\n\r\n}\r\n\r\n/// @title ISapientCompact\r\n/// @author Agustin Aguilar, Michael Standen\r\n/// @notice Sapient signers take a compacted payload and return their own \"imageHash\" as result\r\n/// @dev The consumer of this signer must validate if the imageHash is valid or not, for the desired configuration\r\ninterface ISapientCompact {\r\n\r\n  /// @notice Recovers the image hash of a given signature, using a hashed payload\r\n  /// @param digest The digest of the payload\r\n  /// @param signature The signature to recover the image hash from\r\n  /// @return imageHash The recovered image hash\r\n  function recoverSapientSignatureCompact(\r\n    bytes32 digest,\r\n    bytes calldata signature\r\n  ) external view returns (bytes32 imageHash);\r\n\r\n}",
                "relevance": "ISapient expects proper imageHash return for sapient signer flows."
            }
        ],
        "call_flow": "Sapient signature validation -> BaseAuth.recoverSapientSignature() -> returns constant (0x1) -> Merkle leaf mismatch -> validation fails",
        "context_hint": "Sapient signer recovery returns hardcoded constant instead of actual image hash, breaking nested/sapient signer configurations.",
        "is_vulnerable": true
    },
    {
        "id": "gs_c4_2025-10-sequence_M04",
        "subset": "gold_standard",
        "language": "solidity",
        "chain": "ethereum",
        "source_platform": "code4rena",
        "source_finding_id": "M-04",
        "report_url": "https://code4rena.com/reports/2025-10-sequence",
        "github_repo_url": "https://github.com/code-423n4/2025-10-sequence",
        "contest_date": "2025-10-07",
        "severity": "medium",
        "vulnerability_type": "dos",
        "difficulty_tier": 2,
        "context_level": "single_file",
        "finding_title": "Factory deploy reverts instead of returning address when account already exists",
        "finding_description": "Factory.deploy uses create2 but reverts with CreateCollision if address exists, violating ERC-4337 expectation to return address. Breaks simulations and bundler logic.",
        "attack_scenario": "Deploy wallet once, call deploy again â†’ reverts. Attacker can front-run to cause DoS. PoC: test_factory_double_deploy_PoC in AuditPoC.sol. Shows first deploy succeeds, second reverts.",
        "fix_description": "Check if address exists via predicted.code.length, return it if so.",
        "primary_file": {
            "path": "src/Factory.sol",
            "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport \"./Wallet.sol\";\r\n\r\n/// @title Factory\r\n/// @author Agustin Aguilar, Michael Standen\r\n/// @notice Factory for deploying wallets\r\ncontract Factory {\r\n\r\n  /// @notice Error thrown when the deployment fails\r\n  error DeployFailed(address _mainModule, bytes32 _salt);\r\n\r\n  /// @notice Deploy a new wallet instance\r\n  /// @param _mainModule Address of the main module to be used by the wallet\r\n  /// @param _salt Salt used to generate the wallet, which is the imageHash of the wallet's configuration.\r\n  /// @dev It is recommended to not have more than 200 signers as opcode repricing could make transactions impossible to execute as all the signers must be passed for each transaction.\r\n  function deploy(address _mainModule, bytes32 _salt) public payable returns (address _contract) {\r\n    bytes memory code = abi.encodePacked(Wallet.creationCode, uint256(uint160(_mainModule)));\r\n    assembly {\r\n      _contract := create2(callvalue(), add(code, 32), mload(code), _salt)\r\n    }\r\n    if (_contract == address(0)) {\r\n      revert DeployFailed(_mainModule, _salt);\r\n    }\r\n  }\r\n\r\n}",
            "vulnerable_lines": [
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26
            ],
            "vulnerable_functions": [
                "deploy"
            ]
        },
        "context_files": [],
        "call_flow": "Factory.deploy(existing wallet) -> create2 collision -> revert CreateCollision (instead of returning address)",
        "context_hint": "Factory reverts on redeploy attempt instead of returning existing address, breaking ERC-4337 compatibility and enabling DoS.",
        "is_vulnerable": true
    }
]