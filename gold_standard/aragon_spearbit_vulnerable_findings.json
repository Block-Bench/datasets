[
  {
    "id": "gs_spearbit_aragon-lock-to-vote_H01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "H-01",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "high",
    "vulnerability_type": "flash_loan",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "MinVotingPowerCondition logic can be bypassed via flashloans",
    "finding_description": "The MinVotingPowerCondition contract allows any users who hold at least plugin.minProposerVotingPower() amount of tokens (locked in the LockManager or in their token balance) to create a proposal and execute LockToVote.createProposal. This logic can be easily bypassed if the token allows flashloan or flashmint. Given that isGranted checks the user's token balance (line 45: token.balanceOf(_who) + lockManager.getLockedBalance(_who)), the user does not even need to lock the flashloaned amount into the LockManager to be able to create and spam proposals.",
    "attack_scenario": "1. Flashloan the token.\n2. Create the proposal (isGranted passes because token.balanceOf includes flashloaned amount).\n3. Lock + vote the proposal and auto-execute it (EarlyExecution).\n4. Unlock the tokens.\n5. Repay the flashloan.\nAll in the very same transaction.",
    "fix_description": "Avoid using the token's balance and require the user to only use the locked amount. Change line 45 from 'token.balanceOf(_who) + lockManager.getLockedBalance(_who)' to just 'lockManager.getLockedBalance(_who)'. Store the proposal's creator in the proposal struct and require that the locked amount required to create the proposal won't be unlockable until the proposal ends.",
    "primary_file": {
      "path": "src/conditions/MinVotingPowerCondition.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable plugin;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable lockManager;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable token;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _plugin) {\n        plugin = _plugin;\n        token = plugin.token();\n        lockManager = plugin.lockManager();\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function isGranted(address _where, address _who, bytes32 _permissionId, bytes calldata _data)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (_where, _data, _permissionId);\n\n        uint256 _currentBalance = token.balanceOf(_who) + lockManager.getLockedBalance(_who);\n        uint256 _minProposerVotingPower = plugin.minProposerVotingPower();\n\n        return _currentBalance >= _minProposerVotingPower;\n    }\n}\n",
      "vulnerable_lines": [
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48
      ],
      "vulnerable_functions": [
        "isGranted"
      ]
    },
    "context_files": [
      {
        "path": "src/LockToVotePlugin.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.minProposerVotingPower.selector ^ this.createProposal.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 proposalId, address voter);\n\n    error VoteRemovalForbidden(uint256 proposalId, address voter);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function initialize(\n        IDAO _dao,\n        ILockManager _lockManager,\n        VotingSettings calldata _votingSettings,\n        IPlugin.TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(1) {\n        __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n        __LockToGovernBase_init(_lockManager);\n\n        emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IProposal\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint256 _allowFailureMap;\n\n        if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n        }\n\n        if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n        // Store proposal related information\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minParticipationRatio = minParticipationRatio();\n        proposal_.parameters.minApprovalRatio = minApprovalRatio();\n\n        proposal_.targetConfig = getTargetConfig();\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n\n        lockManager.proposalCreated(proposalId);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n    }\n\n    /// @inheritdoc ILockToVote\n    function vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        public\n        override\n        auth(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n        }\n\n        // Same vote\n        if (_voteOption == proposal_.votes[_voter].voteOption) {\n            // Same value, nothing to do\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                proposal_.tally.no += diff;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                proposal_.tally.abstain += diff;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (proposal_.votes[_voter].votingPower > 0) {\n                // Undo that vote\n                if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                    proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n                } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                    proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n                }\n            }\n\n            // Register the new vote\n            if (_voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n                proposal_.tally.no += _newVotingPower;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n        }\n\n        emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n\n        if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        if (!_isProposalOpen(proposal_)) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.votes[_voter].votingPower == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n        } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n        }\n        proposal_.votes[_voter].votingPower = 0;\n\n        emit VoteCleared(_proposalId, _voter);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function isProposalOpen(uint256 _proposalId) external view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _isProposalOpen(proposal_);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.minProposerVotingPower();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function currentTokenSupply() public view override returns (uint256) {\n        return IERC20(lockManager.token()).totalSupply();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\n        return proposals[_proposalId].votes[_voter].votingPower;\n    }\n\n    // Internal helpers\n\n    function _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        } else if (_voteOption == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_newVotingPower <= _currentVotingPower) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                proposal_.votes[_voter].voteOption != VoteOption.None\n                    && _voteOption != proposal_.votes[_voter].voteOption\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\n        if (!_canExecute(_proposalId)) {\n            return;\n        } else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\n            return;\n        }\n\n        _execute(_proposalId);\n    }\n\n    function _execute(uint256 _proposalId) internal override {\n        super._execute(_proposalId);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        lockManager.proposalEnded(_proposalId);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
        "relevance": "The voting plugin that MinVotingPowerCondition protects. Contains createProposal which is the target of the bypass."
      },
      {
        "path": "src/base/LockManagerBase.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public settings;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public plugin;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private lockedBalances;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal knownProposalIds;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address voter, uint256 amount);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address voter, uint256 amount);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 proposalId);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _settings) {\n        settings.pluginMode = _settings.pluginMode;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function knownProposalIdAt(uint256 _index) public view virtual returns (uint256) {\n        return knownProposalIds.at(_index);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function knownProposalIdsLength() public view virtual returns (uint256) {\n        return knownProposalIds.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function lock() public virtual {\n        _lock(_incomingTokenBalance());\n    }\n\n    /// @inheritdoc ILockManager\n    function lock(uint256 _amount) public virtual {\n        _lock(_amount);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_incomingTokenBalance());\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption, uint256 _amount) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_amount);\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function getLockedBalance(address _account) public view virtual returns (uint256) {\n        return lockedBalances[_account];\n    }\n\n    /// @inheritdoc ILockManager\n    function canVote(uint256 _proposalId, address _voter, IMajorityVoting.VoteOption _voteOption)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(plugin)).canVote(_proposalId, _voter, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function unlock() public virtual {\n        uint256 _refundableBalance = getLockedBalance(msg.sender);\n        if (_refundableBalance == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _withdrawActiveVotingPower();\n\n        // All votes clear\n\n        lockedBalances[msg.sender] = 0;\n\n        // Withdraw\n        _doUnlockTransfer(msg.sender, _refundableBalance);\n        emit BalanceUnlocked(msg.sender, _refundableBalance);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalCreated(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        knownProposalIds.add(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalEnded(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_proposalId);\n        knownProposalIds.remove(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function setPluginAddress(ILockToGovernBase _newPluginAddress) public virtual {\n        if (address(plugin) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToGovernBase).interfaceId)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            settings.pluginMode == PluginMode.Voting\n                && !IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToVote).interfaceId)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        plugin = _newPluginAddress;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _incomingTokenBalance() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _lock(uint256 _amount) internal virtual {\n        if (_amount == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _doLockTransfer(_amount);\n\n        lockedBalances[msg.sender] += _amount;\n        emit BalanceLocked(msg.sender, _amount);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _doLockTransfer(uint256 _amount) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual;\n\n    function _vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) internal virtual {\n        uint256 _currentVotingPower = getLockedBalance(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(plugin)).vote(_proposalId, msg.sender, _voteOption, _currentVotingPower);\n    }\n\n    function _withdrawActiveVotingPower() internal virtual {\n        uint256 _proposalCount = knownProposalIds.length();\n        for (uint256 _i; _i < _proposalCount;) {\n            uint256 _proposalId = knownProposalIds.at(_i);\n            if (!plugin.isProposalOpen(_proposalId)) {\n                knownProposalIds.remove(_proposalId);\n                _proposalCount = knownProposalIds.length();\n\n                // Were we at the last element?\n                if (_i == _proposalCount) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (plugin.usedVotingPower(_proposalId, msg.sender) > 0) {\n                ILockToVote(address(plugin)).clearVote(_proposalId, msg.sender);\n            }\n\n            unchecked {\n                _i++;\n            }\n        }\n    }\n}\n",
        "relevance": "Manages token locking. The vulnerability allows bypassing the lock requirement via flashloans since isGranted checks raw balance."
      }
    ],
    "call_flow": "Attacker.flashloan() -> MinVotingPowerCondition.isGranted() checks token.balanceOf(_who) + lockManager.getLockedBalance(_who) -> returns true -> LockToVotePlugin.createProposal() succeeds -> repay flashloan",
    "context_hint": "The MinVotingPowerCondition.isGranted() function at line 45 checks 'token.balanceOf(_who) + lockManager.getLockedBalance(_who)'. Since token.balanceOf() can be temporarily inflated via flashloans, an attacker can bypass the minimum voting power requirement without actually having tokens locked. Combined with EarlyExecution mode, this allows creating and executing malicious proposals in a single transaction.",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_aragon-lock-to-vote_H02",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "H-02",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "high",
    "vulnerability_type": "flash_loan",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "Proposals created with voting mode EarlyExecution are vulnerable to flashloan attacks",
    "finding_description": "If the token used by the LockManager can be flashloaned (or flashminted) and a proposal is created with the voting mode EarlyExecution, anyone could be able to 'early execute' it by flashloaning tokens, locking them, casting a YES vote to trigger early execution, unlocking tokens, and repaying the flashloan - all in one transaction. The vulnerable code is in LockToVotePlugin.vote() at lines 205-207 which calls _attemptEarlyExecution() when VotingMode.EarlyExecution is set.",
    "attack_scenario": "1. Flashloan the needed amount.\n2. Lock the flashloaned amount via LockManager.lock().\n3. Cast a 'YES' vote via LockManager.vote() which triggers LockToVotePlugin._attemptEarlyExecution().\n4. Proposal executes immediately in same transaction.\n5. Unlock the tokens via LockManager.unlock().\n6. Repay the flashloan.",
    "fix_description": "Avoid allowing the early execution in the very same block that the vote has been made. This would require tracking the 'success' of a proposal in a separate flag, stored in the proposal struct. Alternatively, remove the EarlyExecution voting mode entirely.",
    "primary_file": {
      "path": "src/LockToVotePlugin.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.minProposerVotingPower.selector ^ this.createProposal.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 proposalId, address voter);\n\n    error VoteRemovalForbidden(uint256 proposalId, address voter);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function initialize(\n        IDAO _dao,\n        ILockManager _lockManager,\n        VotingSettings calldata _votingSettings,\n        IPlugin.TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(1) {\n        __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n        __LockToGovernBase_init(_lockManager);\n\n        emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IProposal\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint256 _allowFailureMap;\n\n        if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n        }\n\n        if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n        // Store proposal related information\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minParticipationRatio = minParticipationRatio();\n        proposal_.parameters.minApprovalRatio = minApprovalRatio();\n\n        proposal_.targetConfig = getTargetConfig();\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n\n        lockManager.proposalCreated(proposalId);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n    }\n\n    /// @inheritdoc ILockToVote\n    function vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        public\n        override\n        auth(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n        }\n\n        // Same vote\n        if (_voteOption == proposal_.votes[_voter].voteOption) {\n            // Same value, nothing to do\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                proposal_.tally.no += diff;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                proposal_.tally.abstain += diff;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (proposal_.votes[_voter].votingPower > 0) {\n                // Undo that vote\n                if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                    proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n                } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                    proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n                }\n            }\n\n            // Register the new vote\n            if (_voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n                proposal_.tally.no += _newVotingPower;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n        }\n\n        emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n\n        if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        if (!_isProposalOpen(proposal_)) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.votes[_voter].votingPower == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n        } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n        }\n        proposal_.votes[_voter].votingPower = 0;\n\n        emit VoteCleared(_proposalId, _voter);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function isProposalOpen(uint256 _proposalId) external view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _isProposalOpen(proposal_);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.minProposerVotingPower();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function currentTokenSupply() public view override returns (uint256) {\n        return IERC20(lockManager.token()).totalSupply();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\n        return proposals[_proposalId].votes[_voter].votingPower;\n    }\n\n    // Internal helpers\n\n    function _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        } else if (_voteOption == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_newVotingPower <= _currentVotingPower) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                proposal_.votes[_voter].voteOption != VoteOption.None\n                    && _voteOption != proposal_.votes[_voter].voteOption\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\n        if (!_canExecute(_proposalId)) {\n            return;\n        } else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\n            return;\n        }\n\n        _execute(_proposalId);\n    }\n\n    function _execute(uint256 _proposalId) internal override {\n        super._execute(_proposalId);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        lockManager.proposalEnded(_proposalId);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "vulnerable_lines": [
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        187,
        188,
        189,
        190,
        191,
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        302,
        303,
        304,
        305,
        306,
        307,
        308,
        309,
        310
      ],
      "vulnerable_functions": [
        "vote",
        "_attemptEarlyExecution"
      ]
    },
    "context_files": [
      {
        "path": "src/base/LockManagerBase.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public settings;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public plugin;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private lockedBalances;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal knownProposalIds;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address voter, uint256 amount);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address voter, uint256 amount);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 proposalId);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _settings) {\n        settings.pluginMode = _settings.pluginMode;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function knownProposalIdAt(uint256 _index) public view virtual returns (uint256) {\n        return knownProposalIds.at(_index);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function knownProposalIdsLength() public view virtual returns (uint256) {\n        return knownProposalIds.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function lock() public virtual {\n        _lock(_incomingTokenBalance());\n    }\n\n    /// @inheritdoc ILockManager\n    function lock(uint256 _amount) public virtual {\n        _lock(_amount);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_incomingTokenBalance());\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption, uint256 _amount) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_amount);\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function getLockedBalance(address _account) public view virtual returns (uint256) {\n        return lockedBalances[_account];\n    }\n\n    /// @inheritdoc ILockManager\n    function canVote(uint256 _proposalId, address _voter, IMajorityVoting.VoteOption _voteOption)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(plugin)).canVote(_proposalId, _voter, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function unlock() public virtual {\n        uint256 _refundableBalance = getLockedBalance(msg.sender);\n        if (_refundableBalance == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _withdrawActiveVotingPower();\n\n        // All votes clear\n\n        lockedBalances[msg.sender] = 0;\n\n        // Withdraw\n        _doUnlockTransfer(msg.sender, _refundableBalance);\n        emit BalanceUnlocked(msg.sender, _refundableBalance);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalCreated(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        knownProposalIds.add(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalEnded(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_proposalId);\n        knownProposalIds.remove(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function setPluginAddress(ILockToGovernBase _newPluginAddress) public virtual {\n        if (address(plugin) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToGovernBase).interfaceId)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            settings.pluginMode == PluginMode.Voting\n                && !IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToVote).interfaceId)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        plugin = _newPluginAddress;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _incomingTokenBalance() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _lock(uint256 _amount) internal virtual {\n        if (_amount == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _doLockTransfer(_amount);\n\n        lockedBalances[msg.sender] += _amount;\n        emit BalanceLocked(msg.sender, _amount);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _doLockTransfer(uint256 _amount) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual;\n\n    function _vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) internal virtual {\n        uint256 _currentVotingPower = getLockedBalance(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(plugin)).vote(_proposalId, msg.sender, _voteOption, _currentVotingPower);\n    }\n\n    function _withdrawActiveVotingPower() internal virtual {\n        uint256 _proposalCount = knownProposalIds.length();\n        for (uint256 _i; _i < _proposalCount;) {\n            uint256 _proposalId = knownProposalIds.at(_i);\n            if (!plugin.isProposalOpen(_proposalId)) {\n                knownProposalIds.remove(_proposalId);\n                _proposalCount = knownProposalIds.length();\n\n                // Were we at the last element?\n                if (_i == _proposalCount) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (plugin.usedVotingPower(_proposalId, msg.sender) > 0) {\n                ILockToVote(address(plugin)).clearVote(_proposalId, msg.sender);\n            }\n\n            unchecked {\n                _i++;\n            }\n        }\n    }\n}\n",
        "relevance": "Provides lockAndVote() function (lines 84-101) that allows locking and voting in one call, enabling the flashloan attack vector."
      },
      {
        "path": "src/base/MajorityVotingBase.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/* solhint-disable max-line-length */\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {ProposalUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/ProposalUpgradeable.sol\";\nimport {RATIO_BASE, RatioOutOfBounds} from \"@aragon/osx-commons-contracts/src/utils/math/Ratio.sol\";\nimport {PluginUUPSUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {MetadataExtensionUpgradeable} from\n    \"@aragon/osx-commons-contracts/src/utils/metadata/MetadataExtensionUpgradeable.sol\";\nimport {_applyRatioCeiled} from \"@aragon/osx-commons-contracts/src/utils/math/Ratio.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\n\n/* solhint-enable max-line-length */\n\n/// @title MajorityVotingBase\n/// @author Aragon X - 2022-2025\n/// @notice The abstract implementation of majority voting plugins.\n///\n/// ### Parameterization\n///\n/// We define two parameters\n/// $$\\texttt{support} = \\frac{N_\\text{yes}}{N_\\text{yes} + N_\\text{no}} \\in [0,1]$$\n/// and\n/// $$\\texttt{participation} = \\frac{N_\\text{yes} + N_\\text{no} + N_\\text{abstain}}{N_\\text{total}} \\in [0,1],$$\n/// where $N_\\text{yes}$, $N_\\text{no}$, and $N_\\text{abstain}$ are the yes, no, and abstain votes that have been\n/// cast and $N_\\text{total}$ is the total voting power available at proposal creation time.\n///\n/// #### Limit Values: Support Threshold & Minimum Participation\n///\n/// Two limit values are associated with these parameters and decide if a proposal execution should be possible:\n/// $\\texttt{supportThresholdRatio} \\in [0,1)$ and $\\texttt{minParticipationRatio} \\in [0,1]$.\n///\n/// For threshold values, $>$ comparison is used. This **does not** include the threshold value.\n/// E.g., for $\\texttt{supportThresholdRatio} = 50\\%$,\n/// the criterion is fulfilled if there is at least one more yes than no votes ($N_\\text{yes} = N_\\text{no} + 1$).\n/// For minimum values, $\\ge{}$ comparison is used. This **does** include the minimum participation value.\n/// E.g., for $\\texttt{minParticipationRatio} = 40\\%$ and $N_\\text{total} = 10$,\n/// the criterion is fulfilled if 4 out of 10 votes were casted.\n///\n/// Majority voting implies that the support threshold is set with\n/// $$\\texttt{supportThresholdRatio} \\ge 50\\% .$$\n/// However, this is not enforced by the contract code and developers can make unsafe parameters and\n/// only the frontend will warn about bad parameter settings.\n///\n/// ### Execution Criteria\n///\n/// After the vote is closed, two criteria decide if the proposal passes.\n///\n/// #### The Support Criterion\n///\n/// For a proposal to pass, the required ratio of yes and no votes must be met:\n/// $$(1- \\texttt{supportThresholdRatio}) \\cdot N_\\text{yes} > \\texttt{supportThresholdRatio} \\cdot N_\\text{no}.$$\n/// Note, that the inequality yields the simple majority voting condition for $\\texttt{supportThresholdRatio}=\\frac{1}{2}$.\n///\n/// #### The Participation Criterion\n///\n/// For a proposal to pass, the minimum voting power must have been cast:\n/// $$N_\\text{yes} + N_\\text{no} + N_\\text{abstain} \\ge \\texttt{minVotingPower},$$\n/// where $\\texttt{minVotingPower} = \\texttt{minParticipationRatio} \\cdot N_\\text{total}$.\n///\n/// ### Vote Replacement\n///\n/// The contract allows votes to be replaced. Voters can vote multiple times\n/// and only the latest voteOption is tallied.\n///\n/// ### Early Execution\n///\n/// This contract allows a proposal to be executed early,\n/// iff the vote outcome cannot change anymore by more people voting.\n/// Accordingly, vote replacement and early execution are mutually exclusive options.\n/// The outcome cannot change anymore\n/// iff the support threshold is met even if all remaining votes are no votes.\n/// We call this number the worst-case number of no votes and define it as\n///\n/// $$N_\\text{no, worst-case} = N_\\text{no} + \\texttt{remainingVotes}$$\n///\n/// where\n///\n/// $$\\texttt{remainingVotes} =\n/// N_\\text{total}-\\underbrace{(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})}_{\\text{turnout}}.$$\n///\n/// We can use this quantity to calculate the worst-case support that would be obtained\n/// if all remaining votes are casted with no:\n///\n/// $$\n/// \\begin{align*}\n///   \\texttt{worstCaseSupport}\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no, worst-case})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no} + \\texttt{remainingVotes})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} +  N_\\text{no} + N_\\text{total}\n///      - (N_\\text{yes} + N_\\text{no} + N_\\text{abstain})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{total} - N_\\text{abstain}}\n/// \\end{align*}\n/// $$\n///\n/// In analogy, we can modify [the support criterion](#the-support-criterion)\n/// from above to allow for early execution:\n///\n/// $$\n/// \\begin{align*}\n///   (1 - \\texttt{supportThresholdRatio}) \\cdot N_\\text{yes}\n///   &> \\texttt{supportThresholdRatio} \\cdot  N_\\text{no, worst-case} \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{no} + \\texttt{remainingVotes}) \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{no}\n///     + N_\\text{total}-(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})) \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{total} - N_\\text{yes} - N_\\text{abstain})\n/// \\end{align*}\n/// $$\n///\n/// Accordingly, early execution is possible when the vote is open,\n///     the modified support criterion, and the particicpation criterion are met.\n/// @dev This contract implements the `IMajorityVoting` interface.\n/// @custom:security-contact sirt@aragon.org\nabstract contract MajorityVotingBase is\n    IMajorityVoting,\n    Initializable,\n    ERC165Upgradeable,\n    MetadataExtensionUpgradeable,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The different voting modes available.\n    /// @param Standard In standard mode, early execution and vote replacement are disabled.\n    /// @param EarlyExecution In early execution mode, a proposal can be executed\n    ///     early before the end date if the vote outcome cannot mathematically change by more voters voting.\n    /// @param VoteReplacement In vote replacement mode, voters can change their vote\n    ///     multiple times and only the latest vote option is tallied.\n    enum VotingMode {\n        Standard,\n        EarlyExecution,\n        VoteReplacement\n    }\n\n    /// @notice A container for the majority voting settings that will be applied as parameters on proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    ///     In standard mode (0), early execution and vote replacement are disabled.\n    ///     In early execution mode (1), a proposal can be executed early before the end date\n    ///     if the vote outcome cannot mathematically change by more voters voting.\n    ///     In vote replacement mode (2), voters can change their vote multiple times\n    ///     and only the latest vote option is tallied.\n    /// @param supportThresholdRatio The support threshold ratio.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minParticipationRatio The minimum participation ratio.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minApprovalRatio The minimum ratio of approvals the proposal needs to succeed.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param proposalDuration The duration of the proposal vote in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    struct VotingSettings {\n        VotingMode votingMode;\n        uint32 supportThresholdRatio;\n        uint32 minParticipationRatio;\n        uint32 minApprovalRatio;\n        uint64 proposalDuration;\n        uint256 minProposerVotingPower;\n    }\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param parameters The proposal parameters at the time of the proposal creation.\n    /// @param tally The vote tally of the proposal.\n    /// @param votes The voting power cast by each voter.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    /// @param targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    struct Proposal {\n        bool executed;\n        ProposalParameters parameters;\n        Tally tally;\n        mapping(address => VoteEntry) votes;\n        Action[] actions;\n        uint256 allowFailureMap;\n        TargetConfig targetConfig;\n    }\n\n    /// @notice A container for the proposal parameters at the time of proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThresholdRatio The support threshold ratio.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param startDate The start date of the proposal vote.\n    /// @param endDate The end date of the proposal vote.\n    /// @param minParticipationRatio The minimum voting power ratio needed for a proposal to reach minimum participation.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minApprovalRatio Minimum ratio of allocated YES votes.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    struct ProposalParameters {\n        VotingMode votingMode;\n        uint32 supportThresholdRatio;\n        uint64 startDate;\n        uint64 endDate;\n        uint256 minParticipationRatio;\n        uint256 minApprovalRatio;\n    }\n\n    /// @notice A container for the proposal vote tally.\n    /// @param abstain The number of abstain votes casted.\n    /// @param yes The number of yes votes casted.\n    /// @param no The number of no votes casted.\n    struct Tally {\n        uint256 abstain;\n        uint256 yes;\n        uint256 no;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MAJORITY_VOTING_BASE_INTERFACE_ID = this.proposalDuration.selector\n        ^ this.minProposerVotingPower.selector ^ this.votingMode.selector ^ this.currentTokenSupply.selector\n        ^ this.getProposal.selector ^ this.updateVotingSettings.selector;\n\n    /// @notice The ID of the permission required to call the `updateVotingSettings` function.\n    bytes32 public constant UPDATE_SETTINGS_PERMISSION_ID = keccak256(\"UPDATE_SETTINGS_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PROPOSAL_PERMISSION_ID = keccak256(\"EXECUTE_PROPOSAL_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    // solhint-disable-next-line named-parameters-mapping\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The struct storing the voting settings.\n    VotingSettings private votingSettings;\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown if the proposal duration value is out of bounds (less than one hour or greater than 1 year).\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error ProposalDurationOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown when a proposal doesn't exist.\n    /// @param proposalId The ID of the proposal which doesn't exist.\n    error NonexistentProposal(uint256 proposalId);\n\n    /// @notice Thrown if an account is not allowed to cast a vote. This can be because the vote\n    /// - has not started,\n    /// - has ended,\n    /// - was executed, or\n    /// - the account doesn't have voting powers.\n    /// @param proposalId The ID of the proposal.\n    /// @param account The address of the _account.\n    error VoteCastForbidden(uint256 proposalId, address account);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Thrown if the proposal with same actions and metadata already exists.\n    /// @param proposalId The id of the proposal.\n    error ProposalAlreadyExists(uint256 proposalId);\n\n    /// @notice Emitted when the voting settings are updated.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThresholdRatio The support threshold ratio.\n    /// @param minParticipationRatio The minimum participation ratio.\n    /// @param minApprovalRatio The minimum ratio of yes votes over the token supply needed for the proposal advance.\n    /// @param proposalDuration The duration of the proposal in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    event VotingSettingsUpdated(\n        VotingMode votingMode,\n        uint32 supportThresholdRatio,\n        uint32 minParticipationRatio,\n        uint32 minApprovalRatio,\n        uint64 proposalDuration,\n        uint256 minProposerVotingPower\n    );\n\n    /// @notice Initializes the component to be used by inheriting contracts.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    // solhint-disable-next-line func-name-mixedcase\n    function __MajorityVotingBase_init(\n        IDAO _dao,\n        VotingSettings calldata _votingSettings,\n        TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) internal onlyInitializing {\n        __PluginUUPSUpgradeable_init(_dao);\n        _updateVotingSettings(_votingSettings);\n        _setTargetConfig(_targetConfig);\n        _setMetadata(_pluginMetadata);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, MetadataExtensionUpgradeable, PluginUUPSUpgradeable, ProposalUpgradeable)\n        returns (bool)\n    {\n        return _interfaceId == MAJORITY_VOTING_BASE_INTERFACE_ID || _interfaceId == type(IMajorityVoting).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `EXECUTE_PROPOSAL_PERMISSION_ID` permission.\n    function execute(uint256 _proposalId)\n        public\n        virtual\n        override(IMajorityVoting, IProposal)\n        auth(EXECUTE_PROPOSAL_PERMISSION_ID)\n    {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function getVote(uint256 _proposalId, address _voter) public view virtual returns (VoteEntry memory) {\n        return (proposals[_proposalId].votes[_voter]);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canExecute(uint256 _proposalId) public view virtual override(IMajorityVoting, IProposal) returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _canExecute(_proposalId);\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function hasSucceeded(uint256 _proposalId) public view virtual returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _hasSucceeded(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The code below implements the formula of the support criterion explained in the top of this file.\n        // `(1 - supportThresholdRatio) * N_yes > supportThresholdRatio *  N_no`\n        return (RATIO_BASE - proposal_.parameters.supportThresholdRatio) * proposal_.tally.yes\n            > proposal_.parameters.supportThresholdRatio * proposal_.tally.no;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReachedEarly(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        uint256 noVotesWorstCase = currentTokenSupply() - proposal_.tally.yes - proposal_.tally.abstain;\n\n        // The code below implements the formula of the\n        // early execution support criterion explained in the top of this file.\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no,worst-case`\n        return (RATIO_BASE - proposal_.parameters.supportThresholdRatio) * proposal_.tally.yes\n            > proposal_.parameters.supportThresholdRatio * noVotesWorstCase;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isMinVotingPowerReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        uint256 _minVotingPower = _applyRatioCeiled(currentTokenSupply(), proposal_.parameters.minParticipationRatio);\n\n        // The code below implements the formula of the\n        // participation criterion explained in the top of this file.\n        // `N_yes + N_no + N_abstain >= minVotingPower = minParticipationRatio * N_total`\n        return proposal_.tally.yes + proposal_.tally.no + proposal_.tally.abstain >= _minVotingPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isMinApprovalReached(uint256 _proposalId) public view virtual returns (bool) {\n        uint256 _minApprovalPower =\n            _applyRatioCeiled(currentTokenSupply(), proposals[_proposalId].parameters.minApprovalRatio);\n        return proposals[_proposalId].tally.yes >= _minApprovalPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function supportThresholdRatio() public view virtual returns (uint32) {\n        return votingSettings.supportThresholdRatio;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function minParticipationRatio() public view virtual returns (uint32) {\n        return votingSettings.minParticipationRatio;\n    }\n\n    /// @notice Returns the proposal duration parameter stored in the voting settings.\n    /// @return The proposal duration in seconds.\n    function proposalDuration() public view virtual returns (uint64) {\n        return votingSettings.proposalDuration;\n    }\n\n    /// @notice Returns the minimum voting power required to create a proposal stored in the voting settings.\n    /// @return The minimum voting power required to create a proposal.\n    function minProposerVotingPower() public view virtual returns (uint256) {\n        return votingSettings.minProposerVotingPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function minApprovalRatio() public view virtual returns (uint256) {\n        return votingSettings.minApprovalRatio;\n    }\n\n    /// @notice Returns the vote mode stored in the voting settings.\n    /// @return The vote mode parameter.\n    function votingMode() public view virtual returns (VotingMode) {\n        return votingSettings.votingMode;\n    }\n\n    /// @notice Returns the current voting settings\n    function getVotingSettings() public view virtual returns (VotingSettings memory) {\n        return votingSettings;\n    }\n\n    /// @notice Returns the current token supply.\n    /// @return The token supply.\n    function currentTokenSupply() public view virtual returns (uint256);\n\n    /// @notice Returns all information for a proposal by its ID.\n    /// @param _proposalId The ID of the proposal.\n    /// @return open Whether the proposal is open or not.\n    /// @return executed Whether the proposal is executed or not.\n    /// @return parameters The parameters of the proposal.\n    /// @return tally The current tally of the proposal.\n    /// @return actions The actions to be executed to the `target` contract address.\n    /// @return allowFailureMap The bit map representations of which actions are allowed to revert so tx still succeeds.\n    /// @return targetConfig Execution configuration, applied to the proposal when it was created. Added in build 3.\n    function getProposal(uint256 _proposalId)\n        public\n        view\n        virtual\n        returns (\n            bool open,\n            bool executed,\n            ProposalParameters memory parameters,\n            Tally memory tally,\n            Action[] memory actions,\n            uint256 allowFailureMap,\n            TargetConfig memory targetConfig\n        )\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        open = _isProposalOpen(proposal_);\n        executed = proposal_.executed;\n        parameters = proposal_.parameters;\n        tally = proposal_.tally;\n        actions = proposal_.actions;\n        allowFailureMap = proposal_.allowFailureMap;\n        targetConfig = proposal_.targetConfig;\n    }\n\n    /// @notice Updates the voting settings.\n    /// @dev Requires the `UPDATE_SETTINGS_PERMISSION_ID` permission.\n    /// @param _votingSettings The new voting settings.\n    function updateVotingSettings(VotingSettings calldata _votingSettings)\n        external\n        virtual\n        auth(UPDATE_SETTINGS_PERMISSION_ID)\n    {\n        _updateVotingSettings(_votingSettings);\n    }\n\n    /// @notice Internal function to execute a proposal. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    function _execute(uint256 _proposalId) internal virtual {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        proposal_.executed = true;\n\n        _execute(\n            proposal_.targetConfig.target,\n            bytes32(_proposalId),\n            proposal_.actions,\n            proposal_.allowFailureMap,\n            proposal_.targetConfig.operation\n        );\n\n        emit ProposalExecuted(_proposalId);\n    }\n\n    /// @notice An internal function that checks if the proposal succeeded or not.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the proposal succeeded depending on the thresholds and voting modes.\n    function _hasSucceeded(uint256 _proposalId) internal view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Support threshold, depending on the status and mode\n        if (_isProposalOpen(proposal_)) {\n            // If the proposal is still open and the voting mode is not EarlyExecution,\n            // success cannot be determined until the voting period ends.\n            if (proposal_.parameters.votingMode != VotingMode.EarlyExecution) {\n                return false;\n            }\n            // For EarlyExecution, check if the support threshold\n            // has been reached early to determine success while proposal is still open.\n            else if (!isSupportThresholdReachedEarly(_proposalId)) {\n                return false;\n            }\n        } else {\n            // Normal execution\n            if (!isSupportThresholdReached(_proposalId)) {\n                return false;\n            }\n        }\n\n        // Check the rest\n        if (!isMinVotingPowerReached(_proposalId)) {\n            return false;\n        } else if (!isMinApprovalReached(_proposalId)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal can be executed. It assumes the queried proposal exists.\n    /// @dev Threshold and minimal values are compared with `>` and `>=` comparators, respectively.\n    /// @param _proposalId The ID of the proposal.\n    /// @return True if the proposal can be executed, false otherwise.\n    function _canExecute(uint256 _proposalId) internal view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Verify that the vote has not been executed already.\n        if (proposal_.executed) {\n            return false;\n        } else if (!_hasSucceeded(_proposalId)) {\n            return false;\n        }\n        /// @dev Handling the case of Standard and VoteReplacement voting modes\n        /// @dev Enforce waiting until endDate, which is not covered by _hasSucceeded()\n        else if (\n            proposal_.parameters.votingMode != VotingMode.EarlyExecution\n                && block.timestamp.toUint64() < proposal_.parameters.endDate\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal is still open.\n    /// @param proposal_ The proposal struct.\n    /// @return True if the proposal is open, false otherwise.\n    function _isProposalOpen(Proposal storage proposal_) internal view virtual returns (bool) {\n        uint64 currentTime = block.timestamp.toUint64();\n\n        return proposal_.parameters.startDate <= currentTime && currentTime < proposal_.parameters.endDate\n            && !proposal_.executed;\n    }\n\n    /// @notice Internal function to update the plugin-wide proposal settings.\n    /// @param _votingSettings The voting settings to be validated and updated.\n    function _updateVotingSettings(VotingSettings calldata _votingSettings) internal virtual {\n        // Require the support threshold value to be in the interval [0, 10^6-1],\n        // because `>` comparison is used in the support criterion and >100% could never be reached.\n        if (_votingSettings.supportThresholdRatio > RATIO_BASE - 1) {\n            revert RatioOutOfBounds({limit: RATIO_BASE - 1, actual: _votingSettings.supportThresholdRatio});\n        }\n        // Require the minimum participation value to be in the interval [0, 10^6],\n        // because `>=` comparison is used in the participation criterion.\n        else if (_votingSettings.minParticipationRatio > RATIO_BASE) {\n            revert RatioOutOfBounds({limit: RATIO_BASE, actual: _votingSettings.minParticipationRatio});\n        } else if (_votingSettings.proposalDuration < 60 minutes) {\n            revert ProposalDurationOutOfBounds({limit: 60 minutes, actual: _votingSettings.proposalDuration});\n        } else if (_votingSettings.proposalDuration > 365 days) {\n            revert ProposalDurationOutOfBounds({limit: 365 days, actual: _votingSettings.proposalDuration});\n        }\n        // Require the minimum approval value to be in the interval [0, 10^6],\n        // because `>=` comparison is used in the participation criterion.\n        else if (_votingSettings.minApprovalRatio > RATIO_BASE) {\n            revert RatioOutOfBounds({limit: RATIO_BASE, actual: _votingSettings.minApprovalRatio});\n        }\n\n        votingSettings = _votingSettings;\n\n        emit VotingSettingsUpdated({\n            votingMode: _votingSettings.votingMode,\n            supportThresholdRatio: _votingSettings.supportThresholdRatio,\n            minParticipationRatio: _votingSettings.minParticipationRatio,\n            proposalDuration: _votingSettings.proposalDuration,\n            minProposerVotingPower: _votingSettings.minProposerVotingPower,\n            minApprovalRatio: _votingSettings.minApprovalRatio\n        });\n    }\n\n    /// @notice Checks if proposal exists or not.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if proposal exists, otherwise false.\n    function _proposalExists(uint256 _proposalId) internal view returns (bool) {\n        return proposals[_proposalId].parameters.startDate != 0;\n    }\n\n    /// @notice Validates and returns the proposal dates.\n    /// @param _start The start date of the proposal.\n    ///     If 0, the current timestamp is used and the vote starts immediately.\n    /// @param _end The end date of the proposal. If 0, `_start + proposalDuration` is used.\n    /// @return startDate The validated start date of the proposal.\n    /// @return endDate The validated end date of the proposal.\n    function _validateProposalDates(uint64 _start, uint64 _end)\n        internal\n        view\n        virtual\n        returns (uint64 startDate, uint64 endDate)\n    {\n        uint64 currentTimestamp = block.timestamp.toUint64();\n\n        if (_start == 0) {\n            startDate = currentTimestamp;\n        } else {\n            startDate = _start;\n\n            if (startDate < currentTimestamp) {\n                revert DateOutOfBounds({limit: currentTimestamp, actual: startDate});\n            }\n        }\n        // Since `proposalDuration` is limited to 1 year,\n        // `startDate + proposalDuration` can only overflow if the `startDate` is after `type(uint64).max - proposalDuration`.\n        // In this case, the proposal creation will revert and another date can be picked.\n        uint64 earliestEndDate = startDate + votingSettings.proposalDuration;\n\n        if (_end == 0) {\n            endDate = earliestEndDate;\n        } else {\n            endDate = _end;\n\n            if (endDate < earliestEndDate) {\n                revert DateOutOfBounds({limit: earliestEndDate, actual: endDate});\n            }\n        }\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}\n",
        "relevance": "Contains VotingMode enum (lines 139-143) including EarlyExecution mode which is the vulnerable configuration. Also contains _hasSucceeded() which checks isSupportThresholdReachedEarly()."
      }
    ],
    "call_flow": "Attacker.flashloan() -> LockManager.lockAndVote() -> LockToVotePlugin.vote() -> lines 205-207: if EarlyExecution mode -> _attemptEarlyExecution() -> _canExecute() -> _execute() -> LockManager.unlock() -> repay flashloan",
    "context_hint": "When EarlyExecution voting mode is enabled (VotingMode enum value 1), proposals can be executed as soon as they mathematically cannot fail. The vote() function at lines 205-207 calls _attemptEarlyExecution() which can execute the proposal in the same transaction as the vote. An attacker can flashloan tokens, lock them, vote YES to trigger early execution, then unlock and repay - all atomically.",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_aragon-lock-to-vote_M01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "M-01",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "medium",
    "vulnerability_type": "unchecked_return",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Lack of SafeERC20 can inflate user balance",
    "finding_description": "If the erc20Token configured within LockManagerERC20 is a token that does not revert due to insufficient approved funds, the msg.sender can inflate their lockedBalances[msg.sender] by an arbitrary _amount without actually sending any token. The vulnerable code is at lines 35-37 (_doLockTransfer) and lines 40-42 (_doUnlockTransfer) which use raw transferFrom() and transfer() instead of safeTransferFrom() and safeTransfer(). Some ERC20 tokens like BAT, HT, cUSDC, ZRX do not revert when a transfer fails but instead return false.",
    "attack_scenario": "1. Attacker specifies an arbitrary _amount without having ever given any approval.\n2. erc20Token.transferFrom() returns false but doesn't revert.\n3. The return value is not checked.\n4. lockedBalances[msg.sender] += _amount still executes.\n5. Attacker gains unlimited voting power.\n6. Attacker can drain the LockManagerERC20 of funds deposited by other users.",
    "fix_description": "Use SafeERC20 across all contracts that interact with an ERC20 token. Replace erc20Token.transferFrom() with erc20Token.safeTransferFrom() and erc20Token.transfer() with erc20Token.safeTransfer().",
    "primary_file": {
      "path": "src/LockManagerERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable erc20Token;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _settings, IERC20 _token) LockManagerBase(_settings) {\n        erc20Token = _token;\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function token() public view virtual returns (address _token) {\n        return address(erc20Token);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _incomingTokenBalance() internal view virtual override returns (uint256) {\n        return erc20Token.allowance(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _doLockTransfer(uint256 _amount) internal virtual override {\n        erc20Token.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual override {\n        erc20Token.transfer(_recipient, _amount);\n    }\n}\n",
      "vulnerable_lines": [
        35,
        36,
        37,
        40,
        41,
        42
      ],
      "vulnerable_functions": [
        "_doLockTransfer",
        "_doUnlockTransfer"
      ]
    },
    "context_files": [],
    "call_flow": "Attacker.lock(arbitraryAmount) -> LockManagerBase._lock() -> LockManagerERC20._doLockTransfer() -> erc20Token.transferFrom() returns false (not checked) -> lockedBalances[attacker] += arbitraryAmount",
    "context_hint": "LockManagerERC20._doLockTransfer() at line 36 uses 'erc20Token.transferFrom(msg.sender, address(this), _amount)' without SafeERC20. Some tokens don't revert on failed transfers. Without checking the return value, an attacker can 'lock' tokens they don't have, inflating voting power and draining real tokens.",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_aragon-lock-to-vote_M02",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "M-02",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 1,
    "context_level": "single_file",
    "finding_title": "Lock fails for unlimited approvals",
    "finding_description": "The lock() function intends to lock the user's entire approved balance, but this will fail for the most common case: Most users give contracts they interact with an unlimited allowance by setting it to type(uint256).max. The _incomingTokenBalance() function at line 32 returns just 'erc20Token.allowance(msg.sender, address(this))' which would be type(uint256).max for unlimited approvals. The lock() function then attempts to transfer this impossible amount.",
    "attack_scenario": "1. User approves LockManager with unlimited allowance: approve(lockManager, type(uint256).max).\n2. User calls lock() without specifying an amount.\n3. _incomingTokenBalance() returns type(uint256).max.\n4. _doLockTransfer attempts to transfer type(uint256).max tokens.\n5. Transaction reverts because user doesn't have that many tokens.\n6. User cannot use the standard lock() function.",
    "fix_description": "Have _incomingTokenBalance() return either the actual balance or the allowance depending on whichever is smallest: 'return (allowance >= balance) ? balance : allowance;'",
    "primary_file": {
      "path": "src/LockManagerERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable erc20Token;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _settings, IERC20 _token) LockManagerBase(_settings) {\n        erc20Token = _token;\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function token() public view virtual returns (address _token) {\n        return address(erc20Token);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _incomingTokenBalance() internal view virtual override returns (uint256) {\n        return erc20Token.allowance(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _doLockTransfer(uint256 _amount) internal virtual override {\n        erc20Token.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual override {\n        erc20Token.transfer(_recipient, _amount);\n    }\n}\n",
      "vulnerable_lines": [
        31,
        32,
        33
      ],
      "vulnerable_functions": [
        "_incomingTokenBalance"
      ]
    },
    "context_files": [
      {
        "path": "src/base/LockManagerBase.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public settings;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public plugin;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private lockedBalances;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal knownProposalIds;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address voter, uint256 amount);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address voter, uint256 amount);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 proposalId);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _settings) {\n        settings.pluginMode = _settings.pluginMode;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function knownProposalIdAt(uint256 _index) public view virtual returns (uint256) {\n        return knownProposalIds.at(_index);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function knownProposalIdsLength() public view virtual returns (uint256) {\n        return knownProposalIds.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function lock() public virtual {\n        _lock(_incomingTokenBalance());\n    }\n\n    /// @inheritdoc ILockManager\n    function lock(uint256 _amount) public virtual {\n        _lock(_amount);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_incomingTokenBalance());\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption, uint256 _amount) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_amount);\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function getLockedBalance(address _account) public view virtual returns (uint256) {\n        return lockedBalances[_account];\n    }\n\n    /// @inheritdoc ILockManager\n    function canVote(uint256 _proposalId, address _voter, IMajorityVoting.VoteOption _voteOption)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(plugin)).canVote(_proposalId, _voter, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function unlock() public virtual {\n        uint256 _refundableBalance = getLockedBalance(msg.sender);\n        if (_refundableBalance == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _withdrawActiveVotingPower();\n\n        // All votes clear\n\n        lockedBalances[msg.sender] = 0;\n\n        // Withdraw\n        _doUnlockTransfer(msg.sender, _refundableBalance);\n        emit BalanceUnlocked(msg.sender, _refundableBalance);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalCreated(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        knownProposalIds.add(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalEnded(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_proposalId);\n        knownProposalIds.remove(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function setPluginAddress(ILockToGovernBase _newPluginAddress) public virtual {\n        if (address(plugin) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToGovernBase).interfaceId)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            settings.pluginMode == PluginMode.Voting\n                && !IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToVote).interfaceId)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        plugin = _newPluginAddress;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _incomingTokenBalance() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _lock(uint256 _amount) internal virtual {\n        if (_amount == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _doLockTransfer(_amount);\n\n        lockedBalances[msg.sender] += _amount;\n        emit BalanceLocked(msg.sender, _amount);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _doLockTransfer(uint256 _amount) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual;\n\n    function _vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) internal virtual {\n        uint256 _currentVotingPower = getLockedBalance(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(plugin)).vote(_proposalId, msg.sender, _voteOption, _currentVotingPower);\n    }\n\n    function _withdrawActiveVotingPower() internal virtual {\n        uint256 _proposalCount = knownProposalIds.length();\n        for (uint256 _i; _i < _proposalCount;) {\n            uint256 _proposalId = knownProposalIds.at(_i);\n            if (!plugin.isProposalOpen(_proposalId)) {\n                knownProposalIds.remove(_proposalId);\n                _proposalCount = knownProposalIds.length();\n\n                // Were we at the last element?\n                if (_i == _proposalCount) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (plugin.usedVotingPower(_proposalId, msg.sender) > 0) {\n                ILockToVote(address(plugin)).clearVote(_proposalId, msg.sender);\n            }\n\n            unchecked {\n                _i++;\n            }\n        }\n    }\n}\n",
        "relevance": "Contains the lock() function at lines 74-76 that calls _incomingTokenBalance() to determine how many tokens to lock."
      }
    ],
    "call_flow": "User.approve(LockManager, type(uint256).max) -> User.lock() -> LockManagerBase._lock(_incomingTokenBalance()) -> LockManagerERC20._incomingTokenBalance() returns type(uint256).max -> _doLockTransfer(type(uint256).max) -> REVERTS",
    "context_hint": "The _incomingTokenBalance() function at line 32 just returns 'erc20Token.allowance(msg.sender, address(this))'. For unlimited approvals (type(uint256).max), this returns an impossibly large number. When lock() tries to transfer this amount, it fails. The fix is to return min(allowance, balance).",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_aragon-lock-to-vote_M03",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "M-03",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "multi_file",
    "finding_title": "Misuse of isProposalOpen() function",
    "finding_description": "The isProposalOpen() function returns true if a proposal is open for voting. It returns false if it's too late OR too early for voting. But in _withdrawActiveVotingPower() at line 225, it was being used as an 'isProposalStillOpen()' function, forgetting that it will also be false when the proposal hasn't started yet. This means proposals with future start dates get incorrectly removed from knownProposalIds tracking.",
    "attack_scenario": "1. A proposal is created with a future start date (e.g., starts in 1 week).\n2. User calls unlock() before the proposal starts.\n3. _withdrawActiveVotingPower() is called at line 135.\n4. Line 225: plugin.isProposalOpen(_proposalId) returns false (proposal hasn't started).\n5. Line 226: knownProposalIds.remove(_proposalId) - proposal removed from tracking.\n6. Proposal starts a week later, user votes.\n7. User calls unlock() again - vote isn't cleared because proposal isn't tracked.\n8. User withdraws tokens while still having active votes.",
    "fix_description": "Create and use an isProposalEnded() function specifically for this use case. It should return true only if the proposal has actually ended (endDate passed or executed), not just because it hasn't started.",
    "primary_file": {
      "path": "src/base/LockManagerBase.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public settings;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public plugin;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private lockedBalances;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal knownProposalIds;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address voter, uint256 amount);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address voter, uint256 amount);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 proposalId);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _settings) {\n        settings.pluginMode = _settings.pluginMode;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function knownProposalIdAt(uint256 _index) public view virtual returns (uint256) {\n        return knownProposalIds.at(_index);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function knownProposalIdsLength() public view virtual returns (uint256) {\n        return knownProposalIds.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function lock() public virtual {\n        _lock(_incomingTokenBalance());\n    }\n\n    /// @inheritdoc ILockManager\n    function lock(uint256 _amount) public virtual {\n        _lock(_amount);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_incomingTokenBalance());\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption, uint256 _amount) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_amount);\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function getLockedBalance(address _account) public view virtual returns (uint256) {\n        return lockedBalances[_account];\n    }\n\n    /// @inheritdoc ILockManager\n    function canVote(uint256 _proposalId, address _voter, IMajorityVoting.VoteOption _voteOption)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(plugin)).canVote(_proposalId, _voter, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function unlock() public virtual {\n        uint256 _refundableBalance = getLockedBalance(msg.sender);\n        if (_refundableBalance == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _withdrawActiveVotingPower();\n\n        // All votes clear\n\n        lockedBalances[msg.sender] = 0;\n\n        // Withdraw\n        _doUnlockTransfer(msg.sender, _refundableBalance);\n        emit BalanceUnlocked(msg.sender, _refundableBalance);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalCreated(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        knownProposalIds.add(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalEnded(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_proposalId);\n        knownProposalIds.remove(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function setPluginAddress(ILockToGovernBase _newPluginAddress) public virtual {\n        if (address(plugin) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToGovernBase).interfaceId)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            settings.pluginMode == PluginMode.Voting\n                && !IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToVote).interfaceId)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        plugin = _newPluginAddress;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _incomingTokenBalance() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _lock(uint256 _amount) internal virtual {\n        if (_amount == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _doLockTransfer(_amount);\n\n        lockedBalances[msg.sender] += _amount;\n        emit BalanceLocked(msg.sender, _amount);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _doLockTransfer(uint256 _amount) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual;\n\n    function _vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) internal virtual {\n        uint256 _currentVotingPower = getLockedBalance(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(plugin)).vote(_proposalId, msg.sender, _voteOption, _currentVotingPower);\n    }\n\n    function _withdrawActiveVotingPower() internal virtual {\n        uint256 _proposalCount = knownProposalIds.length();\n        for (uint256 _i; _i < _proposalCount;) {\n            uint256 _proposalId = knownProposalIds.at(_i);\n            if (!plugin.isProposalOpen(_proposalId)) {\n                knownProposalIds.remove(_proposalId);\n                _proposalCount = knownProposalIds.length();\n\n                // Were we at the last element?\n                if (_i == _proposalCount) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (plugin.usedVotingPower(_proposalId, msg.sender) > 0) {\n                ILockToVote(address(plugin)).clearVote(_proposalId, msg.sender);\n            }\n\n            unchecked {\n                _i++;\n            }\n        }\n    }\n}\n",
      "vulnerable_lines": [
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246
      ],
      "vulnerable_functions": [
        "_withdrawActiveVotingPower"
      ]
    },
    "context_files": [
      {
        "path": "src/base/MajorityVotingBase.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/* solhint-disable max-line-length */\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {ProposalUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/ProposalUpgradeable.sol\";\nimport {RATIO_BASE, RatioOutOfBounds} from \"@aragon/osx-commons-contracts/src/utils/math/Ratio.sol\";\nimport {PluginUUPSUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {MetadataExtensionUpgradeable} from\n    \"@aragon/osx-commons-contracts/src/utils/metadata/MetadataExtensionUpgradeable.sol\";\nimport {_applyRatioCeiled} from \"@aragon/osx-commons-contracts/src/utils/math/Ratio.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\n\n/* solhint-enable max-line-length */\n\n/// @title MajorityVotingBase\n/// @author Aragon X - 2022-2025\n/// @notice The abstract implementation of majority voting plugins.\n///\n/// ### Parameterization\n///\n/// We define two parameters\n/// $$\\texttt{support} = \\frac{N_\\text{yes}}{N_\\text{yes} + N_\\text{no}} \\in [0,1]$$\n/// and\n/// $$\\texttt{participation} = \\frac{N_\\text{yes} + N_\\text{no} + N_\\text{abstain}}{N_\\text{total}} \\in [0,1],$$\n/// where $N_\\text{yes}$, $N_\\text{no}$, and $N_\\text{abstain}$ are the yes, no, and abstain votes that have been\n/// cast and $N_\\text{total}$ is the total voting power available at proposal creation time.\n///\n/// #### Limit Values: Support Threshold & Minimum Participation\n///\n/// Two limit values are associated with these parameters and decide if a proposal execution should be possible:\n/// $\\texttt{supportThresholdRatio} \\in [0,1)$ and $\\texttt{minParticipationRatio} \\in [0,1]$.\n///\n/// For threshold values, $>$ comparison is used. This **does not** include the threshold value.\n/// E.g., for $\\texttt{supportThresholdRatio} = 50\\%$,\n/// the criterion is fulfilled if there is at least one more yes than no votes ($N_\\text{yes} = N_\\text{no} + 1$).\n/// For minimum values, $\\ge{}$ comparison is used. This **does** include the minimum participation value.\n/// E.g., for $\\texttt{minParticipationRatio} = 40\\%$ and $N_\\text{total} = 10$,\n/// the criterion is fulfilled if 4 out of 10 votes were casted.\n///\n/// Majority voting implies that the support threshold is set with\n/// $$\\texttt{supportThresholdRatio} \\ge 50\\% .$$\n/// However, this is not enforced by the contract code and developers can make unsafe parameters and\n/// only the frontend will warn about bad parameter settings.\n///\n/// ### Execution Criteria\n///\n/// After the vote is closed, two criteria decide if the proposal passes.\n///\n/// #### The Support Criterion\n///\n/// For a proposal to pass, the required ratio of yes and no votes must be met:\n/// $$(1- \\texttt{supportThresholdRatio}) \\cdot N_\\text{yes} > \\texttt{supportThresholdRatio} \\cdot N_\\text{no}.$$\n/// Note, that the inequality yields the simple majority voting condition for $\\texttt{supportThresholdRatio}=\\frac{1}{2}$.\n///\n/// #### The Participation Criterion\n///\n/// For a proposal to pass, the minimum voting power must have been cast:\n/// $$N_\\text{yes} + N_\\text{no} + N_\\text{abstain} \\ge \\texttt{minVotingPower},$$\n/// where $\\texttt{minVotingPower} = \\texttt{minParticipationRatio} \\cdot N_\\text{total}$.\n///\n/// ### Vote Replacement\n///\n/// The contract allows votes to be replaced. Voters can vote multiple times\n/// and only the latest voteOption is tallied.\n///\n/// ### Early Execution\n///\n/// This contract allows a proposal to be executed early,\n/// iff the vote outcome cannot change anymore by more people voting.\n/// Accordingly, vote replacement and early execution are mutually exclusive options.\n/// The outcome cannot change anymore\n/// iff the support threshold is met even if all remaining votes are no votes.\n/// We call this number the worst-case number of no votes and define it as\n///\n/// $$N_\\text{no, worst-case} = N_\\text{no} + \\texttt{remainingVotes}$$\n///\n/// where\n///\n/// $$\\texttt{remainingVotes} =\n/// N_\\text{total}-\\underbrace{(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})}_{\\text{turnout}}.$$\n///\n/// We can use this quantity to calculate the worst-case support that would be obtained\n/// if all remaining votes are casted with no:\n///\n/// $$\n/// \\begin{align*}\n///   \\texttt{worstCaseSupport}\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no, worst-case})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no} + \\texttt{remainingVotes})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} +  N_\\text{no} + N_\\text{total}\n///      - (N_\\text{yes} + N_\\text{no} + N_\\text{abstain})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{total} - N_\\text{abstain}}\n/// \\end{align*}\n/// $$\n///\n/// In analogy, we can modify [the support criterion](#the-support-criterion)\n/// from above to allow for early execution:\n///\n/// $$\n/// \\begin{align*}\n///   (1 - \\texttt{supportThresholdRatio}) \\cdot N_\\text{yes}\n///   &> \\texttt{supportThresholdRatio} \\cdot  N_\\text{no, worst-case} \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{no} + \\texttt{remainingVotes}) \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{no}\n///     + N_\\text{total}-(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})) \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{total} - N_\\text{yes} - N_\\text{abstain})\n/// \\end{align*}\n/// $$\n///\n/// Accordingly, early execution is possible when the vote is open,\n///     the modified support criterion, and the particicpation criterion are met.\n/// @dev This contract implements the `IMajorityVoting` interface.\n/// @custom:security-contact sirt@aragon.org\nabstract contract MajorityVotingBase is\n    IMajorityVoting,\n    Initializable,\n    ERC165Upgradeable,\n    MetadataExtensionUpgradeable,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The different voting modes available.\n    /// @param Standard In standard mode, early execution and vote replacement are disabled.\n    /// @param EarlyExecution In early execution mode, a proposal can be executed\n    ///     early before the end date if the vote outcome cannot mathematically change by more voters voting.\n    /// @param VoteReplacement In vote replacement mode, voters can change their vote\n    ///     multiple times and only the latest vote option is tallied.\n    enum VotingMode {\n        Standard,\n        EarlyExecution,\n        VoteReplacement\n    }\n\n    /// @notice A container for the majority voting settings that will be applied as parameters on proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    ///     In standard mode (0), early execution and vote replacement are disabled.\n    ///     In early execution mode (1), a proposal can be executed early before the end date\n    ///     if the vote outcome cannot mathematically change by more voters voting.\n    ///     In vote replacement mode (2), voters can change their vote multiple times\n    ///     and only the latest vote option is tallied.\n    /// @param supportThresholdRatio The support threshold ratio.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minParticipationRatio The minimum participation ratio.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minApprovalRatio The minimum ratio of approvals the proposal needs to succeed.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param proposalDuration The duration of the proposal vote in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    struct VotingSettings {\n        VotingMode votingMode;\n        uint32 supportThresholdRatio;\n        uint32 minParticipationRatio;\n        uint32 minApprovalRatio;\n        uint64 proposalDuration;\n        uint256 minProposerVotingPower;\n    }\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param parameters The proposal parameters at the time of the proposal creation.\n    /// @param tally The vote tally of the proposal.\n    /// @param votes The voting power cast by each voter.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    /// @param targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    struct Proposal {\n        bool executed;\n        ProposalParameters parameters;\n        Tally tally;\n        mapping(address => VoteEntry) votes;\n        Action[] actions;\n        uint256 allowFailureMap;\n        TargetConfig targetConfig;\n    }\n\n    /// @notice A container for the proposal parameters at the time of proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThresholdRatio The support threshold ratio.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param startDate The start date of the proposal vote.\n    /// @param endDate The end date of the proposal vote.\n    /// @param minParticipationRatio The minimum voting power ratio needed for a proposal to reach minimum participation.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minApprovalRatio Minimum ratio of allocated YES votes.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    struct ProposalParameters {\n        VotingMode votingMode;\n        uint32 supportThresholdRatio;\n        uint64 startDate;\n        uint64 endDate;\n        uint256 minParticipationRatio;\n        uint256 minApprovalRatio;\n    }\n\n    /// @notice A container for the proposal vote tally.\n    /// @param abstain The number of abstain votes casted.\n    /// @param yes The number of yes votes casted.\n    /// @param no The number of no votes casted.\n    struct Tally {\n        uint256 abstain;\n        uint256 yes;\n        uint256 no;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MAJORITY_VOTING_BASE_INTERFACE_ID = this.proposalDuration.selector\n        ^ this.minProposerVotingPower.selector ^ this.votingMode.selector ^ this.currentTokenSupply.selector\n        ^ this.getProposal.selector ^ this.updateVotingSettings.selector;\n\n    /// @notice The ID of the permission required to call the `updateVotingSettings` function.\n    bytes32 public constant UPDATE_SETTINGS_PERMISSION_ID = keccak256(\"UPDATE_SETTINGS_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PROPOSAL_PERMISSION_ID = keccak256(\"EXECUTE_PROPOSAL_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    // solhint-disable-next-line named-parameters-mapping\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The struct storing the voting settings.\n    VotingSettings private votingSettings;\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown if the proposal duration value is out of bounds (less than one hour or greater than 1 year).\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error ProposalDurationOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown when a proposal doesn't exist.\n    /// @param proposalId The ID of the proposal which doesn't exist.\n    error NonexistentProposal(uint256 proposalId);\n\n    /// @notice Thrown if an account is not allowed to cast a vote. This can be because the vote\n    /// - has not started,\n    /// - has ended,\n    /// - was executed, or\n    /// - the account doesn't have voting powers.\n    /// @param proposalId The ID of the proposal.\n    /// @param account The address of the _account.\n    error VoteCastForbidden(uint256 proposalId, address account);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Thrown if the proposal with same actions and metadata already exists.\n    /// @param proposalId The id of the proposal.\n    error ProposalAlreadyExists(uint256 proposalId);\n\n    /// @notice Emitted when the voting settings are updated.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThresholdRatio The support threshold ratio.\n    /// @param minParticipationRatio The minimum participation ratio.\n    /// @param minApprovalRatio The minimum ratio of yes votes over the token supply needed for the proposal advance.\n    /// @param proposalDuration The duration of the proposal in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    event VotingSettingsUpdated(\n        VotingMode votingMode,\n        uint32 supportThresholdRatio,\n        uint32 minParticipationRatio,\n        uint32 minApprovalRatio,\n        uint64 proposalDuration,\n        uint256 minProposerVotingPower\n    );\n\n    /// @notice Initializes the component to be used by inheriting contracts.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    // solhint-disable-next-line func-name-mixedcase\n    function __MajorityVotingBase_init(\n        IDAO _dao,\n        VotingSettings calldata _votingSettings,\n        TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) internal onlyInitializing {\n        __PluginUUPSUpgradeable_init(_dao);\n        _updateVotingSettings(_votingSettings);\n        _setTargetConfig(_targetConfig);\n        _setMetadata(_pluginMetadata);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, MetadataExtensionUpgradeable, PluginUUPSUpgradeable, ProposalUpgradeable)\n        returns (bool)\n    {\n        return _interfaceId == MAJORITY_VOTING_BASE_INTERFACE_ID || _interfaceId == type(IMajorityVoting).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `EXECUTE_PROPOSAL_PERMISSION_ID` permission.\n    function execute(uint256 _proposalId)\n        public\n        virtual\n        override(IMajorityVoting, IProposal)\n        auth(EXECUTE_PROPOSAL_PERMISSION_ID)\n    {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function getVote(uint256 _proposalId, address _voter) public view virtual returns (VoteEntry memory) {\n        return (proposals[_proposalId].votes[_voter]);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canExecute(uint256 _proposalId) public view virtual override(IMajorityVoting, IProposal) returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _canExecute(_proposalId);\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function hasSucceeded(uint256 _proposalId) public view virtual returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _hasSucceeded(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The code below implements the formula of the support criterion explained in the top of this file.\n        // `(1 - supportThresholdRatio) * N_yes > supportThresholdRatio *  N_no`\n        return (RATIO_BASE - proposal_.parameters.supportThresholdRatio) * proposal_.tally.yes\n            > proposal_.parameters.supportThresholdRatio * proposal_.tally.no;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReachedEarly(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        uint256 noVotesWorstCase = currentTokenSupply() - proposal_.tally.yes - proposal_.tally.abstain;\n\n        // The code below implements the formula of the\n        // early execution support criterion explained in the top of this file.\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no,worst-case`\n        return (RATIO_BASE - proposal_.parameters.supportThresholdRatio) * proposal_.tally.yes\n            > proposal_.parameters.supportThresholdRatio * noVotesWorstCase;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isMinVotingPowerReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        uint256 _minVotingPower = _applyRatioCeiled(currentTokenSupply(), proposal_.parameters.minParticipationRatio);\n\n        // The code below implements the formula of the\n        // participation criterion explained in the top of this file.\n        // `N_yes + N_no + N_abstain >= minVotingPower = minParticipationRatio * N_total`\n        return proposal_.tally.yes + proposal_.tally.no + proposal_.tally.abstain >= _minVotingPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isMinApprovalReached(uint256 _proposalId) public view virtual returns (bool) {\n        uint256 _minApprovalPower =\n            _applyRatioCeiled(currentTokenSupply(), proposals[_proposalId].parameters.minApprovalRatio);\n        return proposals[_proposalId].tally.yes >= _minApprovalPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function supportThresholdRatio() public view virtual returns (uint32) {\n        return votingSettings.supportThresholdRatio;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function minParticipationRatio() public view virtual returns (uint32) {\n        return votingSettings.minParticipationRatio;\n    }\n\n    /// @notice Returns the proposal duration parameter stored in the voting settings.\n    /// @return The proposal duration in seconds.\n    function proposalDuration() public view virtual returns (uint64) {\n        return votingSettings.proposalDuration;\n    }\n\n    /// @notice Returns the minimum voting power required to create a proposal stored in the voting settings.\n    /// @return The minimum voting power required to create a proposal.\n    function minProposerVotingPower() public view virtual returns (uint256) {\n        return votingSettings.minProposerVotingPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function minApprovalRatio() public view virtual returns (uint256) {\n        return votingSettings.minApprovalRatio;\n    }\n\n    /// @notice Returns the vote mode stored in the voting settings.\n    /// @return The vote mode parameter.\n    function votingMode() public view virtual returns (VotingMode) {\n        return votingSettings.votingMode;\n    }\n\n    /// @notice Returns the current voting settings\n    function getVotingSettings() public view virtual returns (VotingSettings memory) {\n        return votingSettings;\n    }\n\n    /// @notice Returns the current token supply.\n    /// @return The token supply.\n    function currentTokenSupply() public view virtual returns (uint256);\n\n    /// @notice Returns all information for a proposal by its ID.\n    /// @param _proposalId The ID of the proposal.\n    /// @return open Whether the proposal is open or not.\n    /// @return executed Whether the proposal is executed or not.\n    /// @return parameters The parameters of the proposal.\n    /// @return tally The current tally of the proposal.\n    /// @return actions The actions to be executed to the `target` contract address.\n    /// @return allowFailureMap The bit map representations of which actions are allowed to revert so tx still succeeds.\n    /// @return targetConfig Execution configuration, applied to the proposal when it was created. Added in build 3.\n    function getProposal(uint256 _proposalId)\n        public\n        view\n        virtual\n        returns (\n            bool open,\n            bool executed,\n            ProposalParameters memory parameters,\n            Tally memory tally,\n            Action[] memory actions,\n            uint256 allowFailureMap,\n            TargetConfig memory targetConfig\n        )\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        open = _isProposalOpen(proposal_);\n        executed = proposal_.executed;\n        parameters = proposal_.parameters;\n        tally = proposal_.tally;\n        actions = proposal_.actions;\n        allowFailureMap = proposal_.allowFailureMap;\n        targetConfig = proposal_.targetConfig;\n    }\n\n    /// @notice Updates the voting settings.\n    /// @dev Requires the `UPDATE_SETTINGS_PERMISSION_ID` permission.\n    /// @param _votingSettings The new voting settings.\n    function updateVotingSettings(VotingSettings calldata _votingSettings)\n        external\n        virtual\n        auth(UPDATE_SETTINGS_PERMISSION_ID)\n    {\n        _updateVotingSettings(_votingSettings);\n    }\n\n    /// @notice Internal function to execute a proposal. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    function _execute(uint256 _proposalId) internal virtual {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        proposal_.executed = true;\n\n        _execute(\n            proposal_.targetConfig.target,\n            bytes32(_proposalId),\n            proposal_.actions,\n            proposal_.allowFailureMap,\n            proposal_.targetConfig.operation\n        );\n\n        emit ProposalExecuted(_proposalId);\n    }\n\n    /// @notice An internal function that checks if the proposal succeeded or not.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the proposal succeeded depending on the thresholds and voting modes.\n    function _hasSucceeded(uint256 _proposalId) internal view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Support threshold, depending on the status and mode\n        if (_isProposalOpen(proposal_)) {\n            // If the proposal is still open and the voting mode is not EarlyExecution,\n            // success cannot be determined until the voting period ends.\n            if (proposal_.parameters.votingMode != VotingMode.EarlyExecution) {\n                return false;\n            }\n            // For EarlyExecution, check if the support threshold\n            // has been reached early to determine success while proposal is still open.\n            else if (!isSupportThresholdReachedEarly(_proposalId)) {\n                return false;\n            }\n        } else {\n            // Normal execution\n            if (!isSupportThresholdReached(_proposalId)) {\n                return false;\n            }\n        }\n\n        // Check the rest\n        if (!isMinVotingPowerReached(_proposalId)) {\n            return false;\n        } else if (!isMinApprovalReached(_proposalId)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal can be executed. It assumes the queried proposal exists.\n    /// @dev Threshold and minimal values are compared with `>` and `>=` comparators, respectively.\n    /// @param _proposalId The ID of the proposal.\n    /// @return True if the proposal can be executed, false otherwise.\n    function _canExecute(uint256 _proposalId) internal view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Verify that the vote has not been executed already.\n        if (proposal_.executed) {\n            return false;\n        } else if (!_hasSucceeded(_proposalId)) {\n            return false;\n        }\n        /// @dev Handling the case of Standard and VoteReplacement voting modes\n        /// @dev Enforce waiting until endDate, which is not covered by _hasSucceeded()\n        else if (\n            proposal_.parameters.votingMode != VotingMode.EarlyExecution\n                && block.timestamp.toUint64() < proposal_.parameters.endDate\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal is still open.\n    /// @param proposal_ The proposal struct.\n    /// @return True if the proposal is open, false otherwise.\n    function _isProposalOpen(Proposal storage proposal_) internal view virtual returns (bool) {\n        uint64 currentTime = block.timestamp.toUint64();\n\n        return proposal_.parameters.startDate <= currentTime && currentTime < proposal_.parameters.endDate\n            && !proposal_.executed;\n    }\n\n    /// @notice Internal function to update the plugin-wide proposal settings.\n    /// @param _votingSettings The voting settings to be validated and updated.\n    function _updateVotingSettings(VotingSettings calldata _votingSettings) internal virtual {\n        // Require the support threshold value to be in the interval [0, 10^6-1],\n        // because `>` comparison is used in the support criterion and >100% could never be reached.\n        if (_votingSettings.supportThresholdRatio > RATIO_BASE - 1) {\n            revert RatioOutOfBounds({limit: RATIO_BASE - 1, actual: _votingSettings.supportThresholdRatio});\n        }\n        // Require the minimum participation value to be in the interval [0, 10^6],\n        // because `>=` comparison is used in the participation criterion.\n        else if (_votingSettings.minParticipationRatio > RATIO_BASE) {\n            revert RatioOutOfBounds({limit: RATIO_BASE, actual: _votingSettings.minParticipationRatio});\n        } else if (_votingSettings.proposalDuration < 60 minutes) {\n            revert ProposalDurationOutOfBounds({limit: 60 minutes, actual: _votingSettings.proposalDuration});\n        } else if (_votingSettings.proposalDuration > 365 days) {\n            revert ProposalDurationOutOfBounds({limit: 365 days, actual: _votingSettings.proposalDuration});\n        }\n        // Require the minimum approval value to be in the interval [0, 10^6],\n        // because `>=` comparison is used in the participation criterion.\n        else if (_votingSettings.minApprovalRatio > RATIO_BASE) {\n            revert RatioOutOfBounds({limit: RATIO_BASE, actual: _votingSettings.minApprovalRatio});\n        }\n\n        votingSettings = _votingSettings;\n\n        emit VotingSettingsUpdated({\n            votingMode: _votingSettings.votingMode,\n            supportThresholdRatio: _votingSettings.supportThresholdRatio,\n            minParticipationRatio: _votingSettings.minParticipationRatio,\n            proposalDuration: _votingSettings.proposalDuration,\n            minProposerVotingPower: _votingSettings.minProposerVotingPower,\n            minApprovalRatio: _votingSettings.minApprovalRatio\n        });\n    }\n\n    /// @notice Checks if proposal exists or not.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if proposal exists, otherwise false.\n    function _proposalExists(uint256 _proposalId) internal view returns (bool) {\n        return proposals[_proposalId].parameters.startDate != 0;\n    }\n\n    /// @notice Validates and returns the proposal dates.\n    /// @param _start The start date of the proposal.\n    ///     If 0, the current timestamp is used and the vote starts immediately.\n    /// @param _end The end date of the proposal. If 0, `_start + proposalDuration` is used.\n    /// @return startDate The validated start date of the proposal.\n    /// @return endDate The validated end date of the proposal.\n    function _validateProposalDates(uint64 _start, uint64 _end)\n        internal\n        view\n        virtual\n        returns (uint64 startDate, uint64 endDate)\n    {\n        uint64 currentTimestamp = block.timestamp.toUint64();\n\n        if (_start == 0) {\n            startDate = currentTimestamp;\n        } else {\n            startDate = _start;\n\n            if (startDate < currentTimestamp) {\n                revert DateOutOfBounds({limit: currentTimestamp, actual: startDate});\n            }\n        }\n        // Since `proposalDuration` is limited to 1 year,\n        // `startDate + proposalDuration` can only overflow if the `startDate` is after `type(uint64).max - proposalDuration`.\n        // In this case, the proposal creation will revert and another date can be picked.\n        uint64 earliestEndDate = startDate + votingSettings.proposalDuration;\n\n        if (_end == 0) {\n            endDate = earliestEndDate;\n        } else {\n            endDate = _end;\n\n            if (endDate < earliestEndDate) {\n                revert DateOutOfBounds({limit: earliestEndDate, actual: endDate});\n            }\n        }\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}\n",
        "relevance": "Contains _isProposalOpen() at lines 575-579 which returns false for both ended AND not-yet-started proposals. The fix adds a separate _isProposalEnded() function."
      }
    ],
    "call_flow": "User.unlock() -> LockManagerBase._withdrawActiveVotingPower() -> line 225: plugin.isProposalOpen() returns false (not started yet) -> line 226: knownProposalIds.remove() -> proposal starts later -> User.vote() -> User.unlock() succeeds without clearing vote",
    "context_hint": "The _isProposalOpen() function (MajorityVotingBase line 578) checks 'startDate <= currentTime && currentTime < endDate'. This returns false for proposals that haven't started YET. The _withdrawActiveVotingPower() incorrectly uses this to detect ended proposals, causing future-dated proposals to be removed from tracking prematurely.",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_aragon-lock-to-vote_M04",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "M-04",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "medium",
    "vulnerability_type": "access_control",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "Proposal's action should not be able to target the voting contract or the lock manager",
    "finding_description": "The LockToVotePlugin.createProposal() at lines 77-131 does not perform any validation on the actions bound to the proposal. The for loop at lines 121-126 just pushes actions without checking targets. If the plugin's targetConfig is set to execute with delegatecall, actions targeting the LockManager will be executed on behalf of the plugin, allowing attackers to call proposalEnded() to remove active proposals from tracking.",
    "attack_scenario": "1. A 'normal' proposal_1 is created ending in 1 year.\n2. Alice locks 100 tokens, votes NO on proposal_1.\n3. Attacker creates proposal_2 with action: LockManager.proposalEnded(proposal_1_id).\n4. proposal_2 passes and executes.\n5. proposalEnded(proposal_1) is called via delegatecall from the plugin.\n6. proposal_1 is removed from knownProposalIds.\n7. Alice calls unlock() - her NO vote is not cleared because proposal_1 isn't tracked.\n8. Alice withdraws tokens while her vote is still active on proposal_1.",
    "fix_description": "Prevent the creation of new proposals when the action's target is address(this) (the plugin) or address(lockManager). Add validation in createProposal: 'if (_actions[i].to == address(this) || _actions[i].to == address(lockManager)) revert InvalidTarget();'",
    "primary_file": {
      "path": "src/LockToVotePlugin.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.minProposerVotingPower.selector ^ this.createProposal.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 proposalId, address voter);\n\n    error VoteRemovalForbidden(uint256 proposalId, address voter);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function initialize(\n        IDAO _dao,\n        ILockManager _lockManager,\n        VotingSettings calldata _votingSettings,\n        IPlugin.TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(1) {\n        __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n        __LockToGovernBase_init(_lockManager);\n\n        emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IProposal\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint256 _allowFailureMap;\n\n        if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n        }\n\n        if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n        // Store proposal related information\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minParticipationRatio = minParticipationRatio();\n        proposal_.parameters.minApprovalRatio = minApprovalRatio();\n\n        proposal_.targetConfig = getTargetConfig();\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n\n        lockManager.proposalCreated(proposalId);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n    }\n\n    /// @inheritdoc ILockToVote\n    function vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        public\n        override\n        auth(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n        }\n\n        // Same vote\n        if (_voteOption == proposal_.votes[_voter].voteOption) {\n            // Same value, nothing to do\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                proposal_.tally.no += diff;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                proposal_.tally.abstain += diff;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (proposal_.votes[_voter].votingPower > 0) {\n                // Undo that vote\n                if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                    proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n                } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                    proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n                }\n            }\n\n            // Register the new vote\n            if (_voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n                proposal_.tally.no += _newVotingPower;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n        }\n\n        emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n\n        if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        if (!_isProposalOpen(proposal_)) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.votes[_voter].votingPower == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n        } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n        }\n        proposal_.votes[_voter].votingPower = 0;\n\n        emit VoteCleared(_proposalId, _voter);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function isProposalOpen(uint256 _proposalId) external view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _isProposalOpen(proposal_);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.minProposerVotingPower();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function currentTokenSupply() public view override returns (uint256) {\n        return IERC20(lockManager.token()).totalSupply();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\n        return proposals[_proposalId].votes[_voter].votingPower;\n    }\n\n    // Internal helpers\n\n    function _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        } else if (_voteOption == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_newVotingPower <= _currentVotingPower) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                proposal_.votes[_voter].voteOption != VoteOption.None\n                    && _voteOption != proposal_.votes[_voter].voteOption\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\n        if (!_canExecute(_proposalId)) {\n            return;\n        } else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\n            return;\n        }\n\n        _execute(_proposalId);\n    }\n\n    function _execute(uint256 _proposalId) internal override {\n        super._execute(_proposalId);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        lockManager.proposalEnded(_proposalId);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "vulnerable_lines": [
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "vulnerable_functions": [
        "createProposal"
      ]
    },
    "context_files": [
      {
        "path": "src/base/LockManagerBase.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public settings;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public plugin;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private lockedBalances;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal knownProposalIds;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address voter, uint256 amount);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address voter, uint256 amount);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 proposalId);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _settings) {\n        settings.pluginMode = _settings.pluginMode;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function knownProposalIdAt(uint256 _index) public view virtual returns (uint256) {\n        return knownProposalIds.at(_index);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function knownProposalIdsLength() public view virtual returns (uint256) {\n        return knownProposalIds.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function lock() public virtual {\n        _lock(_incomingTokenBalance());\n    }\n\n    /// @inheritdoc ILockManager\n    function lock(uint256 _amount) public virtual {\n        _lock(_amount);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_incomingTokenBalance());\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption, uint256 _amount) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_amount);\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _vote(_proposalId, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function getLockedBalance(address _account) public view virtual returns (uint256) {\n        return lockedBalances[_account];\n    }\n\n    /// @inheritdoc ILockManager\n    function canVote(uint256 _proposalId, address _voter, IMajorityVoting.VoteOption _voteOption)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(plugin)).canVote(_proposalId, _voter, _voteOption);\n    }\n\n    /// @inheritdoc ILockManager\n    function unlock() public virtual {\n        uint256 _refundableBalance = getLockedBalance(msg.sender);\n        if (_refundableBalance == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _withdrawActiveVotingPower();\n\n        // All votes clear\n\n        lockedBalances[msg.sender] = 0;\n\n        // Withdraw\n        _doUnlockTransfer(msg.sender, _refundableBalance);\n        emit BalanceUnlocked(msg.sender, _refundableBalance);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalCreated(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        knownProposalIds.add(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function proposalEnded(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_proposalId);\n        knownProposalIds.remove(_proposalId);\n    }\n\n    /// @inheritdoc ILockManager\n    function setPluginAddress(ILockToGovernBase _newPluginAddress) public virtual {\n        if (address(plugin) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToGovernBase).interfaceId)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            settings.pluginMode == PluginMode.Voting\n                && !IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToVote).interfaceId)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        plugin = _newPluginAddress;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _incomingTokenBalance() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _lock(uint256 _amount) internal virtual {\n        if (_amount == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _doLockTransfer(_amount);\n\n        lockedBalances[msg.sender] += _amount;\n        emit BalanceLocked(msg.sender, _amount);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _doLockTransfer(uint256 _amount) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual;\n\n    function _vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) internal virtual {\n        uint256 _currentVotingPower = getLockedBalance(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(plugin)).vote(_proposalId, msg.sender, _voteOption, _currentVotingPower);\n    }\n\n    function _withdrawActiveVotingPower() internal virtual {\n        uint256 _proposalCount = knownProposalIds.length();\n        for (uint256 _i; _i < _proposalCount;) {\n            uint256 _proposalId = knownProposalIds.at(_i);\n            if (!plugin.isProposalOpen(_proposalId)) {\n                knownProposalIds.remove(_proposalId);\n                _proposalCount = knownProposalIds.length();\n\n                // Were we at the last element?\n                if (_i == _proposalCount) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (plugin.usedVotingPower(_proposalId, msg.sender) > 0) {\n                ILockToVote(address(plugin)).clearVote(_proposalId, msg.sender);\n            }\n\n            unchecked {\n                _i++;\n            }\n        }\n    }\n}\n",
        "relevance": "Contains proposalEnded() at lines 159-166 which can be maliciously invoked via crafted proposal actions to remove active proposals from knownProposalIds tracking."
      }
    ],
    "call_flow": "Attacker.createProposal(actions=[call to LockManager.proposalEnded(victimProposalId)]) -> proposal passes -> execute() -> delegatecall to target -> LockManager.proposalEnded() called from plugin address -> msg.sender check passes -> knownProposalIds.remove()",
    "context_hint": "The createProposal() function at lines 121-126 has a for loop that pushes actions without any validation. Since msg.sender for proposalEnded() is checked against address(plugin), and delegatecall preserves msg.sender, an attacker can craft a proposal that calls LockManager.proposalEnded() to manipulate the governance tracking.",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_aragon-lock-to-vote_M05",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "M-05",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Using idle balance in computing isGranted doesn't account for frozen & blacklisted tokens",
    "finding_description": "In MinVotingPowerCondition.isGranted() at line 45, the function checks 'token.balanceOf(_who) + lockManager.getLockedBalance(_who)'. If an address holds tokens but can't spend them due to being frozen or blacklisted (like USDC/USDT blacklist), they are still granted access to create proposals. The intended behavior should be to not allow calling createProposal as the tokens are not actually transferable.",
    "attack_scenario": "1. User holds 1000 USDC but is blacklisted by Circle.\n2. User cannot actually transfer or lock their tokens.\n3. User calls createProposal().\n4. isGranted() at line 45 checks token.balanceOf(user) which returns 1000.\n5. User passes the minProposerVotingPower check despite having unusable tokens.\n6. User can spam create proposals without genuine stake in governance.",
    "fix_description": "Do not use token.balanceOf(_who), rather actually require the tokens to be locked in LockManager by making a transfer. Only check lockManager.getLockedBalance(_who) for voting power, removing the token.balanceOf() portion.",
    "primary_file": {
      "path": "src/conditions/MinVotingPowerCondition.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable plugin;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable lockManager;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable token;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _plugin) {\n        plugin = _plugin;\n        token = plugin.token();\n        lockManager = plugin.lockManager();\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function isGranted(address _where, address _who, bytes32 _permissionId, bytes calldata _data)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (_where, _data, _permissionId);\n\n        uint256 _currentBalance = token.balanceOf(_who) + lockManager.getLockedBalance(_who);\n        uint256 _minProposerVotingPower = plugin.minProposerVotingPower();\n\n        return _currentBalance >= _minProposerVotingPower;\n    }\n}\n",
      "vulnerable_lines": [
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48
      ],
      "vulnerable_functions": [
        "isGranted"
      ]
    },
    "context_files": [],
    "call_flow": "BlacklistedUser.createProposal() -> PermissionManager.isGranted() -> MinVotingPowerCondition.isGranted() -> line 45: checks token.balanceOf(_who) (high but frozen) + lockManager.getLockedBalance(_who) -> returns true -> proposal created despite no real transferable stake",
    "context_hint": "The isGranted() function at line 45 adds token.balanceOf(_who) to the voting power calculation. For tokens with freeze/blacklist functionality (USDC, USDT, Morpho vault tokens), a user's balance might be frozen but still counted. This allows blacklisted users to participate in governance without transferable stake.",
    "is_vulnerable": true
  },
  {
    "id": "gs_spearbit_aragon-lock-to-vote_M06",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "spearbit",
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "M-06",
    "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
    "contest_date": "2025-09-11",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "currentTokenSupply() can be gamed risk-free to manipulate either side of votes in certain assets",
    "finding_description": "The currentTokenSupply() function at LockToVotePlugin line 249-251 returns IERC20(lockManager.token()).totalSupply(). This is used in threshold checks (isMinVotingPowerReached, isMinApprovalReached). For tokens like ERC4626 shares, flash-mintable tokens (DAI, WETH), or tokens with permissionless minting, attackers can manipulate totalSupply to skew voting thresholds. This is especially impactful during the last block of a proposal.",
    "attack_scenario": "1. A proposal is close to passing based on participation threshold.\n2. Attacker flash-mints large amount of tokens (e.g., via ERC4626 vault deposit).\n3. currentTokenSupply() returns inflated totalSupply.\n4. isMinVotingPowerReached() calculates: votes / inflatedSupply.\n5. Participation ratio appears lower than required.\n6. Proposal that should pass now fails.\n7. Attacker burns/withdraws the tokens in same transaction.",
    "fix_description": "Avoid using currentTotalSupply where it can be skewed. Consider recording totalSupply at proposal creation time. Document token compatibility requirements. Use conservative figures if supply changes significantly.",
    "primary_file": {
      "path": "src/LockToVotePlugin.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.minProposerVotingPower.selector ^ this.createProposal.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 proposalId, address voter);\n\n    error VoteRemovalForbidden(uint256 proposalId, address voter);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function initialize(\n        IDAO _dao,\n        ILockManager _lockManager,\n        VotingSettings calldata _votingSettings,\n        IPlugin.TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(1) {\n        __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n        __LockToGovernBase_init(_lockManager);\n\n        emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IProposal\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint256 _allowFailureMap;\n\n        if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n        }\n\n        if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n        // Store proposal related information\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minParticipationRatio = minParticipationRatio();\n        proposal_.parameters.minApprovalRatio = minApprovalRatio();\n\n        proposal_.targetConfig = getTargetConfig();\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n\n        lockManager.proposalCreated(proposalId);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n    }\n\n    /// @inheritdoc ILockToVote\n    function vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        public\n        override\n        auth(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n        }\n\n        // Same vote\n        if (_voteOption == proposal_.votes[_voter].voteOption) {\n            // Same value, nothing to do\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                proposal_.tally.no += diff;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                proposal_.tally.abstain += diff;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (proposal_.votes[_voter].votingPower > 0) {\n                // Undo that vote\n                if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                    proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n                } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                    proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n                }\n            }\n\n            // Register the new vote\n            if (_voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n                proposal_.tally.no += _newVotingPower;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n        }\n\n        emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n\n        if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        if (!_isProposalOpen(proposal_)) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.votes[_voter].votingPower == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n        } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n        }\n        proposal_.votes[_voter].votingPower = 0;\n\n        emit VoteCleared(_proposalId, _voter);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function isProposalOpen(uint256 _proposalId) external view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _isProposalOpen(proposal_);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.minProposerVotingPower();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function currentTokenSupply() public view override returns (uint256) {\n        return IERC20(lockManager.token()).totalSupply();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\n        return proposals[_proposalId].votes[_voter].votingPower;\n    }\n\n    // Internal helpers\n\n    function _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        } else if (_voteOption == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_newVotingPower <= _currentVotingPower) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                proposal_.votes[_voter].voteOption != VoteOption.None\n                    && _voteOption != proposal_.votes[_voter].voteOption\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\n        if (!_canExecute(_proposalId)) {\n            return;\n        } else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\n            return;\n        }\n\n        _execute(_proposalId);\n    }\n\n    function _execute(uint256 _proposalId) internal override {\n        super._execute(_proposalId);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        lockManager.proposalEnded(_proposalId);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "vulnerable_lines": [
        248,
        249,
        250,
        251
      ],
      "vulnerable_functions": [
        "currentTokenSupply"
      ]
    },
    "context_files": [
      {
        "path": "src/base/MajorityVotingBase.sol",
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/* solhint-disable max-line-length */\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {ProposalUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/ProposalUpgradeable.sol\";\nimport {RATIO_BASE, RatioOutOfBounds} from \"@aragon/osx-commons-contracts/src/utils/math/Ratio.sol\";\nimport {PluginUUPSUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {MetadataExtensionUpgradeable} from\n    \"@aragon/osx-commons-contracts/src/utils/metadata/MetadataExtensionUpgradeable.sol\";\nimport {_applyRatioCeiled} from \"@aragon/osx-commons-contracts/src/utils/math/Ratio.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\n\n/* solhint-enable max-line-length */\n\n/// @title MajorityVotingBase\n/// @author Aragon X - 2022-2025\n/// @notice The abstract implementation of majority voting plugins.\n///\n/// ### Parameterization\n///\n/// We define two parameters\n/// $$\\texttt{support} = \\frac{N_\\text{yes}}{N_\\text{yes} + N_\\text{no}} \\in [0,1]$$\n/// and\n/// $$\\texttt{participation} = \\frac{N_\\text{yes} + N_\\text{no} + N_\\text{abstain}}{N_\\text{total}} \\in [0,1],$$\n/// where $N_\\text{yes}$, $N_\\text{no}$, and $N_\\text{abstain}$ are the yes, no, and abstain votes that have been\n/// cast and $N_\\text{total}$ is the total voting power available at proposal creation time.\n///\n/// #### Limit Values: Support Threshold & Minimum Participation\n///\n/// Two limit values are associated with these parameters and decide if a proposal execution should be possible:\n/// $\\texttt{supportThresholdRatio} \\in [0,1)$ and $\\texttt{minParticipationRatio} \\in [0,1]$.\n///\n/// For threshold values, $>$ comparison is used. This **does not** include the threshold value.\n/// E.g., for $\\texttt{supportThresholdRatio} = 50\\%$,\n/// the criterion is fulfilled if there is at least one more yes than no votes ($N_\\text{yes} = N_\\text{no} + 1$).\n/// For minimum values, $\\ge{}$ comparison is used. This **does** include the minimum participation value.\n/// E.g., for $\\texttt{minParticipationRatio} = 40\\%$ and $N_\\text{total} = 10$,\n/// the criterion is fulfilled if 4 out of 10 votes were casted.\n///\n/// Majority voting implies that the support threshold is set with\n/// $$\\texttt{supportThresholdRatio} \\ge 50\\% .$$\n/// However, this is not enforced by the contract code and developers can make unsafe parameters and\n/// only the frontend will warn about bad parameter settings.\n///\n/// ### Execution Criteria\n///\n/// After the vote is closed, two criteria decide if the proposal passes.\n///\n/// #### The Support Criterion\n///\n/// For a proposal to pass, the required ratio of yes and no votes must be met:\n/// $$(1- \\texttt{supportThresholdRatio}) \\cdot N_\\text{yes} > \\texttt{supportThresholdRatio} \\cdot N_\\text{no}.$$\n/// Note, that the inequality yields the simple majority voting condition for $\\texttt{supportThresholdRatio}=\\frac{1}{2}$.\n///\n/// #### The Participation Criterion\n///\n/// For a proposal to pass, the minimum voting power must have been cast:\n/// $$N_\\text{yes} + N_\\text{no} + N_\\text{abstain} \\ge \\texttt{minVotingPower},$$\n/// where $\\texttt{minVotingPower} = \\texttt{minParticipationRatio} \\cdot N_\\text{total}$.\n///\n/// ### Vote Replacement\n///\n/// The contract allows votes to be replaced. Voters can vote multiple times\n/// and only the latest voteOption is tallied.\n///\n/// ### Early Execution\n///\n/// This contract allows a proposal to be executed early,\n/// iff the vote outcome cannot change anymore by more people voting.\n/// Accordingly, vote replacement and early execution are mutually exclusive options.\n/// The outcome cannot change anymore\n/// iff the support threshold is met even if all remaining votes are no votes.\n/// We call this number the worst-case number of no votes and define it as\n///\n/// $$N_\\text{no, worst-case} = N_\\text{no} + \\texttt{remainingVotes}$$\n///\n/// where\n///\n/// $$\\texttt{remainingVotes} =\n/// N_\\text{total}-\\underbrace{(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})}_{\\text{turnout}}.$$\n///\n/// We can use this quantity to calculate the worst-case support that would be obtained\n/// if all remaining votes are casted with no:\n///\n/// $$\n/// \\begin{align*}\n///   \\texttt{worstCaseSupport}\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no, worst-case})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no} + \\texttt{remainingVotes})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} +  N_\\text{no} + N_\\text{total}\n///      - (N_\\text{yes} + N_\\text{no} + N_\\text{abstain})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{total} - N_\\text{abstain}}\n/// \\end{align*}\n/// $$\n///\n/// In analogy, we can modify [the support criterion](#the-support-criterion)\n/// from above to allow for early execution:\n///\n/// $$\n/// \\begin{align*}\n///   (1 - \\texttt{supportThresholdRatio}) \\cdot N_\\text{yes}\n///   &> \\texttt{supportThresholdRatio} \\cdot  N_\\text{no, worst-case} \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{no} + \\texttt{remainingVotes}) \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{no}\n///     + N_\\text{total}-(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})) \\\\[3mm]\n///   &> \\texttt{supportThresholdRatio} \\cdot (N_\\text{total} - N_\\text{yes} - N_\\text{abstain})\n/// \\end{align*}\n/// $$\n///\n/// Accordingly, early execution is possible when the vote is open,\n///     the modified support criterion, and the particicpation criterion are met.\n/// @dev This contract implements the `IMajorityVoting` interface.\n/// @custom:security-contact sirt@aragon.org\nabstract contract MajorityVotingBase is\n    IMajorityVoting,\n    Initializable,\n    ERC165Upgradeable,\n    MetadataExtensionUpgradeable,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The different voting modes available.\n    /// @param Standard In standard mode, early execution and vote replacement are disabled.\n    /// @param EarlyExecution In early execution mode, a proposal can be executed\n    ///     early before the end date if the vote outcome cannot mathematically change by more voters voting.\n    /// @param VoteReplacement In vote replacement mode, voters can change their vote\n    ///     multiple times and only the latest vote option is tallied.\n    enum VotingMode {\n        Standard,\n        EarlyExecution,\n        VoteReplacement\n    }\n\n    /// @notice A container for the majority voting settings that will be applied as parameters on proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    ///     In standard mode (0), early execution and vote replacement are disabled.\n    ///     In early execution mode (1), a proposal can be executed early before the end date\n    ///     if the vote outcome cannot mathematically change by more voters voting.\n    ///     In vote replacement mode (2), voters can change their vote multiple times\n    ///     and only the latest vote option is tallied.\n    /// @param supportThresholdRatio The support threshold ratio.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minParticipationRatio The minimum participation ratio.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minApprovalRatio The minimum ratio of approvals the proposal needs to succeed.\n    ///     Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param proposalDuration The duration of the proposal vote in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    struct VotingSettings {\n        VotingMode votingMode;\n        uint32 supportThresholdRatio;\n        uint32 minParticipationRatio;\n        uint32 minApprovalRatio;\n        uint64 proposalDuration;\n        uint256 minProposerVotingPower;\n    }\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param parameters The proposal parameters at the time of the proposal creation.\n    /// @param tally The vote tally of the proposal.\n    /// @param votes The voting power cast by each voter.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    /// @param targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    struct Proposal {\n        bool executed;\n        ProposalParameters parameters;\n        Tally tally;\n        mapping(address => VoteEntry) votes;\n        Action[] actions;\n        uint256 allowFailureMap;\n        TargetConfig targetConfig;\n    }\n\n    /// @notice A container for the proposal parameters at the time of proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThresholdRatio The support threshold ratio.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param startDate The start date of the proposal vote.\n    /// @param endDate The end date of the proposal vote.\n    /// @param minParticipationRatio The minimum voting power ratio needed for a proposal to reach minimum participation.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minApprovalRatio Minimum ratio of allocated YES votes.\n    ///     The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    struct ProposalParameters {\n        VotingMode votingMode;\n        uint32 supportThresholdRatio;\n        uint64 startDate;\n        uint64 endDate;\n        uint256 minParticipationRatio;\n        uint256 minApprovalRatio;\n    }\n\n    /// @notice A container for the proposal vote tally.\n    /// @param abstain The number of abstain votes casted.\n    /// @param yes The number of yes votes casted.\n    /// @param no The number of no votes casted.\n    struct Tally {\n        uint256 abstain;\n        uint256 yes;\n        uint256 no;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MAJORITY_VOTING_BASE_INTERFACE_ID = this.proposalDuration.selector\n        ^ this.minProposerVotingPower.selector ^ this.votingMode.selector ^ this.currentTokenSupply.selector\n        ^ this.getProposal.selector ^ this.updateVotingSettings.selector;\n\n    /// @notice The ID of the permission required to call the `updateVotingSettings` function.\n    bytes32 public constant UPDATE_SETTINGS_PERMISSION_ID = keccak256(\"UPDATE_SETTINGS_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PROPOSAL_PERMISSION_ID = keccak256(\"EXECUTE_PROPOSAL_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    // solhint-disable-next-line named-parameters-mapping\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The struct storing the voting settings.\n    VotingSettings private votingSettings;\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown if the proposal duration value is out of bounds (less than one hour or greater than 1 year).\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error ProposalDurationOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown when a proposal doesn't exist.\n    /// @param proposalId The ID of the proposal which doesn't exist.\n    error NonexistentProposal(uint256 proposalId);\n\n    /// @notice Thrown if an account is not allowed to cast a vote. This can be because the vote\n    /// - has not started,\n    /// - has ended,\n    /// - was executed, or\n    /// - the account doesn't have voting powers.\n    /// @param proposalId The ID of the proposal.\n    /// @param account The address of the _account.\n    error VoteCastForbidden(uint256 proposalId, address account);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Thrown if the proposal with same actions and metadata already exists.\n    /// @param proposalId The id of the proposal.\n    error ProposalAlreadyExists(uint256 proposalId);\n\n    /// @notice Emitted when the voting settings are updated.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThresholdRatio The support threshold ratio.\n    /// @param minParticipationRatio The minimum participation ratio.\n    /// @param minApprovalRatio The minimum ratio of yes votes over the token supply needed for the proposal advance.\n    /// @param proposalDuration The duration of the proposal in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    event VotingSettingsUpdated(\n        VotingMode votingMode,\n        uint32 supportThresholdRatio,\n        uint32 minParticipationRatio,\n        uint32 minApprovalRatio,\n        uint64 proposalDuration,\n        uint256 minProposerVotingPower\n    );\n\n    /// @notice Initializes the component to be used by inheriting contracts.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    // solhint-disable-next-line func-name-mixedcase\n    function __MajorityVotingBase_init(\n        IDAO _dao,\n        VotingSettings calldata _votingSettings,\n        TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) internal onlyInitializing {\n        __PluginUUPSUpgradeable_init(_dao);\n        _updateVotingSettings(_votingSettings);\n        _setTargetConfig(_targetConfig);\n        _setMetadata(_pluginMetadata);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, MetadataExtensionUpgradeable, PluginUUPSUpgradeable, ProposalUpgradeable)\n        returns (bool)\n    {\n        return _interfaceId == MAJORITY_VOTING_BASE_INTERFACE_ID || _interfaceId == type(IMajorityVoting).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `EXECUTE_PROPOSAL_PERMISSION_ID` permission.\n    function execute(uint256 _proposalId)\n        public\n        virtual\n        override(IMajorityVoting, IProposal)\n        auth(EXECUTE_PROPOSAL_PERMISSION_ID)\n    {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function getVote(uint256 _proposalId, address _voter) public view virtual returns (VoteEntry memory) {\n        return (proposals[_proposalId].votes[_voter]);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canExecute(uint256 _proposalId) public view virtual override(IMajorityVoting, IProposal) returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _canExecute(_proposalId);\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function hasSucceeded(uint256 _proposalId) public view virtual returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _hasSucceeded(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The code below implements the formula of the support criterion explained in the top of this file.\n        // `(1 - supportThresholdRatio) * N_yes > supportThresholdRatio *  N_no`\n        return (RATIO_BASE - proposal_.parameters.supportThresholdRatio) * proposal_.tally.yes\n            > proposal_.parameters.supportThresholdRatio * proposal_.tally.no;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReachedEarly(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        uint256 noVotesWorstCase = currentTokenSupply() - proposal_.tally.yes - proposal_.tally.abstain;\n\n        // The code below implements the formula of the\n        // early execution support criterion explained in the top of this file.\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no,worst-case`\n        return (RATIO_BASE - proposal_.parameters.supportThresholdRatio) * proposal_.tally.yes\n            > proposal_.parameters.supportThresholdRatio * noVotesWorstCase;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isMinVotingPowerReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        uint256 _minVotingPower = _applyRatioCeiled(currentTokenSupply(), proposal_.parameters.minParticipationRatio);\n\n        // The code below implements the formula of the\n        // participation criterion explained in the top of this file.\n        // `N_yes + N_no + N_abstain >= minVotingPower = minParticipationRatio * N_total`\n        return proposal_.tally.yes + proposal_.tally.no + proposal_.tally.abstain >= _minVotingPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isMinApprovalReached(uint256 _proposalId) public view virtual returns (bool) {\n        uint256 _minApprovalPower =\n            _applyRatioCeiled(currentTokenSupply(), proposals[_proposalId].parameters.minApprovalRatio);\n        return proposals[_proposalId].tally.yes >= _minApprovalPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function supportThresholdRatio() public view virtual returns (uint32) {\n        return votingSettings.supportThresholdRatio;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function minParticipationRatio() public view virtual returns (uint32) {\n        return votingSettings.minParticipationRatio;\n    }\n\n    /// @notice Returns the proposal duration parameter stored in the voting settings.\n    /// @return The proposal duration in seconds.\n    function proposalDuration() public view virtual returns (uint64) {\n        return votingSettings.proposalDuration;\n    }\n\n    /// @notice Returns the minimum voting power required to create a proposal stored in the voting settings.\n    /// @return The minimum voting power required to create a proposal.\n    function minProposerVotingPower() public view virtual returns (uint256) {\n        return votingSettings.minProposerVotingPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function minApprovalRatio() public view virtual returns (uint256) {\n        return votingSettings.minApprovalRatio;\n    }\n\n    /// @notice Returns the vote mode stored in the voting settings.\n    /// @return The vote mode parameter.\n    function votingMode() public view virtual returns (VotingMode) {\n        return votingSettings.votingMode;\n    }\n\n    /// @notice Returns the current voting settings\n    function getVotingSettings() public view virtual returns (VotingSettings memory) {\n        return votingSettings;\n    }\n\n    /// @notice Returns the current token supply.\n    /// @return The token supply.\n    function currentTokenSupply() public view virtual returns (uint256);\n\n    /// @notice Returns all information for a proposal by its ID.\n    /// @param _proposalId The ID of the proposal.\n    /// @return open Whether the proposal is open or not.\n    /// @return executed Whether the proposal is executed or not.\n    /// @return parameters The parameters of the proposal.\n    /// @return tally The current tally of the proposal.\n    /// @return actions The actions to be executed to the `target` contract address.\n    /// @return allowFailureMap The bit map representations of which actions are allowed to revert so tx still succeeds.\n    /// @return targetConfig Execution configuration, applied to the proposal when it was created. Added in build 3.\n    function getProposal(uint256 _proposalId)\n        public\n        view\n        virtual\n        returns (\n            bool open,\n            bool executed,\n            ProposalParameters memory parameters,\n            Tally memory tally,\n            Action[] memory actions,\n            uint256 allowFailureMap,\n            TargetConfig memory targetConfig\n        )\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        open = _isProposalOpen(proposal_);\n        executed = proposal_.executed;\n        parameters = proposal_.parameters;\n        tally = proposal_.tally;\n        actions = proposal_.actions;\n        allowFailureMap = proposal_.allowFailureMap;\n        targetConfig = proposal_.targetConfig;\n    }\n\n    /// @notice Updates the voting settings.\n    /// @dev Requires the `UPDATE_SETTINGS_PERMISSION_ID` permission.\n    /// @param _votingSettings The new voting settings.\n    function updateVotingSettings(VotingSettings calldata _votingSettings)\n        external\n        virtual\n        auth(UPDATE_SETTINGS_PERMISSION_ID)\n    {\n        _updateVotingSettings(_votingSettings);\n    }\n\n    /// @notice Internal function to execute a proposal. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    function _execute(uint256 _proposalId) internal virtual {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        proposal_.executed = true;\n\n        _execute(\n            proposal_.targetConfig.target,\n            bytes32(_proposalId),\n            proposal_.actions,\n            proposal_.allowFailureMap,\n            proposal_.targetConfig.operation\n        );\n\n        emit ProposalExecuted(_proposalId);\n    }\n\n    /// @notice An internal function that checks if the proposal succeeded or not.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the proposal succeeded depending on the thresholds and voting modes.\n    function _hasSucceeded(uint256 _proposalId) internal view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Support threshold, depending on the status and mode\n        if (_isProposalOpen(proposal_)) {\n            // If the proposal is still open and the voting mode is not EarlyExecution,\n            // success cannot be determined until the voting period ends.\n            if (proposal_.parameters.votingMode != VotingMode.EarlyExecution) {\n                return false;\n            }\n            // For EarlyExecution, check if the support threshold\n            // has been reached early to determine success while proposal is still open.\n            else if (!isSupportThresholdReachedEarly(_proposalId)) {\n                return false;\n            }\n        } else {\n            // Normal execution\n            if (!isSupportThresholdReached(_proposalId)) {\n                return false;\n            }\n        }\n\n        // Check the rest\n        if (!isMinVotingPowerReached(_proposalId)) {\n            return false;\n        } else if (!isMinApprovalReached(_proposalId)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal can be executed. It assumes the queried proposal exists.\n    /// @dev Threshold and minimal values are compared with `>` and `>=` comparators, respectively.\n    /// @param _proposalId The ID of the proposal.\n    /// @return True if the proposal can be executed, false otherwise.\n    function _canExecute(uint256 _proposalId) internal view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Verify that the vote has not been executed already.\n        if (proposal_.executed) {\n            return false;\n        } else if (!_hasSucceeded(_proposalId)) {\n            return false;\n        }\n        /// @dev Handling the case of Standard and VoteReplacement voting modes\n        /// @dev Enforce waiting until endDate, which is not covered by _hasSucceeded()\n        else if (\n            proposal_.parameters.votingMode != VotingMode.EarlyExecution\n                && block.timestamp.toUint64() < proposal_.parameters.endDate\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal is still open.\n    /// @param proposal_ The proposal struct.\n    /// @return True if the proposal is open, false otherwise.\n    function _isProposalOpen(Proposal storage proposal_) internal view virtual returns (bool) {\n        uint64 currentTime = block.timestamp.toUint64();\n\n        return proposal_.parameters.startDate <= currentTime && currentTime < proposal_.parameters.endDate\n            && !proposal_.executed;\n    }\n\n    /// @notice Internal function to update the plugin-wide proposal settings.\n    /// @param _votingSettings The voting settings to be validated and updated.\n    function _updateVotingSettings(VotingSettings calldata _votingSettings) internal virtual {\n        // Require the support threshold value to be in the interval [0, 10^6-1],\n        // because `>` comparison is used in the support criterion and >100% could never be reached.\n        if (_votingSettings.supportThresholdRatio > RATIO_BASE - 1) {\n            revert RatioOutOfBounds({limit: RATIO_BASE - 1, actual: _votingSettings.supportThresholdRatio});\n        }\n        // Require the minimum participation value to be in the interval [0, 10^6],\n        // because `>=` comparison is used in the participation criterion.\n        else if (_votingSettings.minParticipationRatio > RATIO_BASE) {\n            revert RatioOutOfBounds({limit: RATIO_BASE, actual: _votingSettings.minParticipationRatio});\n        } else if (_votingSettings.proposalDuration < 60 minutes) {\n            revert ProposalDurationOutOfBounds({limit: 60 minutes, actual: _votingSettings.proposalDuration});\n        } else if (_votingSettings.proposalDuration > 365 days) {\n            revert ProposalDurationOutOfBounds({limit: 365 days, actual: _votingSettings.proposalDuration});\n        }\n        // Require the minimum approval value to be in the interval [0, 10^6],\n        // because `>=` comparison is used in the participation criterion.\n        else if (_votingSettings.minApprovalRatio > RATIO_BASE) {\n            revert RatioOutOfBounds({limit: RATIO_BASE, actual: _votingSettings.minApprovalRatio});\n        }\n\n        votingSettings = _votingSettings;\n\n        emit VotingSettingsUpdated({\n            votingMode: _votingSettings.votingMode,\n            supportThresholdRatio: _votingSettings.supportThresholdRatio,\n            minParticipationRatio: _votingSettings.minParticipationRatio,\n            proposalDuration: _votingSettings.proposalDuration,\n            minProposerVotingPower: _votingSettings.minProposerVotingPower,\n            minApprovalRatio: _votingSettings.minApprovalRatio\n        });\n    }\n\n    /// @notice Checks if proposal exists or not.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if proposal exists, otherwise false.\n    function _proposalExists(uint256 _proposalId) internal view returns (bool) {\n        return proposals[_proposalId].parameters.startDate != 0;\n    }\n\n    /// @notice Validates and returns the proposal dates.\n    /// @param _start The start date of the proposal.\n    ///     If 0, the current timestamp is used and the vote starts immediately.\n    /// @param _end The end date of the proposal. If 0, `_start + proposalDuration` is used.\n    /// @return startDate The validated start date of the proposal.\n    /// @return endDate The validated end date of the proposal.\n    function _validateProposalDates(uint64 _start, uint64 _end)\n        internal\n        view\n        virtual\n        returns (uint64 startDate, uint64 endDate)\n    {\n        uint64 currentTimestamp = block.timestamp.toUint64();\n\n        if (_start == 0) {\n            startDate = currentTimestamp;\n        } else {\n            startDate = _start;\n\n            if (startDate < currentTimestamp) {\n                revert DateOutOfBounds({limit: currentTimestamp, actual: startDate});\n            }\n        }\n        // Since `proposalDuration` is limited to 1 year,\n        // `startDate + proposalDuration` can only overflow if the `startDate` is after `type(uint64).max - proposalDuration`.\n        // In this case, the proposal creation will revert and another date can be picked.\n        uint64 earliestEndDate = startDate + votingSettings.proposalDuration;\n\n        if (_end == 0) {\n            endDate = earliestEndDate;\n        } else {\n            endDate = _end;\n\n            if (endDate < earliestEndDate) {\n                revert DateOutOfBounds({limit: earliestEndDate, actual: endDate});\n            }\n        }\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}\n",
        "relevance": "Contains isMinVotingPowerReached() and isMinApprovalReached() which call currentTokenSupply(). These functions are called during _hasSucceeded() checks to determine if a proposal can be executed."
      }
    ],
    "call_flow": "Attacker.flashMint() -> totalSupply increases -> proposal.execute() -> MajorityVotingBase._hasSucceeded() -> isMinVotingPowerReached() -> currentTokenSupply() returns inflated value -> participation check fails -> Attacker.flashBurn()",
    "context_hint": "The currentTokenSupply() at lines 249-251 returns IERC20.totalSupply() directly. For tokens where supply can be atomically manipulated (flash-mintable, ERC4626 shares), attackers can inflate/deflate supply during threshold calculations. This allows gaming the participation and approval requirements, especially on the last block of voting.",
    "is_vulnerable": true
  }
]